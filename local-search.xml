<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>存储论</title>
    <link href="/2025/01/21/%E5%AD%98%E5%82%A8%E8%AE%BA/"/>
    <url>/2025/01/21/%E5%AD%98%E5%82%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="存储论">存储论</h2><h3 id="基本概念">基本概念</h3><p>存储问题的费用：</p><ul><li>生产费：<ul><li>订购费：与订货次数有关，一般固定</li><li>货物成本费：与订货数量有关，一般变动</li></ul></li><li>生产费<ul><li>装配费：与生产次数有关，一般固定</li><li>生产成本费：与生产数量有关，一般变动</li></ul></li><li>存储费</li><li>缺货费</li></ul><p>储存模型：</p><ul><li>需求是否确定：确定型存储模型，随机型存储模型</li><li>订货还是生产：批量订货（备货时间短），批量生产（生产需时间）</li><li>允不允许缺货：允许缺货，不允许缺货</li></ul><h3id="不允许缺货瞬时到货模型经济订货批量模型">不允许缺货、瞬时到货模型（经济订货批量模型）</h3><h4 id="模型基本假设">模型基本假设</h4><ol type="1"><li>不允许缺货，缺货费正无穷</li><li>存储量为零时，可<strong>立即</strong>得到补充</li><li>需求是连续均匀的，需求速度为常数 <spanclass="math inline">\(R\)</span></li><li>每次订货量不变，订购费不变</li><li>单位时间的存储</li></ol><h4 id="模型计算">模型计算</h4><p>假设每次订货的订购费用为 <span class="math inline">\(c_3\)</span></p><p>假设 <span class="math inline">\(货物成本费 = 成本费单价 \times订货量=KQ=KRt\)</span></p><p>其中 <span class="math inline">\(K\)</span> 为货物成本费单价，<spanclass="math inline">\(Q\)</span> 为订货量，<spanclass="math inline">\(R\)</span> 为需求速度，<spanclass="math inline">\(t\)</span> 为每间隔时间 <spanclass="math inline">\(t\)</span> 补充一次存储</p><p>存储费：<span class="math inline">\(t\)</span>时间内的平均存储量：<span class="math inline">\(\frac{1}{2}Q =\frac{1}{2}Rt\)</span>，我们在这里假设单位时间内单位货物存储费为 <spanclass="math inline">\(c_1\)</span></p><p>怎么来的呢？求积分得到上面的式子的：<spanclass="math inline">\(\dfrac{存储量之和}{t} =\dfrac{\int_{0}^{t}RT\,dT}{t} = \dfrac{1}{2}Rt\)</span></p><p>那么我们的 <span class="math inline">\(t\)</span>时间内的总平均费用（一般省略 <span class="math inline">\(KR\)</span>）：<span class="math display">\[C(t)=\frac{c_3}{t} + KR + \frac{1}{2}Rtc_1\]</span> 我们用这个式子对 <span class="math inline">\(t\)</span>求一次导数，求极值点</p><p>得到最优订货周期为：<span class="math inline">\(t_0 =\sqrt{\dfrac{2c_3}{c_1R}}\)</span></p><p>最优订货量：<span class="math inline">\(Q_0 = Rt_0 =\sqrt{\dfrac{2c_3R}{c_1}}\)</span></p><h3 id="不允许缺货逐步均匀到货模型">不允许缺货，逐步均匀到货模型</h3><h4 id="模型基本假设-1">模型基本假设</h4><ol type="1"><li>不允许缺货，缺货费正无穷</li><li>存储量为零时开始生产，生产速度为常数 <spanclass="math inline">\(P\)</span></li><li>需求是连续均匀的，需求速度为常数 <spanclass="math inline">\(R\)</span></li><li>每次订货量不变，装配费不变</li><li>单位时间的存储费不变</li></ol><h4 id="模型计算-1">模型计算</h4><p>首先假设每次生产的装配费用为 <spanclass="math inline">\(c_3\)</span>，那么 <spanclass="math inline">\(t\)</span> 时间内平均装配费为 <spanclass="math inline">\(\frac{c_3}{t}\)</span></p><p><span class="math inline">\(t\)</span>时间内的平均<strong>存储量</strong>为：<spanclass="math inline">\(\frac{1}{2}(P-R)t_1\)</span>，其中 <spanclass="math inline">\(t_1\)</span> 是所需生产时间</p><p>我们用 <span class="math inline">\(t \tot_0\)</span>，那么平均<strong>储存费</strong>就等于 <spanclass="math inline">\(\dfrac{c_1R(P-R)}{2P}t\)</span></p><p>那么将两个加在一起就是总平均费用： <span class="math display">\[C(t) = \frac{c_3}{t} + \frac{c_1 R(P-R)}{2P} t\]</span> 求极值点，那么可得最优周期为：<span class="math inline">\(t_0= \sqrt{\dfrac{2c_3P}{c_1 R (P - R)}}\)</span></p><p>最优生产量为：<span class="math inline">\(Q_0 =\sqrt{\dfrac{2c_3PR}{c_1(P-R)}}\)</span></p><p>最小总平均费用为：<span class="math inline">\(C_0 =\sqrt{2c_1c_3R\dfrac{P-R}{P}}\)</span></p><h3 id="允许缺货瞬时到货模型">允许缺货，瞬时到货模型</h3><h4 id="模型基本假设-2">模型基本假设</h4><ol type="1"><li>允许缺货</li><li>备货时间很短，可立即得到补充</li><li>需求是连续均匀的，需求速度为常数 <spanclass="math inline">\(R\)</span></li><li>每次订货量不变，订购费不变</li><li>单位时间内的存储费不变</li></ol><h4 id="模型计算-2">模型计算</h4><p>我们只算一个周期 <span class="math inline">\(t\)</span>的一个费用。</p><p>假设每次订货的订购费用为 <span class="math inline">\(c_3\)</span>，单位存储费为 <span class="math inline">\(c_1\)</span></p><p>那么储存费为 <spanclass="math inline">\(\frac{1}{2}c_1\frac{S^2}{R}\)</span>，其中 <spanclass="math inline">\(S = Rt_1\)</span>，<spanclass="math inline">\(t_1\)</span> 表示有货的那段时间</p><p>假设单位时间内单位物品缺货费为 <spanclass="math inline">\(c_2\)</span></p><p>那么总缺货费为 <span class="math inline">\(\frac{1}{2} c_2 \frac{(Rt-S)^2}{R}\)</span></p><p>那么我们总的费用就是三项加起来： <span class="math display">\[C(t) = \frac{1}{2}c_1\frac{S^2}{R}+\frac{1}{2}c_2\frac{(Rt-S)^2}{R}+c_3\]</span> 多元函数求极值，得到最优周期为：<spanclass="math inline">\(t_0 =\sqrt{\dfrac{2c_3(c_1+c_2)}{c_1c_2R}}\)</span></p><p>最大存储量：<span class="math inline">\(S_0 =\sqrt{\dfrac{2c_2c_3R}{c_1(c_1+c_2)}}\)</span></p><p>最优进货量：<span class="math inline">\(Q_0 =\sqrt{\dfrac{2Rc_3(c_1+c_2)}{c_1c_2}}\)</span></p><p>最小总平均费用：<span class="math inline">\(C_0 =\sqrt{\dfrac{2c_1c_2c_3R}{c_1 + c_2}}\)</span></p><p>观察第一个模型与这个的区别，其实可以发现其实第一个的式子就是这个的特殊情况，将<spanclass="math inline">\(c_2\to +\infty,\dfrac{c_2}{c_1+c_3} \to 1\)</span>加上。</p><h3 id="允许缺货逐步均匀到货模型">允许缺货，逐步均匀到货模型</h3><h4 id="模型基本假设-3">模型基本假设</h4><ol type="1"><li>允许缺货</li><li>生产需一定时间，生产速度为常数 <spanclass="math inline">\(P\)</span></li><li>需求是连续均匀的，需求速度为常数 <spanclass="math inline">\(R\)</span></li><li>每次订货量不变，装配费不变</li><li>单位时间的存储费不变</li></ol><p>首先假设每次生产的装配费用为 <spanclass="math inline">\(c_3\)</span>，单位时间内单位物品缺货费为 <spanclass="math inline">\(c_2\)</span>，那么 <spanclass="math inline">\(t\)</span> 时间内平均装配费为 <spanclass="math inline">\(\frac{c_3}{t}\)</span>，其中 <spanclass="math inline">\(t_2\)</span> 表示从开始到库存里有货这一段时间</p><p><span class="math inline">\(t\)</span> 时间内的总存储费为：<spanclass="math inline">\(\dfrac{1}{2}c_1\dfrac{R(P-R)}{P}(t-t_2)^2\)</span></p><p><span class="math inline">\(t\)</span> 时间内的总缺货费：<spanclass="math inline">\(\dfrac{1}{2}c_2\dfrac{R(P-R)}{P}t_2^2\)</span></p><p>那么我们总的费用就是三项加起来： <span class="math display">\[C(t) =\frac{1}{2}c_1\frac{R(P-R)}{P}(t-t_2)^2+\frac{1}{2}c_2\frac{R(P-R)}{P}t_2^2+c_3\]</span> 多元函数求极值，可得最优生产量为：<spanclass="math inline">\(Q_0 =\sqrt{\dfrac{2c_3(c_1+c_2)PR}{c_1c_2(P-R)}}\)</span></p><p>最大储存量为：<span class="math inline">\(S_0 =\sqrt{\dfrac{2c_2c_3R(P-R)}{c_1(c_1+c_2)P}}\)</span></p><p>最小总平均费用：<span class="math inline">\(C_0 =\sqrt{\dfrac{2c_1c_2c_3R(P-R)}{c_1(c_1+c_2)P}}\)</span></p><p>最大缺货量：<span class="math inline">\(B_0 =\sqrt{\dfrac{2c_1c_3R(P-R)}{c_2(c_1+c_2)P}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>存储论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分析并查集的时间复杂度</title>
    <link href="/2025/01/20/%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2025/01/20/%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并查集的时间复杂度">并查集的时间复杂度</h1><p>其实自从高二开始学习并查集就发现这个数据结构真的奇妙，能解决许多问题，但是对时间复杂度就不太理解，大二退役之后我开始想去知道为什么是这个奇妙的时间复杂度，遂有此文。</p><p>本文参考了：<a href="https://oiwiki.org/ds/dsu/">OI-Wiki</a>，<ahref="https://www.coursera.org/lecture/algorithms-greedy/path-compression-the-hopcroft-ullman-analysis-i-advanced-optional-KdbbU">coursera上的算法课程</a></p><p>这里证明并没有引入势能分析，但是相关东西异曲同工。</p><h2 id="引入">引入</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><h2 id="朴素算法">朴素算法</h2><p>查询：我们需要沿着树向上移动，直至找到根节点。</p><p>合并：要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。</p><p>那么这样的时间复杂度有多少呢？</p><h3 id="排名rank">排名（Rank）</h3><p>对于并查集的中的每个树，其中 <span class="math inline">\(V\)</span>是节点集合，<span class="math inline">\(E\)</span> 是边集合，<spanclass="math inline">\(r\)</span> 为树的叶节点，对于任意节点 <spanclass="math inline">\(v \in V\)</span>，定义节点 <spanclass="math inline">\(v\)</span> 的排名 <spanclass="math inline">\(\text{rank}\)</span> 为：</p><ul><li>如果 <span class="math inline">\(v\)</span> 没有叶节点 ，则 <spanclass="math inline">\(\text{rank}(v) = 0\)</span></li><li>如果 <span class="math inline">\(v\)</span> 有叶节点 ，则 <spanclass="math inline">\(\text{rank}(v) = \max\{\text{rank}(\text{son})\} +1\)</span></li></ul><p>某个节点到<strong>根结点</strong>的路径上的边数的<strong>最大值</strong>为排名（Rank）</p><p>注意：下面所有秩都和 <span class="math inline">\(\text{rank}\)</span>一个意思</p><p>那么就有以下性质：</p><ol type="1"><li>对于任意节点 <span class="math inline">\(x\)</span>，<spanclass="math inline">\(\text{rank}(x)\)</span> 只会增加</li><li>在合并时，只有根节点的 <spanclass="math inline">\(\text{rank}(x)\)</span> 才有可能增加</li><li>在一条路径（从下至上）中 <spanclass="math inline">\(\text{rank}(x)\)</span> 严格递增</li></ol><h4 id="rank-的引理-1">rank 的引理 1</h4><p>对于任意的查询Find操作，该操作中生成的图 <spanclass="math inline">\(G\)</span>，<span class="math inline">\(|G| =n\)</span>，对于所有的 <span class="math inline">\(r \in \{1,2,3 \dotsn\}\)</span>，<span class="math inline">\(\text{rank} = r\)</span>的元素个数 <span class="math inline">\(\leq \frac{n}{2^r}\)</span></p><h5 id="证明引理-1">证明引理 1</h5><ol type="1"><li>假设一：如果两个的不相同的点的 <spanclass="math inline">\(\text{rank}\)</span>相同，那么他们的子树不可能有重合部分。<ul><li>反证：如果有重合部分，那么一定有一个路径 <spanclass="math inline">\(x\to z \to y\)</span>，<spanclass="math inline">\(z\)</span> 为重合部分，<spanclass="math inline">\(x,y\)</span> 为两个 rank 相同的点，那么可以得出<span class="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> 之间有更大的祖先，那么就有更大的 <spanclass="math inline">\(\text{rank}\)</span>，与假设不符。</li></ul></li><li>假设二：<span class="math inline">\(\text{rank}=x\)</span>的子树的元素 <span class="math inline">\(\ge2^n\)</span>（数学归纳法）</li></ol><p>证明：<strong>Base</strong>：<span class="math inline">\(\text{rank}= 0,size =0\)</span></p><p><strong>inductive step</strong>：</p><ol type="1"><li><p>不一样的子树大小，<spanclass="math inline">\(\text{rank}\)</span> 不变</p></li><li><p>一样的子树大小， <span class="math inline">\(\text{rank} +1\)</span></p></li></ol><p><span class="math inline">\(X_s = 合并前一个子树的大小 \geq 2^r,Y_s =合并前另一个子树的大小 \geq 2^r\)</span></p><p>合并后，Union(x,y)得到了新祖先 <spanclass="math inline">\(Z\)</span>，<spanclass="math inline">\(\text{rank}(z) = r+1\)</span></p><p><span class="math inline">\(Z_s \geq 2^r + 2^r \geq2^{r+1}\)</span>，假设二证明完毕</p><p>现在我们来证明引理 1：n 个元素，我们设<strong>每个</strong> <spanclass="math inline">\(\text{rank}=x\)</span> 的子树的大小为 <spanclass="math inline">\(x\)</span>，假设二可知，<spanclass="math inline">\(x \geq 2^r\)</span></p><p>我们两边取倒数，并且同时乘一个 n，那么可以得出 <spanclass="math inline">\(\dfrac{n}{x} \leq\dfrac{n}{2^r}\)</span>，那么可以看出左边就是 <spanclass="math inline">\(\text{rank} = r\)</span> 的元素个数，引理 1也证明完毕了。</p><h3 id="时间复杂度">时间复杂度</h3><p>证明了这么多，我们也能看出来 <spanclass="math inline">\(\text{rank}\)</span>其实就是一个子树的深度，也是我们最多要查询的次数。</p><p>首先，<spanclass="math inline">\(最大\text{rank}的个数=祖先的个数=1\)</span>，显然，那么根据引理1，得出：<span class="math display">\[1 \leq \frac{n}{2^r} \ \Rightarrow 2^r \leq n \Rightarrow r \leq\log_{2}n\]</span> 那么我们可以得到查询和合并的时间复杂度为 <spanclass="math inline">\(O(\log_{2} n)\)</span></p><h2 id="路径压缩启发式合并按秩合并">路径压缩+启发式合并（按秩合并）</h2><p>上面的朴素算法已经很快了，但是考虑一种可能，如果这个不是一个正常的树，而是一条链，而我们正常的去查询最底下的节点，那么复杂度将会退化成<spanclass="math inline">\(O(n)\)</span>，这并不是我们想要的，想到我们查询时有许多地方时冗余的，我们就想到了路径压缩。</p><p><strong>路径压缩</strong>：查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。</p><p>在合并时我们又想到了这两个的 <spanclass="math inline">\(\text{rank}\)</span>不同也会导致路径压缩的时候会多了一些不该有的操作。</p><p><strong>启发式合并（按秩合并）</strong>：合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p><p>另一种做法则是使用“秩”来比较树的大小。”秩“的定义如下：</p><ul><li>只有根节点的树（即只有一个元素的集合），秩为0；</li><li>当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者；</li><li>当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。</li></ul><p>容易发现，在没有路径压缩优化时，树的秩等于树的深度减一。在有路径压缩优化时，树的秩仍然能反映出树的深度和大小。在合并时根据两棵树的秩的大小，决定新的根节点，这被称作<strong>按秩合并</strong>。</p><h3 id="theorem">Theorem</h3><p><strong>注意：经过路径压缩过时，<spanclass="math inline">\(\text{rank}\)</span>不变，相当于被冻结了，不管压缩到哪都不会改变</strong></p><p><strong>内容：</strong>通过“按秩合并”和“路径压缩”优化后，进行 <spanclass="math inline">\(m\)</span> 次合并+查询的操作的时间复杂度为 <spanclass="math inline">\(O(m \log^* n)\)</span>，其中 <spanclass="math inline">\(\log^* n\)</span> 表示对 <spanclass="math inline">\(n\)</span> 反复应用对数运算，直到结果小于等于 1所需要的次数，一般叫迭代对数。</p><table><thead><tr><th><span class="math inline">\(x\)</span></th><th><span class="math inline">\(\lg^* x\)</span></th></tr></thead><tbody><tr><td><span class="math inline">\((−\infty, 1]\)</span></td><td><span class="math inline">\(0\)</span></td></tr><tr><td><span class="math inline">\((1, 2]\)</span></td><td><span class="math inline">\(1\)</span></td></tr><tr><td><span class="math inline">\((2, 4]\)</span></td><td><span class="math inline">\(2\)</span></td></tr><tr><td><span class="math inline">\((4, 16]\)</span></td><td><span class="math inline">\(3\)</span></td></tr><tr><td><span class="math inline">\((16, 65536]\)</span></td><td><span class="math inline">\(4\)</span></td></tr><tr><td><span class="math inline">\((65536, 2^{65536}]\)</span></td><td><span class="math inline">\(5\)</span></td></tr></tbody></table><h4 id="证明">证明</h4><p>首先我们来定义一个 <span class="math inline">\(\text{rank\,blocks}\)</span>（秩块）；<spanclass="math inline">\(\{0\},\{1\},\{2,3,4\},\{5,\dots, 2 4\},\{17,18,\dots,2^{16}\},\{65537,\dots,2^{65536}\},\dots,\{\dots,n\}\)</span></p><p>很显然这些块只会有 <span class="math inline">\(O(\log^* n)\)</span>个。</p><p>我们给每个节点分类，我们现在称一个节点 <spanclass="math inline">\(x\)</span>（可变）是好的当：</p><ol type="1"><li><span class="math inline">\(x\)</span> 或者 <spanclass="math inline">\(x\)</span> 的父节点为根节点</li><li>父亲的 <span class="math inline">\(\text{rank}\)</span> 比自己的<span class="math inline">\(\text{rank}\)</span> 大。<strong>注意：<span class="math inline">\(\text{rank}不变\)</span></strong></li></ol><p>如果两个条件都不符合，那么就是坏节点。</p><p><strong>我们会尽量将一个节点变成好节点。</strong></p><p>第一个要点：要点：每次查找操作只会访问 <spanclass="math inline">\(O(\log^* n)\)</span> 个好节点 （计算方式为 <spanclass="math inline">\(2 + 秩块的数量 = O(\log^* n)\)</span>）</p><p>结论：在 <span class="math inline">\(m\)</span>次操作中完成的总工作量可以表示为两种：</p><ul><li><span class="math inline">\(O(m \log^*n)\)</span>（访问好节点的次数）</li><li>访问坏节点的总次数，下面就来论证。</li></ul><p>首先我们思考，在路径压缩中，其父节点被更改为具有严格更大 <spanclass="math inline">\(\text{rank}\)</span> 的节点，这种情况最多只会发生<span class="math inline">\(2^k\)</span> 次，之后 <spanclass="math inline">\(x\)</span>将永久成为“好节点”。（很显然，在路径压缩中，那个节点相当于在往上跳，最多跳到这个block 的第一个）</p><p>总时间复杂度：<span class="math inline">\(O(m \log^* n) +O(访问坏节点的次数)\)</span>。</p><p>我们对一个秩块 <span class="math inline">\(\{k+1, k+2, \dots,2^k\}\)</span> 分析：</p><p>对于每个最终秩处于此块的 <span class="math inline">\(x\)</span>，当<span class="math inline">\(x\)</span> 是“坏节点”时的访问次数最多为<span class="math inline">\(2^k\)</span>。</p><p>具有最终 <span class="math inline">\(\text{rank}\)</span>处于此块的对象总数为： <span class="math display">\[\sum_{i=k+1}^{2^k} \frac{n}{2^i} \leq \frac{n}{2^k}\]</span> 因此，此秩块中对“坏节点”的访问总次数最多为 <spanclass="math inline">\(n\)</span>。</p><p>因为只有 <span class="math inline">\(O(\log^* n)\)</span>个秩块。</p><p><strong>总时间复杂度</strong>：</p><p><span class="math inline">\(O((m + n) \log^*n)\)</span>，在正常操作中 <span class="math inline">\(m\)</span> 与<span class="math inline">\(n\)</span> 同阶，就可以是 <spanclass="math inline">\(O(m \log^* n)\)</span>，证明完毕。</p><h3 id="tarjans-bound">Tarjan’s Bound</h3><p>该证明在1975年由Tarjan完成，后在1989年，由Fredman证明该结构下无法找到更好的时间复杂度</p><p><strong>内容</strong>：通过“按秩合并”和“路径压缩”优化后，进行 <spanclass="math inline">\(m\)</span> 次合并和查找操作的时间复杂度为 <spanclass="math inline">\(O(m \alpha(n))\)</span>，其中 <spanclass="math inline">\(\alpha(n)\)</span> 是反阿克曼函数。</p><h4 id="阿克曼函数">阿克曼函数</h4><p>需要两个自然数作为输入值，输出一个自然数，它的输出值增长速度非常高。</p><p>定义： <span class="math display">\[A(m,n) = \begin{cases}n + 1 &amp; \text{如果 m=0} \\ A(m-1,1) &amp;\text{如果 m&gt;0 且 n=0} \\ A(m-1,A(m,n-1)) &amp; \text{如果 m&gt;0 且n&gt;0 }\end{cases}\]</span>由于这个函数的增加速率非常快，那么它的反函数就相应的增长的非常慢。</p><p><strong>反函数的定义</strong>：对于每个 <span class="math inline">\(n\geq 4\)</span>，<span class="math inline">\(\alpha(n)\)</span> 是满足<span class="math inline">\(A_k(2) \geq n\)</span> 的最小 <spanclass="math inline">\(k\)</span> 值，其中 <spanclass="math inline">\(A_k(2)\)</span> 是阿克曼函数。</p><blockquote><p><span class="math inline">\(\alpha(n) = 1 \Rightarrown=4\)</span></p><p><span class="math inline">\(\alpha(n) = 2 \Rightarrow n=5 \dots8\)</span></p><p><span class="math inline">\(\alpha(n) = 3 \Rightarrow n=9 ,10\dots2048\)</span></p><p><span class="math inline">\(\alpha(n) = 4 \Rightarrow n=4\dots n(n满足 \log^*n= 2048)\)</span></p><p><span class="math inline">\(\cdots\)</span></p></blockquote><h4 id="证明-1">证明</h4><p>我们定义 <span class="math inline">\(x\)</span> 为不是根节点 <spanclass="math inline">\(\delta(x)\)</span> 是最大的 <spanclass="math inline">\(k\)</span> 使得 <spanclass="math inline">\(\text{rank}(\text{parent}[x]) \geqA_k(\text{rank}(x))\)</span></p><p>显然， <span class="math inline">\(\delta(x)\)</span> 是递增的。</p><p>这里有一个性质：只要 <span class="math inline">\(\text{rank} \geq2\)</span> 的点，那么一定会有 <span class="math inline">\(\delta(x) \leq\alpha(n)\)</span></p><p>证明： <span class="math display">\[A_{\alpha(n)}(2) \geq n \geq \text{rank}(parent[x]) \geqA_k(\text{rank}(x))\]</span> 其中 <span class="math inline">\(n \geq\text{rank}(parent[x])\)</span>很显然一定成立，左边其实就是上面反函数的定义，右边就是 <spanclass="math inline">\(\delta(x)\)</span>的定义，最左边与最右边分别进行反函数，即证成立。</p><p>这里我们继续定义好节点与坏节点：</p><p>一个点为好的节点当且仅当符合下面几个条件，我们称这个节点为坏节点：</p><ol type="1"><li><span class="math inline">\(x\)</span> 不是根节点</li><li>它的父亲不是根节点</li><li><span class="math inline">\(\text{rank}(x) \geq 2\)</span></li><li><span class="math inline">\(x\)</span> 存在祖先 <spanclass="math inline">\(y\)</span> 使得 <spanclass="math inline">\(\delta(y) = \delta(x)\)</span></li></ol><p>否则，<span class="math inline">\(x\)</span> 是好的节点。</p><p>同 Hopcroft-Ullman 类似，在一次路径中最多有 <spanclass="math inline">\(\Theta(\alpha(n)) \leq 2 +2 +\alpha(n)\)</span>个好节点。</p><p>那么最终 <span class="math inline">\(m\)</span>次操作（合并与查询）的总时间复杂度：<spanclass="math inline">\(O(m\alpha(n))(访问好节点的次数)+访问坏节点的次数\)</span></p><p>下面我们来计算一下这个坏节点的个数，我们同样只先看一次路径的：</p><figure><img src="https://s2.loli.net/2025/01/23/rWEjnAXFbfmUO8w.png"alt="A path" /><figcaption aria-hidden="true">A path</figcaption></figure><p>路径压缩：<span class="math inline">\(p&#39;\)</span> 是 <spanclass="math inline">\(x\)</span> 的新父亲或者更向上，则有： <spanclass="math display">\[\text{rank}(x的新父亲) \geq \text{rank}(p&#39;) \geq A_k(\text{rank}(y))\geq A_k(\text{rank}(p))\]</span> 中间这个过渡我们用到了上面 <spanclass="math inline">\(\delta(x)\)</span> 的定义，其他的都很显然。</p><p>假设 <span class="math inline">\(r =\text{rank}(x)\)</span>，然后我们对 <spanclass="math inline">\(x\)</span> 做 <spanclass="math inline">\(r\)</span>次查找（<strong>路径压缩</strong>），假设每次都是有用的，那么我的 <spanclass="math inline">\(\delta(x)\)</span> <strong>至少</strong> <spanclass="math inline">\(+1\)</span></p><p>为什么？我们不从理性的（数学的）角度去分析，而是去从感性的角度，首先想<span class="math inline">\(\text{rank}(x) =0，1\)</span>，显然根据定义，本身就是好节点，成立。</p><p>那么 <span class="math inline">\(\text{rank}(x) \geq 2\)</span>呢？压缩一次会压缩到好节点的同地方，下一次必然会压缩到下一个 <spanclass="math inline">\(\delta(x) + 1\)</span>中，所以的证，而且是<strong>至少</strong>。</p><p>那最多可以加多少次 1 呢？<spanclass="math inline">\(\alpha(n)\)</span> 次</p><p>那么 <span class="math inline">\(x\)</span> 是坏的 <spanclass="math inline">\(\leq r \alpha(n)\)</span></p><p>那么我们开始算总共访问坏节点的次数： <span class="math display">\[\begin{align*}&amp;总共访问坏节点的次数  \\&amp;\leq \Sigma_{所有节点}\text{rank}(x) \cdot \alpha(n) \tag 1\\&amp;= \alpha(n) \cdot \Sigma_{r \geq 0} \,r \,(\text{rank}=r节点的个数) \tag2\\&amp;\leq n \alpha(n) \Sigma_{r \geq 0} \frac{r}{2^r} \tag 3\\&amp;= O(n \alpha(n))\end{align*}\]</span> 我们来解释一下这个东西怎么来的，在 <spanclass="math inline">\((2) \to (3)\)</span> 中的推导中我们用到了 rank的引理 1，不理解的可以倒回去看看，这里我们对每个 <spanclass="math inline">\(r\)</span> 都用了一个引理 1 并相加，<spanclass="math inline">\((3)\)</span> 中的 <spanclass="math inline">\(\Sigma_{r \geq 0}\frac{r}{2^r}\)</span>，其实是个几何级数，最后是个常数，可以省略，就得到了坏节点的次数。</p><p>那么我们能得出总共的时间复杂度为：</p><p><span class="math inline">\(O((n+m)\alpha(n))\)</span>，同样在正常操作中 <spanclass="math inline">\(m\)</span> 与 <spanclass="math inline">\(n\)</span> 同阶，就可以是 <spanclass="math inline">\(O(m \alpha(n))\)</span>，证明完毕。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>时间复杂度分析</tag>
      
      <tag>数学归纳法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图与网络分析基础</title>
    <link href="/2025/01/18/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/18/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没想到没几天又开始学到算法部分了，这一次定义将会学习的更加严谨。按照书上的拓展学习。</p><h1 id="图的相关概念">图的相关概念</h1><p><strong>图 (graph)</strong> 是一个二元组 <spanclass="math inline">\(G=(V(G), E(G))\)</span>。其中 <spanclass="math inline">\(V(G)\)</span> 是非空集，称为<strong>点集</strong>，对于 <span class="math inline">\(V\)</span>中的每个元素，我们称其为 <strong>顶点</strong> 或<strong>节点</strong>，简称 <strong>点</strong>；<spanclass="math inline">\(E(G)\)</span> 为 <spanclass="math inline">\(V(G)\)</span> 各结点之间边的集合，称为<strong>边集</strong>。</p><p>常用 <span class="math inline">\(G=(V,E)\)</span> 表示图。</p><p>当 <span class="math inline">\(V,E\)</span> 都是有限集合时，称 <spanclass="math inline">\(G\)</span> 为 <strong>有限图</strong>。</p><p>当 <span class="math inline">\(V\)</span> 或 <spanclass="math inline">\(E\)</span> 是无限集合时，称 <spanclass="math inline">\(G\)</span> 为 <strong>无限图</strong>。</p><p>图有多种，包括<strong>无向图</strong>，<strong>有向图</strong>，<strong>混合图</strong>等。</p><p>若 <span class="math inline">\(G\)</span> 为无向图，则 <spanclass="math inline">\(E\)</span> 中的每个元素为一个无序二元组 <spanclass="math inline">\((u, v)\)</span>，称作<strong>无向边</strong>，简称 <strong>边</strong>，其中 <spanclass="math inline">\(u, v \in V\)</span>。设 <spanclass="math inline">\(e = (u, v)\)</span>，则 <spanclass="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span> 称为 <spanclass="math inline">\(e\)</span> 的 <strong>端点</strong>。</p><p>若 <span class="math inline">\(G\)</span> 的每条边 <spanclass="math inline">\(e_k=(u_k,v_k)\)</span> 都被赋予一个数作为该边的<strong>权</strong>，则称 <span class="math inline">\(G\)</span> 为<strong>赋权图</strong>。如果这些权都是正实数，就称 <spanclass="math inline">\(G\)</span> 为 <strong>正权图</strong>。与一个顶点<span class="math inline">\(v\)</span> 关联的边的条数称作该顶点的<strong>度</strong>，记作 <spanclass="math inline">\(d(v)\)</span>。特别地，对于边 <spanclass="math inline">\((v, v)\)</span>，则每条这样的边要对 <spanclass="math inline">\(d(v)\)</span> 产生 <spanclass="math inline">\(2\)</span> 的贡献。</p><p>对于一张无向图 <span class="math inline">\(𝐺=(𝑉,𝐸)\)</span>，对于<span class="math inline">\(𝑢,𝑣∈𝑉\)</span>，若存在一条途径使得 <spanclass="math inline">\(𝑣=𝑢,𝑣𝑘=𝑣\)</span>，则称 𝑢 和 𝑣 是<strong>连通的</strong>。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。</p><p>若无向图 <spanclass="math inline">\(𝐺=(𝑉,𝐸)\)</span>，满足其中任意两个顶点均连通，则称<span class="math inline">\(𝐺\)</span> 是 <strong>连通图</strong>，<spanclass="math inline">\(𝐺\)</span> 的这一性质称作<strong>连通性</strong>。</p><p>最基本的就这些了。</p><h2 id="树">树</h2><p>一个无圈的连通图称为<strong>树</strong>。</p><p>给了一个无向图<span class="math inline">\(G=(V,E)\)</span>，保留<span class="math inline">\(G\)</span> 的所有点，而删掉部分 <spanclass="math inline">\(G\)</span>，的边或者说保留一部分 <spanclass="math inline">\(G\)</span> 的边，所获得的图称为<spanclass="math inline">\(G\)</span>的<strong>生成子图</strong>。如果 <spanclass="math inline">\(G\)</span>的生成子图是一个树，则称这个生产子图为一个生成树。</p><h3 id="最小生成树">最小生成树</h3><p>在一个赋权图的联通的无向图 <span class="math inline">\(G\)</span>中找一个生成树，并使得这个生成树的所有边的权数之和最小。</p><h4 id="kruskal-算法求最小生成树">Kruskal 算法求最小生成树</h4><p>基本思想是从小到大加入边，是个贪心算法。</p><ol type="1"><li>新建图 <span class="math inline">\(G\)</span>，<spanclass="math inline">\(G\)</span>中拥有原图中相同的节点，但没有任何边。</li><li>将原图中所有的边按权值从小到大排序。</li><li>从权值最小的边开始，如果这条边连接的两个节点于图 <spanclass="math inline">\(G\)</span>中不在同一个连通分量（不是联通的）中，则添加这条边到图 <spanclass="math inline">\(G\)</span> 中。</li><li>重复3，直到 <span class="math inline">\(G\)</span>中所有的节点都在同一个联通分量中。</li></ol><p>伪代码：</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">KRUSKAL-<span class="hljs-function"><span class="hljs-keyword">FUNCTION</span><span class="hljs-params">(G, w)</span></span><br><span class="hljs-function">    <span class="hljs-title">F</span> :</span>= 空集合<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> 图 G 中的顶点 v<br>        <span class="hljs-keyword">do</span> 将 v 加入森林 F<br>    所有的边(u, v) ∈ E依权重 w 递增排序<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> 边(u, v) ∈ E<br>        <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> u 和 v 不在同一棵子树<br>            <span class="hljs-keyword">then</span> F := F ∪ <span class="hljs-comment">&#123;(u, v)&#125;</span><br>                将 u 和 v 所在的子树合并<br></code></pre></div></td></tr></table></figure><p>通过使用路径压缩的并查集，平均时间复杂度为<spanclass="math inline">\(O(\left| E \right| \log \left| V\right|)\)</span>，其中 <span class="math inline">\(E,V\)</span>分别是图的边集和点集。</p><p>还有如果同时使用路径压缩和按秩合并的并查集，时间复杂度可以优化到<spanclass="math inline">\(O(\left| E \right| \alpha( \left| V\right|))\)</span>，其中 <span class="math inline">\(\alpha\)</span>表示反阿克曼函数。</p><p>#### 反阿克曼函数</p><p>定义： <span class="math display">\[A(m,n) = \begin{cases}n + 1 &amp; \text{如果 m=0} \\ A(m-1,1) &amp;\text{如果 m&gt;0 且 n=0} \\ A(m-1,A(m,n-1)) &amp; \text{如果 m&gt;0 且n&gt;0 }\end{cases}\]</span>由于这个函数的增加速率非常快，那么它的反函数就相应的增长的非常慢。</p><h4 id="证明">证明</h4><p>思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了<span class="math inline">\(n-1\)</span> 条边，即形成了一棵树。</p><p>证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST所包含。</p><p>基础：对于算法刚开始时，显然成立（最小生成树存在）。</p><p>归纳：假设某时刻成立，当前边集为 <spanclass="math inline">\(F\)</span>，令 <spanclass="math inline">\(T\)</span> 为这棵 MST，考虑下一条加入的边 <spanclass="math inline">\(e\)</span>。</p><p>如果 <span class="math inline">\(e\)</span> 属于 <spanclass="math inline">\(T\)</span>，那么成立。</p><p>否则，<span class="math inline">\(T+e\)</span>一定存在一个环，考虑这个环上不属于 <spanclass="math inline">\(F\)</span> 的另一条边 <spanclass="math inline">\(f\)</span>（一定只有一条）。</p><p>首先，<span class="math inline">\(f\)</span> 的权值一定不会比 <spanclass="math inline">\(e\)</span> 小，不然 <spanclass="math inline">\(f\)</span> 会在 <spanclass="math inline">\(e\)</span> 之前被选取</p><p>然后，<span class="math inline">\(f\)</span> 的权值一定不会比 <spanclass="math inline">\(e\)</span> 大，不然 <spanclass="math inline">\(T+e-f\)</span> 就是一棵比 <spanclass="math inline">\(T\)</span> 还优的生成树了。</p><p>所以，<span class="math inline">\(T+e-f\)</span> 包含了 <spanclass="math inline">\(F\)</span>，并且也是一棵最小生成树，归纳成立。</p><h2 id="最短路问题">最短路问题</h2><p>最短路问题是指对一个赋权的有向图 <spanclass="math inline">\(D\)</span> 中指定的两点 <spanclass="math inline">\(v_s\)</span> 和 <spanclass="math inline">\(v_t\)</span>，找到一条从 <spanclass="math inline">\(v_s\)</span> 到 <spanclass="math inline">\(v_t\)</span>的路，使得这条路上所有弧的总和最小，这条路被称为从 <spanclass="math inline">\(v_s\)</span> 到 <spanclass="math inline">\(v_t\)</span>的最短路。这条路上所有弧的权数的总和被称为从 <spanclass="math inline">\(v_s\)</span> 到 <spanclass="math inline">\(v_t\)</span> 的距离。</p><p>我们一般讨论单源的最短路，全源最短路径得用 Floyd 算法以及 Johnson全源最短路径算法，这里不再讨论。</p><h3 id="dijkstra-算法">Dijkstra 算法</h3><p>Dijkstra 算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959年公开发表。是一种求解 <strong>非负权图</strong>上单源最短路径的算法。</p><h4 id="松弛">松弛</h4><p>对于边 <spanclass="math inline">\((u,v)\)</span>，松弛操作对应下面的式子：<spanclass="math inline">\(dis(v) = \min(dis(v), dis(u) + w(u,v))\)</span>。</p><p><span class="math inline">\(dis(v)\)</span> 表示的含义是起点开始，到<span class="math inline">\(v\)</span> 的最短路径，<spanclass="math inline">\(w(u,v)\)</span> 表示边 <spanclass="math inline">\((u,v)\)</span> 的权值 <spanclass="math inline">\(w\)</span>。</p><p>这么做的含义是显然的：我们尝试用 <span class="math inline">\(S \to u\to v\)</span>（其中 <span class="math inline">\(S \to u\)</span>的路径取最短路）这条路径去更新 <span class="math inline">\(v\)</span>点最短路的长度，如果这条路径更优，就进行更新。</p><h4 id="过程">过程</h4><p>将结点分成两个集合：已确定最短路长度的点集（记为 <spanclass="math inline">\(S\)</span> 集合）的和未确定最短路长度的点集（记为<span class="math inline">\(T\)</span> 集合）。一开始所有的点都属于<span class="math inline">\(T\)</span> 集合。</p><p>初始化 <span class="math inline">\(dis(s)=0\)</span>，其他点的 <spanclass="math inline">\(dis\)</span> 均为 <spanclass="math inline">\(+\infty\)</span>。</p><p>然后重复这些操作：</p><ol type="1"><li>从 <span class="math inline">\(T\)</span>集合中，选取一个最短路长度最小的结点，移到 <spanclass="math inline">\(S\)</span> 集合中。</li><li>对那些刚刚被加入 <span class="math inline">\(S\)</span>集合的结点的所有出边执行<strong>松弛</strong>操作。</li></ol><p>直到 <span class="math inline">\(T\)</span> 集合为空，算法结束。</p><h4 id="正确性证明">正确性证明</h4><p><span class="math inline">\(D(u)\)</span> 为 <spanclass="math inline">\(s\)</span> 点到 <spanclass="math inline">\(u\)</span> 点的 <strong>实际</strong>最短路长度。</p><p>下面用数学归纳法证明，在 <strong>所有边权值非负</strong>的前提下，Dijkstra 算法的正确性。</p><p>简单来说，我们要证明的，就是在执行 1 操作时，取出的结点 <spanclass="math inline">\(u\)</span> 最短路均已经被确定，即满足 <spanclass="math inline">\(D(u) = dis(u)\)</span>。</p><p>初始时 <span class="math inline">\(S =\varnothing\)</span>，假设成立。</p><p>接下来用反证法。</p><p>设 <span class="math inline">\(u\)</span> 点为算法中第一个在加入<span class="math inline">\(S\)</span> 集合时不满足 <spanclass="math inline">\(D(u) = dis(u)\)</span> 的点。因为 <spanclass="math inline">\(u\)</span> 点一定满足 <spanclass="math inline">\(D(u)=dis(u)=0\)</span>，且它一定是第一个加入 <spanclass="math inline">\(S\)</span> 集合的点，因此将 <spanclass="math inline">\(u\)</span> 加入 <spanclass="math inline">\(S\)</span> 集合前，<span class="math inline">\(S\neq \varnothing\)</span>，如果不存在 <spanclass="math inline">\(s\)</span> 到 <spanclass="math inline">\(u\)</span> 的路径，则 <spanclass="math inline">\(D(u) = dis(u) = +\infty\)</span>，与假设矛盾。</p><p>于是一定存在路径 <span class="math inline">\(s \to x \to y \tou\)</span>，其中 <span class="math inline">\(y\)</span> 为 <spanclass="math inline">\(s \to u\)</span> 路径上第一个属于 <spanclass="math inline">\(T\)</span> 集合的点，而 <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(y\)</span> 的前驱结点（显然 <spanclass="math inline">\(x \in S\)</span>）。需要注意的是，可能存在 <spanclass="math inline">\(s = x\)</span> 或 <span class="math inline">\(y =u\)</span> 的情况，即 <span class="math inline">\(s \to x\)</span> 或<span class="math inline">\(y \to u\)</span> 可能是空路径。</p><p>因为在 <span class="math inline">\(u\)</span>结点之前加入的结点都满足 <span class="math inline">\(D(u) =dis(u)\)</span>，所以在 <span class="math inline">\(x\)</span> 点加入到<span class="math inline">\(S\)</span> 集合时，有 <spanclass="math inline">\(D(x) = dis(x)\)</span>，此时边 <spanclass="math inline">\((x,y)\)</span> 会被松弛，从而可以证明，将 <spanclass="math inline">\(u\)</span> 加入到 <spanclass="math inline">\(S\)</span> 时，一定有 <spanclass="math inline">\(D(y)=dis(y)\)</span>。</p><p>下面证明 <span class="math inline">\(D(u) = dis(u)\)</span>成立。在路径 <span class="math inline">\(s \to x \to y \to u\)</span>中，因为图上所有边边权非负，因此 <span class="math inline">\(D(y) \leqD(u)\)</span>。从而 <span class="math inline">\(dis(y) = D(y) \leqD(u)\leq dis(u)\)</span>。但是因为 <spanclass="math inline">\(u\)</span> 结点在 1 过程中被取出 <spanclass="math inline">\(T\)</span> 集合时，<spanclass="math inline">\(y\)</span> 结点还没有被取出 <spanclass="math inline">\(T\)</span> 集合，因此此时有 <spanclass="math inline">\(dis(u)\leq dis(y)\)</span>，从而得到 <spanclass="math inline">\(dis(y) = D(y) = D(u) = dis(u)\)</span>，这与 <spanclass="math inline">\(D(u)\neq dis(u)\)</span>的假设矛盾，故假设不成立。</p><p>因此我们证明了，1操作每次取出的点，其最短路均已经被确定。命题得证。</p><p>注意到证明过程中的关键不等式 <span class="math inline">\(D(y) \leqD(u)\)</span>是在图上所有边边权非负的情况下得出的。当图上存在负权边时，这一不等式不再成立，Dijkstra算法的正确性将无法得到保证，算法可能会给出错误的结果。</p><h4 id="时间复杂度">时间复杂度</h4><p><span class="math inline">\(|E|\)</span> 表示边数，<spanclass="math inline">\(|V|\)</span> 顶点数</p><p>朴素方法：<span class="math inline">\(O(|E|^2)\)</span></p><p>使用二叉堆优化方法：<span class="math inline">\(O((|E| + |V|) \log|V|)\)</span></p><h2 id="网络流问题">网络流问题</h2><h3 id="前置知识">前置知识</h3><p>网络是指一个特殊的有向图 <spanclass="math inline">\(G=(V,E)\)</span>，其与一般有向图的不同之处在于有容量和源汇点。</p><ul><li><span class="math inline">\(E\)</span> 中的每条边 <spanclass="math inline">\((u, v)\)</span> 都有一个被称为容量的权值，记作<span class="math inline">\(c(u, v)\)</span>。当 <spanclass="math inline">\((u,v)\notin E\)</span> 时，可以假定 <spanclass="math inline">\(c(u,v)=0\)</span>。</li><li><span class="math inline">\(V\)</span> 中有两个特殊的点：源点 <spanclass="math inline">\(s\)</span> 和汇点 <spanclass="math inline">\(t\)</span>（<span class="math inline">\(s \neqt\)</span>）。</li></ul><p>对于网络 <span class="math inline">\(G=(V,E)\)</span>，流是一个从边集 <span class="math inline">\(E\)</span>到整数集或实数集的函数，其满足以下性质。</p><ol type="1"><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 <spanclass="math inline">\(0 \leq f(u,v) \leq c(u,v)\)</span>；</li><li>流守恒性（平衡条件）：除源汇点外，任意结点 <spanclass="math inline">\(u\)</span> 的净流量为 <spanclass="math inline">\(0\)</span>（输入量等于输出量）。其中，我们定义<span class="math inline">\(u\)</span> 的净流量为 <spanclass="math inline">\(f(u) = \sum_{x \in V} f(u, x) - \sum_{x \in V}f(x, u)\)</span>。</li></ol><p>定义网络 <span class="math inline">\(D\)</span>，若 <spanclass="math inline">\(\mu\)</span> 为网络中的一条链，给 <spanclass="math inline">\(\mu\)</span> 定向为从 <spanclass="math inline">\(u_s\)</span> 到 <spanclass="math inline">\(u_t\)</span>，<spanclass="math inline">\(\mu\)</span> 上的弧凡与 <spanclass="math inline">\(\mu\)</span>同向称为前向弧，反向为后向弧，其集合分别用 <spanclass="math inline">\(\mu^+\)</span> 和 <span class="math inline">\(\mu^-\)</span> 表示。设 <span class="math inline">\(f={f_{ij}}\)</span>是一个可行流，如果满足 <span class="math display">\[\begin{cases} 0 \leq f_{ij} \leq c_{ij} &amp; (v_i,v_j) \in \mu^+ \\c_{ij} \geq f_{ij} &gt; 0 &amp; (v_i,v_j) \in \mu^- \end{cases}\]</span> 则称 <span class="math inline">\(\mu\)</span> 为从 <spanclass="math inline">\(v_s\)</span> 到 <spanclass="math inline">\(v_t\)</span> 的一条增广链。</p><p>对于给定网络 <span class="math inline">\(G=(V,E,C)\)</span> ，设<span class="math inline">\(S,T \subset V\)</span> ，且 <spanclass="math inline">\(S\cup T=V,S \cap T = \varnothing,v_s\in S,v_t\inT\)</span> ，则称 <span class="math inline">\((S,T)\)</span> 为割集</p><p>残量网络：根据原网络，定义的一个可描述每条边当前可调配流量的网络图，其中<strong>可调配残量</strong><span class="math inline">\(r(u,v)=c(u,v)−f(u,v)\)</span>，表明每条弧还能再有多 少流量经过。</p><h3 id="网络最大流问题标号法">网络最大流问题（标号法）</h3><p>最大流问题：对于网络 <span class="math inline">\(G = (V,E)\)</span>，给<strong>每条边指定流量</strong>，得到合适的流 <spanclass="math inline">\(f\)</span>，使得 <spanclass="math inline">\(f\)</span> 的流量尽可能大。此时我们称 <spanclass="math inline">\(f\)</span> 是 <spanclass="math inline">\(G\)</span> 的最大流。</p><p>这里我们只讨论运筹书上写的标号法求最大流，不讨论更深入的。</p><h4 id="标号过程">标号过程</h4><ol type="1"><li><p>源点 <span class="math inline">\(v_s\)</span> 标号<spanclass="math inline">\((0,+\infty)\)</span></p></li><li><p>不断选择一个已标号的顶点 <span class="math inline">\(v_i\)</span>，对所有与 <span class="math inline">\(v_i\)</span> 相邻而没有标号的顶点<span class="math inline">\(v_j\)</span> 按如下规则处理：</p><ul><li><p>若 <span class="math inline">\((v_i,v_j)\in E\)</span> ，并且<span class="math inline">\(f_{ij}&lt;c_{ij}\)</span> ，则给顶点 <spanclass="math inline">\(v_j\)</span> 标号 <spanclass="math inline">\((v_i,\delta_j),\delta_j=\min(\delta_i,c_{ij}−f_{ij})\)</span></p></li><li><p>若 <span class="math inline">\((v_j,v_i)\in E\)</span> ，并且<span class="math inline">\(f_{ij}&gt;0\)</span>，则给顶点 <spanclass="math inline">\(v_j\)</span> 标号 <spanclass="math inline">\((v_i,\delta_j),\delta_j=\min(\delta_i,f_{ji})\)</span></p></li></ul></li><li><p>当无法选择后，若终点 <span class="math inline">\(v_i\)</span>得到标号，说明存在增广链，转到调整阶段，否则说明不存在增广链，此时可行流<span class="math inline">\(f\)</span> 即为最大流</p></li></ol><h4 id="调整过程">调整过程</h4><ul><li>应用反向追踪法，从终点 <span class="math inline">\(v_t\)</span>及其其他顶点的第一个标号，找出增广链</li><li>调整结束后去掉所有标号，再次进行标号过程。</li></ul><h3 id="最小费用最大流问题">最小费用最大流问题</h3><p>最小费用最大流问题：在网络 <span class="math inline">\(G = (V,E)\)</span> 上，对每条边给定一个权值 <span class="math inline">\(w(u,v)\)</span>，称为费用（cost），含义是单位流量通过 <spanclass="math inline">\((u, v)\)</span> 所花费的代价。对于 <spanclass="math inline">\(G\)</span>所有可能的最大流，我们称其中总费用最小的一者为最小费用最大流。</p><h4 id="增流网络">增流网络</h4><p><strong>顶点</strong>：增流网络 <spanclass="math inline">\(D_f\)</span> 的顶点与原网络相同</p><p><strong>弧与权</strong>：</p><ul><li>在 D 中的弧 <span class="math inline">\((v_i,v_j)\)</span>若为<strong>零流弧</strong>，即 <span class="math inline">\(f_{ij} =0\)</span> ，则在 <span class="math inline">\(D_f\)</span>中构建一个同向的弧，<span class="math inline">\(c_{ij}^, = c_{ij} -f_{ij},b_{ij}^, = b_{ij}\)</span></li><li>在 D 中的弧 <span class="math inline">\((v_i,v_j)\)</span>若为<strong>饱和弧</strong>，即 <span class="math inline">\(f_{ij} =c_{ij}\)</span> ，则在 <span class="math inline">\(D_f\)</span>中构建一个反向的弧，<span class="math inline">\(c_{ij}^, = c_{ij},b_{ij}^, = -b_{ij}\)</span></li><li>在 D 中的弧 <span class="math inline">\((v_i,v_j)\)</span>若为<strong>非饱和弧</strong>，即 <span class="math inline">\(f_{ij}&lt; 0\)</span> ，则在 <span class="math inline">\(D_f\)</span>中构建一个同向的弧和反向的弧，同向的弧<spanclass="math inline">\(c_{ij}^, = c_{ij} - f_{ij},b_{ij}^, =b_{ij}\)</span>，反向的弧 <span class="math inline">\(c_{ij}^, = c_{ij},b_{ij}^, = -b_{ij}\)</span></li></ul><h4 id="增流圈">增流圈</h4><p>在增流网络 <span class="math inline">\(D_f\)</span>中的负回路对应网络 <span class="math inline">\(D\)</span>中的一个圈，在这个圈中，如果方向与负回路方向相同的所有弧都为不饱和弧，方向与负回路方向相反的所有弧都为非零流弧，则这个圈被称为增流圈。</p><h4 id="算法实际过程">算法实际过程</h4><ol type="1"><li>利用最大流算法，将网络的流量调整到最大流</li><li>构建伴随网络流f的增流网络 <spanclass="math inline">\(D_f\)</span></li><li>在增流网络 <span class="math inline">\(D_f\)</span>中，查找关于费用的负回路，令<span class="math inline">\(\theta = \minc_{ij}^,\)</span>(<span class="math inline">\(c_{ij}^,\)</span>为负回路中各弧的容量)，若不存在负回路，则说明当前网络流已经是最小费用流，结束算法</li><li>针对负回路对应网络 <span class="math inline">\(D\)</span>中的圈，若该圈是增流圈，则把增流圈方向上与负回路方向一若该圈致的所有弧的流量加上<spanclass="math inline">\(\theta\)</span>，把增流圈方向上与负回路方向相反的所有弧的流量减去<span class="math inline">\(\theta\)</span> 不是增流圈，则转到 3重新寻找负回路</li><li>继续寻找负回路，如果还有负回路，继续调整；否则返回 2</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>图</tag>
      
      <tag>生成树</tag>
      
      <tag>最短路</tag>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正大杯随笔</title>
    <link href="/2025/01/18/%E6%AD%A3%E5%A4%A7%E6%9D%AF%E9%9A%8F%E7%AC%94/"/>
    <url>/2025/01/18/%E6%AD%A3%E5%A4%A7%E6%9D%AF%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天正好在学习正大杯的一些知识，正好就来做一些笔记。</p><h2 id="数据清洗">数据清洗</h2><p>数据去重：去除数据集中的重复记录。这可以通过比较记录中的唯一标识符或关键字段来实现。</p><p>缺失值处理：填补数据集中的缺失值。这可以使用插值、平均值、中位数、众数等方法进行处理。</p><p>异常值处理：检测和处理数据集中的异常值。异常值可以被删除或替换为可接受的值。</p><p>数据标准化：将数据格式标准化为一致的格式，以便于处理和分析。例如，可以将日期格式标准化为ISO格式。</p><p>数据转换：数据转换实质上是将数据的格式进行转换，其目的主要是为了便于处理和分析数据。例如，将文本格式的日期转换为日期格式。</p><p>数据验证：确保数据集中的数据准确性和完整性。</p><h2 id="信度分析">信度分析</h2><p>信度，又叫可靠性，可检验同一事物重复测量结果的一致性程度，其与测量结果的正确与否无关，而是反映测量工具（如调查问卷）的稳定性或可靠性，一般用信度系数表示。</p><p>一般而言，如果信度系数达到 0.9以上，表示该测验或量表的信度很好；信度系数在 0.8以上，表示可以接受；如果在 0.7以上，则应该对该测量工具进行修订，但仍不失其价值；如果低于0.7，则此量表的调查结果很不可信，需要重新设计量表。</p><h3 id="科隆巴赫系数cronbachs-alpha">科隆巴赫系数（Cronbach'salpha）</h3><p>科隆巴赫系数也叫 <span class="math inline">\(\alpha\)</span>信度系数：</p><p><span class="math display">\[\alpha = \dfrac{k}{k-1}(1 -\dfrac{\Sigma^{k}_{1} S^2_i}{S^2_x})\]</span></p><p>式中 <span class="math inline">\(k\)</span> 为题目个数，<spanclass="math inline">\(S^2_i\)</span> 第 <spanclass="math inline">\(i\)</span> 题得分的方差，<spanclass="math inline">\(S^2_x\)</span> 为测验总得分的总方差。</p><p><span class="math inline">\(\alpha\)</span>信度系数与量表的题目数量关系密切。如果一个含有约 10 个题目的量表，<spanclass="math inline">\(\alpha\)</span> 系数应能达到 0.8以上；如果量表的题目增加，<span class="math inline">\(\alpha\)</span>系数会随之升高，当题目多于 20 个时，<spanclass="math inline">\(\alpha\)</span> 系数会很容易地升至 0.9以上；如果量表的题目减少，<span class="math inline">\(\alpha\)</span>系数会随之降低。</p><h2 id="效度分析">效度分析</h2><p>效度是指测量的有效性程度，是测量工具能测出所要测量特质的程度，即准确性、有用性。</p><p>在测量理论中，效度被定义为在一系列测量中，与测量目的有关的真实方差与实得分数方差的比率：</p><p><span class="math display">\[r_{xv}^{2} =\dfrac{\sigma_v^2}{\sigma_x^2}\]</span></p><p>其中 <span class="math inline">\(r_{xv}\)</span>为测量的效度系数，<span class="math inline">\(\sigma_v^2\)</span>表示真实方差，<span class="math inline">\(\sigma_x^2\)</span>表示实得分数方差。一般使用因子分析模型，采用 KMO 和 Bartlett球形度检验。</p><h2 id="质量控制">质量控制</h2><ol type="1"><li>需要对于所有问卷进行筛选，对于前后答案明显不一致，逻辑矛盾的问卷，我们会将问卷作为无效问卷处理。</li><li>当发现无效问卷较多时，需要发放更多的问卷保证样本量，并及时对于所收集的数据进行整理和汇总，直至满足所需要的样本量。</li></ol><h2id="对于收集的问卷信息的分析因子分析法">对于收集的问卷信息的分析（因子分析法）</h2><h3 id="合适度和效果检验">合适度和效果检验</h3><p>使用 KMO统计量来调查是否能存在相关关系。变量共同度分析是为查看原始变量能被提取的因子所表示的程度。在这之前我们得让变量标准化，以消除量纲的影响。</p><h4 id="kmo">KMO</h4><p>KMO 是 Kaiser-Meyer-Olkin 的取样适当性量数，当 KMO值愈大时，表示变量间的共同因素愈多，愈适合进行因素分析，根据专家Kaiser（1974）观点，如果 KMO 的值小于 0.5 时，较不宜进行因素分析，</p><h4 id="标准化变量">标准化变量</h4><p>xxxxxxxxxx17 1# Distant-Skys2# To make a picture smaller orbigger.3​4import cv2 as cv5import numpy as np6​7image =cv.imread('1.jpg')8​9res =cv.resize(image,None,fx=0.7,fy=0.7,interpolation=cv.INTER_CUBIC)10# ifwant to make picture bigger ,let ((fx and fy) &gt; 1).11​12# print theresult picture.13# cv.imshow('result image',res)14# cv.waitKey(0)15#cv.destroyAllWindows()16​17cv.imwrite('1_result.jpg',res)python</p><p>对于样本序列$ x_1,x_2,, x_n$进行标准化，有</p><p><span class="math display">\[y_i = \frac{x_i - \barx}{s_i}\]</span></p><p>产生的<span class="math inline">\(y_1,y_2,\dots,y_n\)</span> 是均值为0，方差为 1，无量纲的数据。</p><h3 id="累计方差贡献率分析">累计方差贡献率分析</h3><p>如果变量的累计方差贡献率较大，说明因子对于变量的解释能力非常好。</p><h3 id="成分矩阵">成分矩阵</h3><p>成分矩阵显示的是旋转之前的因子载荷矩阵，其中有些变量在各因子上的载荷比较接近，难以对因子进行明确定义，因此，对于因子解释和命名更有指导意义的是旋转后的成分矩阵。</p><h3 id="聚类分析">聚类分析</h3><p>聚类分析是统计学中研究“物以类聚”问题的多元统计分析方法。</p><p>对个案进行分类：Q型聚类（平方欧式距离）</p><p>对变量进行分类：R型聚类（皮尔逊相关性）</p><h4 id="聚类的好不好">聚类的好不好？</h4><ul><li>能不能给每一类起一个名字？（显著的特征）</li><li>ANOVA显示两个或多个类别的群体，在各个变量上是否有差异，有差异说明聚类相对成功。</li><li>每个类别各有多少被试，最好比较均匀</li></ul><h2 id="杂项">杂项</h2><h3 id="swot分析法">SWOT分析法</h3><p>所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>S （Strengths）是优势、W （Weaknesses）是劣势、O（Opportunities）是机会、T（Threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。</p><h4 id="多重响应分析">多重响应分析</h4><p>多重相应分析一般用于多选题的分析，一般有三种：</p><ul><li>一道多选题，每个选项用一列表示，0表示未选，1表示已选；</li><li>一道排序题，存在选项先后次序，每个选项用一列表示，列值对应选项的次序；</li><li>一道多选题，存在选项先后次序，每个次序用一列表示，列值对应选择的选项。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>市场调研大赛</tag>
      
      <tag>SPSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划基础</title>
    <link href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性规划基础">线性规划基础</h1><p>线性规划是统筹学中最重要的一种系统优化方案，引用领域十分广泛，包括生产计划、物资调运、任务分配、资源优化配置、经济规划等问题。也有许多线性规划的应用，我们这里就用COPT的规划求解器去学习使用。</p><h2 id="线性规划的基本定义">线性规划的基本定义</h2><p>一般形式为：</p><p><span class="math inline">\(\max (\min) z = c_1x_1+c_2x_2+\cdots  +c_nx_n\)</span></p><p><span class="math inline">\(s.t.\begin{cases}  a_{11}x_1+a_{12}x_2+\cdots + c_{1n}x_n = b_1 \\ a_{21}x_1+ a_{22}x_2 + \cdots+c_{2n}x_n = b_2 \\ \cdots \\ x_1,x_2,x_3\cdots x_n\geq 0 \end{cases}\)</span></p><p>其中<span class="math inline">\(\max (\min) z = c_1x_1+c_2x_2+\cdots  +c_nx_n\)</span> 称为目标函数，</p><p><span class="math inline">\(a_{11}x_1+a_{12}x_2+\cdots + c_{1n}x_n =b_1 \\ a_{21}x_1 + a_{22}x_2 + \cdots+c_{2n}x_n = b_2\)</span>称为约束条件，这里的=号，可以更换成<span class="math inline">\(\leq \\geq \ \neq\)</span></p><p><span class="math inline">\(x_1,x_2,x_3\cdots x_n \geq 0\)</span>称为非负约束。</p><p>线性规划问题可以由向量和矩阵表示：</p><p><span class="math inline">\(\max(\min) z = C^T X \\ s.t.\begin{cases} AX \leq(=,\geq) \ b \\ X \geq 0 \end{cases}\)</span></p><p>对于正常的解法，单纯形法等方法，不在介绍，直接上COPT怎么用。</p><h2 id="copt如何解决线性规划">COPT如何解决线性规划</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">题目：某加工厂需要加工一批圆钢调料，规格为70cm,52cm,35cm，这三种圆钢条料的需要量为100条，150条，900条</span><br><span class="hljs-string">库房库存一批长 180cm 的圆钢坯料，先对圆钢坯料进行切割。</span><br><span class="hljs-string">问：如何下料，使总余料最少。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> coptpy <span class="hljs-keyword">as</span> cp<br><span class="hljs-keyword">from</span> coptpy <span class="hljs-keyword">import</span> COPT<br><br>env = cp.Envr() <br>model = env.createModel(<span class="hljs-string">&quot;eg2&quot;</span>)<span class="hljs-comment"># 搭建环境</span><br><br>x1 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x1&quot;</span>) <span class="hljs-comment"># 定义变量，参数lb为下界，ub为上界</span><br>x2 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x2&quot;</span>)<span class="hljs-comment"># vtype为变量类型COPT.CONTINUOUS连续型变量，COPT.BINARY二进制变量</span><br>x3 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x3&quot;</span>)<span class="hljs-comment"># COPT.INTEGER 为整数变量</span><br>x4 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x4&quot;</span>)<br>x5 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x5&quot;</span>)<br>x6 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x6&quot;</span>)<br>x7 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x7&quot;</span>)<br>x8 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x8&quot;</span>)<br><br>model.addConstr(<span class="hljs-number">2</span>*x1 + x2 + x3 + x4 &gt;= <span class="hljs-number">100</span>)<span class="hljs-comment"># 给出约束条件</span><br>model.addConstr(<span class="hljs-number">2</span>*x2 + x3 + <span class="hljs-number">3</span>*x5 + <span class="hljs-number">2</span>*x6 + x7 &gt;= <span class="hljs-number">150</span>)<br>model.addConstr(x1 + <span class="hljs-number">3</span>*x3 + <span class="hljs-number">2</span>*x6 + <span class="hljs-number">3</span>*x7 + <span class="hljs-number">5</span>*x8 &gt;= <span class="hljs-number">900</span>)<br><br>model.setObjective(<span class="hljs-number">5</span>*x1 + <span class="hljs-number">6</span>*x2 + <span class="hljs-number">23</span>*x3 + <span class="hljs-number">5</span>*x4 + <span class="hljs-number">24</span>*x5 + <span class="hljs-number">6</span>*x6 + <span class="hljs-number">23</span>*x7 + <span class="hljs-number">5</span>*x8, sense=COPT.MINIMIZE)<br><span class="hljs-comment"># 设置目标函数 setObjective(expr, sense=None)，expr为表达式，sense为目标函数的优化方向，有MAXIMIZE和MINIMIZE</span><br><br>model.solve()<br><span class="hljs-comment"># 解线性规划</span><br><br><span class="hljs-keyword">if</span> model.status == COPT.OPTIMAL: <span class="hljs-comment"># 输出规划中的一些变量值</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Objective value: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(model.objval))<br>  allvars = model.getVars()<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variable solution:&quot;</span>)<br>  <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> allvars:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; x[&#123;0&#125;]: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(var.index, var.x))<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variable basis status:&quot;</span>)<br>  <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> allvars:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; x[&#123;0&#125;]: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(var.index, var.basis))<br></code></pre></div></td></tr></table></figure><h2 id="整数规划">整数规划</h2><p>跟线性规划没有什么差距，就只是将连续型的变量变成了离散的，只能取整数<code>COPT.INTEGER</code>。</p><p>所有变量全取整数的规划叫纯整数规划，部分变量取整数的规划称为混合整数规划。所有变量都取0,1两个值的规划叫0-1规划，部分的叫0-1混合规划。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>Math</tag>
      
      <tag>线性规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>也该结束了</title>
    <link href="/2025/01/13/%E4%B9%9F%E8%AF%A5%E7%BB%93%E6%9D%9F%E4%BA%86/"/>
    <url>/2025/01/13/%E4%B9%9F%E8%AF%A5%E7%BB%93%E6%9D%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=501829&amp;auto=0&amp;height=66"></iframe><p>（最喜欢的音乐，也很契合）</p><blockquote><p>时间、运气、命运对 OIer 们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的 OIer，也难以保证他在省选或 NOI一定能够有和他的付出对等的回报。这是很多 OIer心知肚明的事实，也是我们无力感的根源。</p><p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p><p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打CF，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100 分与 0 分之差，一个部分分之差就可能是 20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p></blockquote><p>想了这么长时间，也该结束这些没有做完的梦了，作为一名 OI选手是不负责任的，在高中花了许多时间却没有任何成绩，所谓的那些也只是虚无缥缈的一些标准，也仅仅是一些学长们出的题目的一些标准。（笑</p><p>想了怎么久，发现很长时间没有用C++写一些代码题目发现感觉不习惯，也只能让他这样下去了。我也是决定不打OI/ACM 相关的比赛了。说真的，很想去打 ACM比赛，但是也是因为我实力不是太强，没有一个像样的成绩，如果高中那次参加了比赛，至少还有个省二的奖项，至少现在还是能打的。但是就是没有，想单独参加至少圆一个高中当时的梦想，可惜都不行。可惜，都没办法以一个正规选手的身份去参加一个省级赛事。</p><p>想起当初我在床上关着灯，怕被父母发现，偷偷一个人打着CF，最后就拿到了1000分，想起当时不随大流，他们在教室里晚自习，而我申请在机房晚自习，将每天基本作业写完了就开始写代码了，那段时光，虽然累但是有光，而现在，已经无力回天。</p><p>再见了，OI，我引以为傲的OI。</p><p>下面不会更新OI的一些题目了，会写写自己的学数学建模的一些东西。:(</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round 69</title>
    <link href="/2024/11/26/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound-69/"/>
    <url>/2024/11/26/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound-69/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近一直很忙没什么时间去写题目，也就是抽空来看了几道题，周二下午没课来集中写了写。</p><h2 id="a-题">A 题</h2><p>很简单，学过高中知识就会写。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;(a+(a - b))&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b-题">B 题</h2><p>和上道题差不多，唯一不同的就是加了一个字符串处理（将string 变成int）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r)</span></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=r;i&gt;=l;i--)&#123;<br>ans += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)*base;<br>base = base * <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>end = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-built_in">num</span>(start,end);<br><br>start = end+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=end+<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>end = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b = <span class="hljs-built_in">num</span>(start,end),c = <span class="hljs-built_in">num</span>(end+<span class="hljs-number">6</span>,n<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d = (b - a);<br><br>cout&lt;&lt;(c - b) / d - <span class="hljs-number">1</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c-题">C 题</h2><p>就是数学加物理题，根据镜面反射的原理，很显然我们需要将 <spanclass="math inline">\(z\)</span>轴的坐标镜面对称。最后同时除以他们的最大公约数就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,k;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,y,z;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>z = <span class="hljs-number">2</span>*k - z;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">gcd</span>(x,y),z);<br><span class="hljs-keyword">if</span>(x % t == <span class="hljs-number">0</span>)x = x / t;<br><span class="hljs-keyword">if</span>(y % t == <span class="hljs-number">0</span>)y = y / t;<br><span class="hljs-keyword">if</span>(z % t == <span class="hljs-number">0</span>)z = z / t;<br><br><br>cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d-题">D 题</h2><p>稍微有点难，但是稍微想想也能出来。</p><p>看了数据范围为全都 <span class="math inline">\(\leq7\)</span>，每个计划只有取和不取两种选择，那么我们最多的方案有 <spanclass="math inline">\(2^7 =128\)</span>，所以很简单枚举每一种就行了，但是怎么让方案数与每一种的方案关联处理呢？</p><p>联系到快速幂，我们可以想到与二进制结合起来。这样就很简单就可以算出来了，剩下的就是循环和判断的事了，对了，题目默认方案之间可以有重叠（错过一次）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxq = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> t[maxn][maxn],a[maxn][maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,q;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>t[i][j] = (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)<br>a[i][j][k] = (s[k] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> anscnt = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,q),ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,q);i++)&#123;<br><span class="hljs-function">bitset&lt;maxq&gt; <span class="hljs-title">bits</span><span class="hljs-params">(i)</span></span>;<br><span class="hljs-comment">// cout&lt;&lt;bits&lt;&lt;endl;</span><br><span class="hljs-keyword">int</span> scheme[maxn][maxn],cnt = bits.<span class="hljs-built_in">count</span>();<br><span class="hljs-built_in">memset</span>(scheme,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(scheme));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;q;j++)&#123;<br><span class="hljs-keyword">if</span>(bits[j] == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;n;x++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;m;y++)<br>scheme[x][y] += a[j][x][y];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;n;x++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;m;y++)&#123;<br><span class="hljs-keyword">if</span>(t[x][y] == <span class="hljs-number">1</span> &amp;&amp; scheme[x][y] == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[x][y] == <span class="hljs-number">0</span> &amp;&amp; scheme[x][y] &gt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span>flag = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span>(anscnt &gt; cnt)anscnt = cnt,ans = i;<br>&#125;<br><br><span class="hljs-keyword">if</span>(ans == <span class="hljs-number">-1</span>)cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;anscnt&lt;&lt;endl;<br><span class="hljs-function">bitset&lt;maxq&gt; <span class="hljs-title">bits</span><span class="hljs-params">(ans)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)<br><span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-number">1</span>)<br>cout&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="e-题">E 题</h2><p><del>说实话，到现在我还没有写出来，感觉是常数太大的问题，感觉时间复杂度没啥太大的问题。感觉极限能过。</del>（突然想到会退化了）</p><p>我的想法是，先用前缀和算出前 <span class="math inline">\(n\)</span>项和，顺便再记录正数的数字位置，将每个放入 map中。然后再枚举后面的一个划分点，然后在用 <code>lower_bound()</code>记录算出区间里有没有正数，就 OK 了。</p><p>但是我这个想法会退化，如果数据的许多小区间中，前缀和有相同的，就比如<code>1 -1 1 -1 1 -1 1 -1</code>， 会退化成 <spanclass="math inline">\(O(n)\)</span> 查找每个区间。</p><p>所以最坏时间复杂度应该为 <span class="math inline">\(\Theta (n^2 \logn)\)</span></p><p>平均时间复杂度为 <span class="math inline">\(O (n \log n \logn)\)</span></p><p>我在夜里突然想到一个很简单的结论，就是划分的三个数组一定是 <spanclass="math inline">\(\frac{S}{3}\)</span>，那么只需要加上这个判断，那么时间复杂度就会大大下降。wok，这个第一次看我还真没想到这么显然的结论。</p><p>那么优化过的最坏时间复杂度下降到 <span class="math inline">\(\Theta(n \log n)\)</span>。</p><p>平均时间复杂度为 <span class="math inline">\(O (n + \logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn],sum[maxn];<br>map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; m;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; pos;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">if</span>(a[i] &gt; <span class="hljs-number">0</span>)pos.<span class="hljs-built_in">push_back</span>(i);<br>cnt += a[i];<br>&#125;<br><br><span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> || pos.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>)&#123;cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><br>sum[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + a[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br><span class="hljs-keyword">if</span>(sum[i] == cnt / <span class="hljs-number">3</span>)<br>m[sum[i]].<span class="hljs-built_in">push_back</span>(i);<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-keyword">int</span> num = sum[n] - sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num) == <span class="hljs-number">1</span> &amp;&amp; num == cnt / <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> it : m[num])&#123;<br><span class="hljs-keyword">if</span>(i &lt;= it)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">int</span> num2 = sum[i<span class="hljs-number">-1</span>] - sum[it];<br><span class="hljs-keyword">auto</span> a1 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> a2 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),it+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> a3 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),i);<br><span class="hljs-keyword">if</span>(num2 == num &amp;&amp; a1 != pos.<span class="hljs-built_in">end</span>() &amp;&amp; a2 != pos.<span class="hljs-built_in">end</span>() &amp;&amp; a3 != pos.<span class="hljs-built_in">end</span>())&#123;<br><span class="hljs-keyword">if</span>(*a1 &lt;= it &amp;&amp; *a2 &lt;= i<span class="hljs-number">-1</span> &amp;&amp; *a3 &lt;= n)ans ++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-CF DIV2.ABC题-2</title>
    <link href="/2024/11/22/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CFDIV2-ABC%E9%A2%98-2/"/>
    <url>/2024/11/22/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CFDIV2-ABC%E9%A2%98-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cf-div2.">CF Div2.</h1><p>写了四个的 Div2了，知道自己差不多在哪了，继续开始突破，看看一周能不能再突破一百。</p><p>现在大约在 <span class="math inline">\(1200\)</span> 左右。</p><h2 id="codeforces-round-980-div.-2">Codeforces Round 980 (Div. 2)</h2><h3 id="b-题">B 题</h3><p>本来想的是排序之后一个一个判断是否能不能超过 <spanclass="math inline">\(k\)</span>，如果不能则需要比这个多一次才能跳到下一个数组上，没想到连样例都没过。</p><p>后来看了看样例解释就懂了，同样是排序，变成递增的，然后一个一个判断能不能这个数后面的每个都去和他一样的话，总和能不能超过所需要的饮料，能的话就需要多一次去判断是否是空的了。</p><p>如果不能，那这个不行，就只能用完这个了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> T;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,k;cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> len = (n - i + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;len&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(a[i] * len &gt;= k)&#123;<br>ans += k;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>ans += (a[i] + <span class="hljs-number">1</span>);<br>k -= a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c-题">C 题</h3><p>这道题题目根本没有什么提醒让我从哪里想，题解就感觉很空穴来风，样例解释也没有什么可以往这上面靠的。</p><p>题解思路就是用这两个小数组的总和作为值从小到大排序，最后排序的结果就是答案。题解证明：注意，如果在最终的顺序中有两个相邻的数组，左边数组的元素之和大于右边数组的元素之和，那么我们可以交换它们，并且逆序对的数量不会增加。因此，我们可以通过交换相邻的数组，使得每次逆序对的数量不增加，从而将任何最优解转化为我们的解。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nums</span>&#123;</span><br><span class="hljs-keyword">int</span> a1,a2;<br><span class="hljs-keyword">int</span> sum;<br>&#125; a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(nums x,nums y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.sum &lt; y.sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a[i].a1,&amp;a[i].a2);<br>a[i].sum = a[i].a1 + a[i].a2;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d &quot;</span>,a[i].a1,a[i].a2);<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="codeforces-round-979-div.-2">Codeforces Round 979 (Div. 2)</h2><h3 id="c-题-1">C 题</h3><p>这个比赛前2题没什么难度，都是 <spanclass="math inline">\(800\)</span> 分左右，有点简单了，C题很显然是构造题，想了想，能想到有第一个或最后一个是 <spanclass="math inline">\(1\)</span>的肯定能赢，但是后面怎么处理，根本想不到。还是只能看题解了。</p><p>如果中间的有两个 <code>true</code> 那么一定可以赢，我们可以让 Alice最后去管理两个 <code>true</code>。首先第一个放在 <code>or</code>之前。如果 Bob 没有将他的运算符放在两个 <code>true</code> 之间，那么Alice 将在下一步中将 <code>or</code> 放在两个 <code>true</code>之间并获胜。</p><p>如果没有连续的 <code>true</code>，每当 Alice 将 <code>true</code>或相邻位置放置时，Bob 都会通过在 <code>true</code> 之后放置<code>and</code> 来响应，这将使此子句无效为 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> x[<span class="hljs-number">200010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(x,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(x));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>x[i] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">bool</span> win = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>] || x[n<span class="hljs-number">-1</span>])&#123;cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(x[i] &amp;&amp; x[i<span class="hljs-number">-1</span>])<br>win = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(win) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="codeforces-round-979-div.-2-1">Codeforces Round 979 (Div.2)</h2><h3 id="b-题-1">B 题</h3><p>这道题挺有意思，我发现最优的方案一定是先选出 <spanclass="math inline">\(k\)</span> 个最大的，然后每个减去这 <spanclass="math inline">\(k\)</span> 个中最小的一个数。最后将大于 <spanclass="math inline">\(0\)</span>的数再存进去。重复这几个操作。这期间可以用堆来存储数字，这样每次读取只需要<span class="math inline">\(O(\log n)\)</span>读取每个数。这种贪心不太对，在评论区也有许多人用了这种方式，但是都无一例外的Wa 了。</p><p>直到一位老哥的解释让我恍然大悟。他说可以看看这个样例。<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure></p><p>的确，答案确实和我们想的不太一样。其实最优方案是，每次将最大 <spanclass="math inline">\(k\)</span> 个元素取出，减去 <spanclass="math inline">\(1\)</span> 后再放回，但是数字要大于 <spanclass="math inline">\(10^9\)</span>，很显然 TLE 了。</p><p>有个更简单的方法。我们最大限度的让每个客人<strong>随机</strong>去选汽车。这样最后选不够<span class="math inline">\(x\)</span> 辆汽车之后，就会有两种情况；</p><ol type="1"><li>所有型号都将具有相同数量的剩余汽车，很显然，这种答案就是 <spanclass="math inline">\(\lceil \dfrac{a_1+a_2+\dotsb + a_n}{x}\rceil\)</span>。</li><li>如果还有型号不为 <span class="math inline">\(0\)</span>但是个数小于等于 <span class="math inline">\(x\)</span>，那么答案为<span class="math inline">\(\max(a_1+a_2+\dotsb +a_n)\)</span>。</li></ol><p>这两种结合一下就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,r;<br>cin&gt;&gt;n&gt;&gt;r;<br><span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;cin&gt;&gt;x;<br>cnt1 += (x % <span class="hljs-number">2</span>);<br>ans += (x/<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>; <br>r -= (x/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(r &gt;= cnt1)ans += cnt1;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">int</span> t = cnt1 - r;<br>ans += (cnt1 - t*<span class="hljs-number">2</span>);<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>Div2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-CF DIv2.ABC题-1</title>
    <link href="/2024/11/19/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CF-DIv2.ABC%E9%A2%98/"/>
    <url>/2024/11/19/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CF-DIv2.ABC%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cf-div2.">CF Div2.</h1><p>除了正常的学习算法以及每周一次的周赛，现在每天有时间就写写CF的div2.的前几题，具体是ABC这三题左右难度。遇到好题，以及不会的题目都会放在这里，每4场Div2.放在一起。</p><h2 id="codeforces-round-987-div.-2">Codeforces Round 987 (Div. 2)</h2><h3 id="b-题">B 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2031B#author=GPT_zh">中文题目</a></p><p>挺有意思的，很像冒泡排序，就是对于一个数，它与它后面一个数的差值等于<span class="math inline">\(1\)</span>就交换，否则不动，判断是否能成为一个有序的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>; <br><span class="hljs-keyword">int</span> a[maxn]; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br><span class="hljs-keyword">if</span>(a[i] -  a[i+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<span class="hljs-built_in">swap</span>(a[i],a[i+<span class="hljs-number">1</span>]),cnt ++;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] != i)&#123;flag = <span class="hljs-number">0</span>;&#125;<br>&#125;<br>cout&lt;&lt;(flag == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c-题">C 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2031C#author=GPT_zh">中文题面</a></p><p>刚开始想的是对于 <span class="math inline">\(n\)</span>分成奇数与偶数判断。偶数非常简单，就是每个相邻就行了。</p><p>如果是奇数，那么一定会存在三个一样的数字，也就是符合 <spanclass="math inline">\(x + y = z\)</span>， <spanclass="math inline">\(x,y,z\)</span>都是完全平方数，我列了几项，发现确实存在。（<spanclass="math inline">\(9,16,25\)</span>）就符合。但是具体怎么实现是根本想不到。</p><p>题解的想法非常妙就是可以说是递归实现。如果是 <spanclass="math inline">\(n &lt; 25\)</span> 的偶数就一定不存在方案。大于<span class="math inline">\(25\)</span>后可以递归实现，就是将小于25的部分分成 <spanclass="math inline">\(1（14个）\dots 16 (15个) \dots 25\)</span>，后面的<span class="math inline">\(15\)</span> 可以和后面 <spanclass="math inline">\(25\)</span> 后的一个组一个，间距也是 <spanclass="math inline">\(25\)</span> 个.</p><p>在实现是前面的 <span class="math inline">\(25\)</span>个直接打表。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; n &lt;= <span class="hljs-number">25</span>)&#123;cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1 3 3 4 4 5 5 6 6 1 2 7 7 8 8 9 9 10 10 11 11 12 12 13 13 1 2 &quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">14</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="codeforces-round-986-div.-2">Codeforces Round 986 (Div. 2)</h2><h3 id="b-题-1">B 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2028B#author=GPT_zh">中文题目</a></p><p>首先观察到如果 <span class="math inline">\(b = 0\)</span>时，整个数列是一个常数列 <span class="math inline">\(c\)</span>。</p><p>通过分析样例以及一些其他情况可以想到 <span class="math inline">\(c\geq n - 2\)</span> 是可以变成排列，其中 <span class="math inline">\(c =n-2\)</span> 时步骤为 <spanclass="math inline">\(n-1\)</span>，其他时候为 <spanclass="math inline">\(n\)</span> , 如果小于 <spanclass="math inline">\(n-2\)</span>就不存在，可以在纸上模拟模拟就了解了。</p><p>如果 <span class="math inline">\(b \neq0\)</span>，那么就更一般的情况，整个数列是一个等差数列 <spanclass="math inline">\(b \times (i - 1) + c\)</span>，判断出来小于 <spanclass="math inline">\(n\)</span> 的数字不贡献操作数。</p><p>本来想着一个数一个数的列举，但是好像超时了，就直接改成了直接算个数，计算每个的时间复杂度为<span class="math inline">\(O(1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt; m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>m.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;b,&amp;c);<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(c &gt;= n)cout&lt;&lt;n&lt;&lt;endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= n<span class="hljs-number">-2</span>)cout&lt;&lt;n<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span>cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt = <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>*(n-c)/b);<br>cout&lt;&lt;(n - (cnt &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : cnt))&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c-题-1">C 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2028C#author=GPT_zh">中文题目</a></p><p>这道题本来是想用线段树来解决的，但是想了想还是想不到，感觉超越我的程度了，就看了看Hint，就只是想到了用前缀和与类似于滑动窗口的类型解决，但是实现起来好像挺难的就放弃了，没想到题解的思路能懂，但是实现方法感觉有点看不懂了，就直接copy了一份题解（汗。</p><p>就是用 <span class="math inline">\(px_i\)</span> 来表示从 <spanclass="math inline">\(1 \sim i\)</span> 时能够分的最大生物数，<spanclass="math inline">\(py_j\)</span> 表示从 <span class="math inline">\(j\sim n\)</span> 时能够分的最大生物数。</p><p>我们可以让一个区间分成三份 <span class="math inline">\(1 \sim i \simj \sim n\)</span>，我们枚举 <span class="math inline">\(i \simj\)</span>也就是生物吃的区间，那么剩下两个区间就是爱丽丝能所在区间。</p><p><span class="math inline">\(px_i\)</span> 和 <spanclass="math inline">\(py_i\)</span>实现方法，就是用双指针的方式，刚开始都在开头，如果这个区间总和不到 <spanclass="math inline">\(v\)</span>,那么后面一个指针往后移动，使窗口更大一个，如果大于 <spanclass="math inline">\(v\)</span> ，就可以更新了，<spanclass="math inline">\(px_{end} = px_{start} +1\)</span>。每次更新前面的。</p><p>能力有限，也就能理解到这了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn],px[maxn],py[maxn],sum[maxn];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;v);<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br><span class="hljs-built_in">memset</span>(py,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(py));<br><span class="hljs-built_in">memset</span>(px,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(px));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>sum[i+<span class="hljs-number">1</span>] = sum[i] + a[i];<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>,end = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(start = <span class="hljs-number">1</span>;start &lt;= n;start ++)&#123;<br><span class="hljs-keyword">while</span>(end &lt;= n &amp;&amp; ans &lt; v)&#123;<br>ans += a[end];<br>++ end;<br>px[end] = <span class="hljs-built_in">max</span>(px[end],px[end<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">if</span>(ans &gt;= v)&#123;<br>px[end] = px[start] + <span class="hljs-number">1</span>;<br>&#125;<br>ans -= a[start];<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>px[i] = <span class="hljs-built_in">max</span>(px[i] , px[i<span class="hljs-number">-1</span>]);<br><span class="hljs-built_in">reverse</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><br>start = <span class="hljs-number">1</span>,end = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(start = <span class="hljs-number">1</span>;start &lt;= n;start ++)&#123;<br><span class="hljs-keyword">while</span>(end &lt;= n &amp;&amp; ans &lt; v)&#123;<br>ans += a[end];<br>++ end;<br>py[end] = <span class="hljs-built_in">max</span>(py[end],py[end<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">if</span>(ans &gt;= v)&#123;<br>py[end] = py[start] + <span class="hljs-number">1</span>;<br>&#125;<br>ans -= a[start];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>py[i] = <span class="hljs-built_in">max</span>(py[i] , py[i<span class="hljs-number">-1</span>]);<br><br><span class="hljs-built_in">reverse</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">reverse</span>(py+<span class="hljs-number">1</span>,py+n+<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// for(long long i=1;i&lt;=n;i++)cout&lt;&lt;py[i]&lt;&lt;endl;</span><br><br><span class="hljs-keyword">if</span> (px[n+<span class="hljs-number">1</span>] &lt; m) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">0</span>,j = <span class="hljs-number">1</span>;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; px[i] + py[j + <span class="hljs-number">1</span>] &gt;= m)++j;<br><span class="hljs-keyword">if</span>(px[i] + py[j] &gt;= m)<br>ans = <span class="hljs-built_in">max</span>(ans,sum[j]-sum[i]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="codeforces-round-983-div.-2">Codeforces Round 983 (Div. 2)</h2><h3 id="b-题-2">B 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2032B#author=GPT_zh">中文题目</a></p><p>这题还挺有意思的，给你一个奇数列，从 <span class="math inline">\(1\sim n\)</span>，最后让你求能不能通过合理的划分找到给定的 <spanclass="math inline">\(k\)</span>，使得 <spanclass="math inline">\(k\)</span> 为中位数。</p><p>刚开始想的是用线段树维护每一段的中位数，但是看了看线段树的定义发现好像不太行，因为每次递归就只能是奇数，没办法变成连续的一段区间，最主要是中位数不能维护。</p><p>就开始想那个第 <span class="math inline">\(k\)</span>个数一定在子数组中一定是中位数，这样才能被选出去，那么在子数组形成的中位数数组中也一定是中位数。那么最简单可以想到直接划分为三个子数组，需要的数在中间，其他的在两边。这样就一定可以。</p><p>对了，还需要中位数一定不能再左右断点，特判就好。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,k;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> &amp;&amp; k == <span class="hljs-number">1</span>)&#123;cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span> || k &gt;= n)&#123;cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">int</span> start = k,end = k;<br><span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">1</span> &amp;&amp; end &lt;= n)&#123;<br><span class="hljs-keyword">int</span> lenl  = start - <span class="hljs-number">1</span>,lenr = n - end;<br><span class="hljs-keyword">if</span>(lenl % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; lenr % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-keyword">else</span>&#123;start --;end ++;&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(start != <span class="hljs-number">1</span> &amp;&amp; end != n)&#123;<br>cout&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;start&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;end+<span class="hljs-number">1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c-题-2">C 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2032C#author=GPT_zh">中文题目</a></p><p>这道题感觉就差一点点就推出来了，但是临门一脚没想到。</p><p>题目主要是让你求出使得 <span class="math inline">\(a_x + a_y \geqa_z\)</span> 的数组的最小操作次数，每次操作都可以让任意一个 <spanclass="math inline">\(a_i\)</span> 变成数组里任意一个数。</p><p>可以想想上限，首先我们可以让除了<spanclass="math inline">\(a_1,a_n\)</span> 的所有数变成 <spanclass="math inline">\(a_n\)</span> 这样就全部成了，所以答案最多为 <spanclass="math inline">\(n - 2\)</span>。</p><p>首先想到可以先排序，这样就有序了，对于每个 <spanclass="math inline">\(i\)</span> 用双指针的方法，判断出大于 <spanclass="math inline">\(a_i\)</span>的最小和的的两个，这样我们只需要改其他的，这些的在区间因为是有序的，中间的必然符合，那么不用改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>a.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;<br>cin&gt;&gt;x;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">int</span> ans = n - <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">2</span>;r &lt; n;r++)&#123;<br><span class="hljs-keyword">if</span>(r - l &gt;= <span class="hljs-number">2</span>  &amp;&amp; a[l] + a[l+<span class="hljs-number">1</span>] &lt;= a[r])l++;<br>ans = <span class="hljs-built_in">min</span>(ans,n - (r - l + <span class="hljs-number">1</span>));<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="codeforces-round-982-div.-2">Codeforces Round 982 (Div. 2)</h2><h3 id="b-题-3">B 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2027B#author=GPT_zh">中文题目</a></p><p>这道题感觉不像 1100的，感觉看懂题都挺难的。当时看完这个题目一点思路都没有，还是看了题解之后才理解题目让我干啥的，看了评论区的发现有许多人也说这次的B 有点怪，而且感觉题目没有说清楚到底要干啥。</p><p>定义一种排序叫斯大林排序，就是如果一个数小于它前面的数，则删掉它，直到按照非递减顺序</p><p>定义一个数组为脆弱数组，就是对任意子序列任意使用这种排列可以使整个数组递减。</p><p>用贪心，当第一个为最大时，那我一定可以通过从他到倒数第二个用一次斯大林排序变成递减序列。所以他后面比他大的我要全部提前删掉</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10000</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;cin&gt;&gt;n;<br>v.<span class="hljs-built_in">clear</span>();<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;cin&gt;&gt;x;<br>v.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">999999</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> sum = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">if</span>(v[i] &lt; v[j])sum ++;<br>ans = <span class="hljs-built_in">min</span>(ans,sum);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="c-题-3">C 题</h3><p><ahref="https://vjudge.net/problem/CodeForces-2027C#author=GPT_zh">中文题目</a></p><p>这道题我只会的暴力 <spanclass="math inline">\(O(n^2)\)</span>，再进一步就想不出来了。只好看题解，才发现题解用了数组当前大小来DFS。</p><p>正解应该是，将每个 <span class="math inline">\(a_i\)</span>能够加零的数组当前大小给存起来，然后从长度为 <spanclass="math inline">\(n\)</span> 开始DFS，在DFS区间内取最大值。</p><p>时间复杂度为（估计） <span class="math inline">\(O(n \logn)\)</span>。</p><p>对了注意 vis 数组，要用 map 实现，因为数组没有那么大 <spanclass="math inline">\(10^9\)</span> 左右（就因为这个改了半天）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">300010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br>map&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; mp;<br>map&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">bool</span>&gt; vis;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t)</span></span>&#123;<br>vis[t] = <span class="hljs-number">1</span>;<br>ans = <span class="hljs-built_in">max</span>(ans,t);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : mp[t])&#123;<br><span class="hljs-keyword">if</span>(!vis[t + it - <span class="hljs-number">1</span>])&#123;<br><span class="hljs-built_in">dfs</span>(t + it - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><br>vis.<span class="hljs-built_in">clear</span>();<br>mp.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>mp[a[i] + i - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs</span>(n);<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>Div2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round66</title>
    <link href="/2024/11/17/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound66/"/>
    <url>/2024/11/17/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound66/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛客周赛round66">牛客周赛Round66</h1><h2 id="a-题">A 题</h2><p>很简单，其实就是求三个数的最大值和其他两个数之和那个打，输出最大的就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y,z;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-keyword">int</span> sum = x + y + z;<br><span class="hljs-keyword">int</span> t = <span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">max</span>(y,z));<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(sum - t,t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b-题">B 题</h2><p>构造题，构造一个<span class="math inline">\(p_i\)</span>使得<spanclass="math inline">\(a_i = p_i + p_{p_{i}}\)</span>，使得重新构造的数组<span class="math inline">\(a_i\)</span>为一个<strong>单调不增</strong>的数列。</p><p>可以想到最简单的构造就是每一个 <spanclass="math inline">\(a_i\)</span> 都是相等。很简单可以想到构造<spanclass="math inline">\(1 \dotsc n\)</span> 使得 <spanclass="math inline">\(a_i\)</span> 成立。</p><p>注意最后一个的输出没有空格。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)cout&lt;&lt;i&lt;&lt;(i== <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot; &quot;</span>);<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c-题">C 题</h2><p>可以观察到 <span class="math inline">\(n\)</span> 非常小，只有 <spanclass="math inline">\(10\)</span> 位，所以可以直接暴力枚举断点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;string s;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>cin&gt;&gt;s;<br>string ans = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>string s1 = s.<span class="hljs-built_in">substr</span>(i) + s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i);<br>ans = <span class="hljs-built_in">min</span>(s1,ans);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="de-题">D、E 题</h2><p>E 题为 D题的加强版，没有想出来。这题可以用并查集，每次操作都会使两个区间合并，就相当于并查集里的合并。</p><p>对于区间，并查集可以维护每个区间的总长度以及水量，父亲为区间的最右点。剩下的就是并查集的部分了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pa[maxn],cnt[maxn];<br><span class="hljs-keyword">int</span> n,q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> pa[x] == x ? x : <span class="hljs-built_in">Find</span>(pa[x]);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> fx = <span class="hljs-built_in">Find</span>(x),fy = <span class="hljs-built_in">Find</span>(y);<br><span class="hljs-keyword">if</span>(fx == fy)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(fx &lt; fy)<span class="hljs-built_in">swap</span>(fx,fy);<br>cnt[fx] += cnt[fy];<br>a[fx] += a[fy];<br>pa[fy] = fx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)pa[i] = i,cnt[i] = <span class="hljs-number">1</span>; <br><br><span class="hljs-keyword">int</span> opt,l,r;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>cin&gt;&gt;opt;<br><span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>)&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++)&#123;<br><span class="hljs-built_in">unite</span>(j,j+<span class="hljs-number">1</span>);<br>j = <span class="hljs-built_in">Find</span>(j) - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">int</span> x;<br>cin&gt;&gt;x;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">Find</span>(x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>,<span class="hljs-number">1.0</span>*a[f]/cnt[f]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="f-题">F 题</h2><p>这道题其实挺可惜的，当时补题时，想出来思路了，就是不会实现，看了题解才发现，题解实现的特别妙。</p><p>显然可以发现 <span class="math inline">\(Move(a)\)</span>是字典序最小的，因为 <span class="math inline">\(a\)</span>提到了最前面了，字典序当然最小，其他的依次变大。</p><p>如果存在两个相同的字母，那字典序的排名该怎么算呢？</p><p>如果将一个字母放到前面来，相对顺序变化的只有移到前面来的字符以及原来后面的一个字符，其他的相对顺序不变，不会影响到字典序的排名。</p><p>假定 <span class="math inline">\(s_i = a\)</span>，a为重复的字符。</p><ol type="1"><li>如果 <span class="math inline">\(s_i &gt; s_{i+1}\)</span> :那么是排名较小的字典序。（为什么？）因为在移动了他之后<spanclass="math inline">\(s_{i+1}\)</span>的相对顺序变小了（通俗来讲就是<spanclass="math inline">\(s_i\)</span>原本所在的位置被<spanclass="math inline">\(s_{i+1}\)</span>替换），让其他字典序无法比它更小。</li><li>如果 <span class="math inline">\(s_i &lt; s_{i+1}\)</span> :那么是排名较大的字典序。与上面的同理。</li><li>如果 <span class="math inline">\(s_i =  s_{i+1}\)</span> :不用排名，显然与后一个相同，因为无论是移动 <spanclass="math inline">\(s_i\)</span> 还是 <spanclass="math inline">\(s_{i+1}\)</span>，字符串没有变化。</li></ol><p>然后把所有排名排序，找到我们想要的那个排名字符串即可。</p><p>代码实现的非常妙，时间复杂度为 <span class="math inline">\(O(n\logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arank pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">28</span>],vv[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(arank x,arank y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.second &lt; y.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,k;string s;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br><span class="hljs-built_in">memset</span>(vv,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vv));<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>a[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br><span class="hljs-comment">// cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="hljs-keyword">int</span> tar;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(k &lt;= a[i])&#123;<br>tar = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>k -= a[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(i == n<span class="hljs-number">-1</span>)vv[i] = r;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(s[i] &lt; s[i+<span class="hljs-number">1</span>])<br>vv[i] = r --;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt; s[i+<span class="hljs-number">1</span>])<br>vv[i] = l ++;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; vv[i] == <span class="hljs-number">-1</span>)<br>vv[i] = vv[i+<span class="hljs-number">1</span>];<br><br>vector&lt;arank&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span>)<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i,vv[i]));<br>&#125;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : vec)&#123;<br>k --;<br><span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;(<span class="hljs-keyword">char</span>)(tar + <span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;it.first;i++) cout&lt;&lt;s[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=it.first+<span class="hljs-number">1</span>;i&lt;n;i++) cout&lt;&lt;s[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round67</title>
    <link href="/2024/11/11/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound67/"/>
    <url>/2024/11/11/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound67/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛客周赛round67">牛客周赛Round67</h1><h2 id="a-题">A 题</h2><p>很简单，暴力处理就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>string s;<br>cin&gt;&gt;n&gt;&gt;s;<br>string s1,s2,s3;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>s1 += s[i];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>s2 += s[i];<br><span class="hljs-keyword">else</span><br>s3 += s[i];<br>&#125;<br>cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="b-题">B 题</h2><p>写起来非常简单，注意精度问题，最后比较的时候同时乘以分母可以忽略精度问题。比赛时就没想起这个东西，导致分低。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,b,c,d;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ay = c*b/d;<br><span class="hljs-keyword">if</span>(ay*d &gt;= b*c)ay--;<br>cout&lt;&lt;a-ay&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c-题">C 题</h2><p>其实就是限定枚举。只枚举一个，另一个可以通过 C算出来。复杂度就降低一个。话说比赛时因为以为相加的有无限多个，而直接想错思路，应该是只有两个加分。（哭</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,c;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=c;i++)&#123;<br><span class="hljs-keyword">int</span> b = c - i;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">to_string</span>(i).<span class="hljs-built_in">length</span>() + <span class="hljs-built_in">to_string</span>(b).<span class="hljs-built_in">length</span>() + <span class="hljs-built_in">to_string</span>(c).<span class="hljs-built_in">length</span>() + <span class="hljs-number">2</span> == n)<br>ans ++;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d-题">D 题</h2><p>这道题真的可惜，比赛时差一点点就能满分了，但是整体思路没问题。看样例以及稍加分析，就可以看出最优的区间就创造一个像滑动窗口一样的组，长度为<span class="math inline">\(n-k+1\)</span> 的一个从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n-k+1\)</span>的区间，然后让队头移除窗口，队尾加上刚刚移除的数，这样一定可以构造出一个k 个的 “极大不同区间”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,k;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(n &lt; k)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(n == k)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;<br>els&#123;<span class="hljs-function">e</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-k+<span class="hljs-number">1</span>;i++)</span></span>&#123;cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;a[i] = i;&#125;<br>a[<span class="hljs-number">0</span>] =a[n-k+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k<span class="hljs-number">-1</span>;i++)&#123;cout&lt;&lt;a[i % (n-k+<span class="hljs-number">1</span>)]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>剩下两个都没学过了，等到后面学到了，再来补吧，每天学的太多了，基本上没有什么休息时间，全在看代码。</p>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划---摆花（有意思的一道dp）</title>
    <link href="/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/"/>
    <url>/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补题计划，也是我的oi生涯的最后一章，如果这一次能够成功，至少以一个正规选手能参加一次正规的比赛一次，为了自己那几年高中的努力，泪水，确实，该开始了，如果12月的那次校级比赛，没有得到大三的认可，那......这次的oi之旅真的要结束了。我虽然也不想让他翻篇，不想结束那些在机房里一个静静地写题，不被任何人认可的那段寂静。但天下没有不散的宴席，如果没有，那么该翻篇了。最后一次。</p><blockquote><p>时间、运气、命运对 OIer 们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的 OIer，也难以保证他在省选或 NOI一定能够有和他的付出对等的回报。这是很多 OIer心知肚明的事实，也是我们无力感的根源。</p><p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p><p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打CF，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100 分与 0 分之差，一个部分分之差就可能是 20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p></blockquote><h2 id="摆花">摆花</h2><h3 id="题目描述">题目描述</h3><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 <spanclass="math inline">\(m\)</span>盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 <spanclass="math inline">\(n\)</span> 种花，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 标号。为了在门口展出更多种花，规定第<span class="math inline">\(i\)</span> 种花不能超过 <spanclass="math inline">\(a_i\)</span>盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p><p>试编程计算，一共有多少种不同的摆花方案。</p><h3 id="输入格式">输入格式</h3><p>第一行包含两个正整数 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(m\)</span>，中间用一个空格隔开。</p><p>第二行有 <span class="math inline">\(n\)</span>个整数，每两个整数之间用一个空格隔开，依次表示 <spanclass="math inline">\(a_1,a_2, \cdots ,a_n\)</span>。</p><h3 id="输出格式">输出格式</h3><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对<span class="math inline">\(10^6+7\)</span> 取模的结果。</p><h3 id="样例-1">样例 #1</h3><h4 id="样例输入-1">样例输入 #1</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h4 id="样例输出-1">样例输出 #1</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">2<br></code></pre></div></td></tr></table></figure><h4 id="提示">提示</h4><p>【数据范围】</p><p>对于 <span class="math inline">\(20\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le8\)</span>。</p><p>对于 <span class="math inline">\(50\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le20\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 数据，有 <spanclass="math inline">\(0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le100\)</span>。</p><h2 id="思路">思路</h2><p>刚开始我想的是让 <span class="math inline">\(dp_{i,j,k}\)</span>表示为摆在第i个位置，摆的第j种花盆的第k个。但是好像细想有点反直觉，就是有点感觉有点不对。最后我想到，其实i可以省略，因为这个摆的花盆与j与k有关（因为题目说花盆有序），就是一个单调不下降子序列。</p><p>本来想是通过直接去掉i，但是细想这种又有点不对，最后求最后有多少种的时候又有不知道输出什么。</p><p>看了我之前的代码，我理解了，就是可以定义 <spanclass="math inline">\(d_{i,j}\)</span> 为在用到第 i 种花时，用了第 <spanclass="math inline">\(j\)</span> 盆花的方案数（<strong>注意：这里<spanclass="math inline">\(j\)</span>指的是全体的<spanclass="math inline">\(j\)</span>盆，而不是<spanclass="math inline">\(a_{i}\)</span>的第<spanclass="math inline">\(j\)</span>盆</strong>。</p><p>这样对于每个 <span class="math inline">\(d_{i,j}\)</span>可以去更新后面的 <span class="math inline">\(d_{i+1,j+k}\)</span>，k表示对于第 i 种花的约束。</p><p>那么动态转移方程为：</p><p><span class="math display">\[d_{i+1,j+k} = d_{i+1,j+k} + d_{i,j}\qquad (k = 1,2,....a_i)\]</span></p><p>xxxxxxxxxx31 1#include&lt;bits/stdc++.h&gt;2​3using namespacestd;4​5int T;6​7int main()8{9 int T;10 cin&gt;&gt;T;11 while(T--){12 intn,r;13 cin&gt;&gt;n&gt;&gt;r;14 int cnt1 = 0,ans = 0;15 for(inti=1;i&lt;=n;i++){16 int x;cin&gt;&gt;x;17 cnt1 += (x % 2);18 ans +=(x/2)<em>2; 19 r -= (x/2);20 }21 22 if(r &gt;= cnt1) ans += cnt1;23else{24 int t = cnt1 - r;25 ans += (cnt1 - t</em>2);26 }27 28cout&lt;&lt;ans&lt;&lt;endl;29 }30 return 0;31}cpp</p><p>以后遇到好题，都会加入补题计划（如果这次失败了，那也该和OI说再见了，一心一意的开始考研了）。</p>]]></content>
    
    
    <categories>
      
      <category>算法、 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树</title>
    <link href="/2024/10/05/AVL%E6%A0%91/"/>
    <url>/2024/10/05/AVL%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="avl-树">AVL 树</h1><h2 id="前言">前言</h2><p>AVL树是二叉搜索&amp;平衡树的一种，能够担任快速地插入，查找，等操作的数据结构。二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有<span class="math inline">\(n\)</span>个结点的二叉搜索树中，这些操作的最优时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>，最坏为 <spanclass="math inline">\(O(n)\)</span>。</p><h2 id="二叉搜索树的定义">二叉搜索树的定义</h2><ul><li>空树为二叉搜索树</li><li>如果二叉搜索树的左子树不为空，那么它的左子树上所有点的附加权值均小于其根节点的值。</li><li>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</li><li>二叉搜索树的左右子树均为二叉搜索树。</li></ul><p>简单来说，就是一棵树满足全部左子树的值小于其根节点，全部右子树的值大于其根节点。</p><h2 id="节点的定义">节点的定义</h2><p>与正常的树相同，有左右子节点。还有需要维护的总体大小，高度。全部用指针实现。在保存时只需保存根节点的指针就行。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> key;<br>AVLTreeNote *Left;<br>AVLTreeNote *Right;<br><span class="hljs-keyword">int</span> height;<br><span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">int</span> count;<br><span class="hljs-built_in">AVLTreeNote</span>(<span class="hljs-keyword">int</span> value): <span class="hljs-built_in">key</span>(value), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">Left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">Right</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">height</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="基本操作">基本操作</h2><h3 id="遍历">遍历</h3><p>对于一个符合要求的二叉平衡树，它的中序遍历为非降的序列。那么可以利用这个性质来debug。(在小范围数据特别好用)，时间复杂度为<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 树的中序遍历，并且按顺序输出节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Traversal</span><span class="hljs-params">(AVLTreeNote* root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Left);<br>cout&lt;&lt;<span class="hljs-string">&quot;root-&gt;key: &quot;</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="hljs-string">&quot; height: &quot;</span>&lt;&lt;root-&gt;height&lt;&lt;<span class="hljs-string">&quot; size: &quot;</span>&lt;&lt;root-&gt;size&lt;&lt;<span class="hljs-string">&quot; count : &quot;</span>&lt;&lt;root-&gt;count&lt;&lt;<span class="hljs-string">&quot; Left(if have): &quot;</span>&lt;&lt;(root-&gt;Left ? root-&gt;Left-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot; Right(if have): &quot;</span>&lt;&lt;(root-&gt;Right ? root-&gt;Right-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Right);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="寻找最大最小值">寻找最大最小值</h3><p>一个二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右链的顶点。时间复杂度为<span class="math inline">\(O(h)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉平衡树</tag>
      
      <tag>AVL 树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序（Heapsort）</title>
    <link href="/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/"/>
    <url>/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆排序heapsort">堆排序（Heapsort）</h1><p>堆排序指利用堆数据结构所设计的一种排序算法，</p><h2 id="排序">排序</h2><p>首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；</p><p>之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；</p><p>以此类推，在第 <span class="math inline">\(n-1\)</span>次操作后，整个数组就完成了排序。</p><ul><li>如何从一个无序序列建成一个堆？</li><li>如何将堆顶的元素取出之后，调整剩余元素成为一个新的堆？</li></ul><p>下面是具体步骤：</p><p>先解决第一个问题，首先现将数组从上至下转换成二叉树，对于一个节点<span class="math inline">\(i\)</span>，它的父节点为 <spanclass="math inline">\(i/2\)</span>，左儿子为 <spanclass="math inline">\(2 \times i\)</span>，右儿子为 <spanclass="math inline">\(2 \times i + 1\)</span>。现在是无序堆，我们要让这个无序堆变成最大堆（最小堆）。</p><p>从最后一个子堆开始，首先开始对比左右儿子，有的话取较大的子节点，再与父节点相比，如果比父节点大，那么就将儿子与父亲交换，这样一个子堆就变成了最大堆。</p><p>最后自顶向上去创建最大堆，直至最大堆完成。</p><p>将创建完成的最大堆的父节点给下放，放到最下面的一个节点，不动它了，之后对前面的继续变成最大堆，不断重复这些步骤。</p><h3 id="例子">例子</h3><p>首先我们选一个数组 [100, 5, 3, 11, 33, 6, 8,7]，按照数组顺序来构建一棵树。如下图</p><figure><img src="https://s2.loli.net/2024/09/08/tTX1eJirlWSyq8L.png"alt="graph" /><figcaption aria-hidden="true">graph</figcaption></figure><p>按照步骤，先看最后一个子堆，就是最下面的 11，发现 11没有右儿子，有个左儿子 7，符合最大堆的性质，现在在看以 5为父节点的堆，发现右儿子更大，再与父节点比较，发现儿子比父节点大，那么 5和 33 交换，交换后子堆符合最大堆的性质。</p><figure><img src="https://s2.loli.net/2024/09/08/8HYlK2rPO7SD5VF.png"alt="graph_1" /><figcaption aria-hidden="true">graph_1</figcaption></figure><p>再按照上面的规则将 3 的堆，变成最大堆，再将 100为父节点的堆变成最大堆，最后成为下图：</p><figure><img src="https://s2.loli.net/2024/09/08/ZXOEij3dUBwmLK1.png"alt="graph_2" /><figcaption aria-hidden="true">graph_2</figcaption></figure><p>这样我们第一步就完成了，下面将整个最大堆的父节点 100放到堆的末尾(实际上是100与7交换)，我们就不管它了。</p><figure><img src="https://s2.loli.net/2024/09/08/li8VRZKedbEJzak.png"alt="graph_3" /><figcaption aria-hidden="true">graph_3</figcaption></figure><p>然后继续开始最大堆调整，直至一轮结束，在 7升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。这里就不给图了。</p><p>最后不断建立最大堆，并且扩大有序区，最终全部有序，最终图如下图所示</p><figure><img src="https://s2.loli.net/2024/09/10/23CHIv95YDNyGWV.png"alt="graph6.png" /><figcaption aria-hidden="true">graph6.png</figcaption></figure><h2 id="代码">代码</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x,<span class="hljs-keyword">int</span> *y)</span></span>&#123;       <span class="hljs-comment">// 交换代码</span><br><span class="hljs-keyword">int</span> tmp = *x;<br>*x = *y;<br>*y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;            <span class="hljs-comment">// 对于 start到end的堆，从顶上开始往下去让整个堆符合最大堆的性质</span><br><span class="hljs-keyword">int</span> dad = start;<br><span class="hljs-keyword">int</span> son =  dad * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(son &lt;= end)&#123;      <span class="hljs-comment">// 如何儿子没有超过范围，也就是这个父节点有儿子的话</span><br><span class="hljs-keyword">if</span>(son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; a[son] &lt; a[son+<span class="hljs-number">1</span>])     <span class="hljs-comment">//两个儿子比较</span><br>son ++;<br><span class="hljs-keyword">if</span>(a[dad] &gt; a[son]) <span class="hljs-comment">// 儿子与父节点比较</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span>&#123;       <span class="hljs-comment">// 如果不符合最大堆的性质，则交换父节点与子节点</span><br>swap(&amp;a[dad],&amp;a[son]);<br>dad = son;<br>son = dad * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">()</span>     <span class="hljs-comment">// 真正的堆排序</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>max_heapify(i,n);       <span class="hljs-comment">// 第一次完整的堆排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>swap(&amp;a[<span class="hljs-number">1</span>],&amp;a[i]);      <span class="hljs-comment">// 将父节点下放</span><br>max_heapify(<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);     <span class="hljs-comment">// 注意是 i-1</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稳定匹配(stable Matching)问题</title>
    <link href="/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/"/>
    <url>/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学 UCBCS70时，有一个note专门讲了这问题————稳定匹配问题，用了两天时间稍微理解了一些些。</p><h1 id="稳定匹配问题">稳定匹配问题</h1><h2id="提议与拒绝算法the-propose-and-reject-algorithm">提议与拒绝算法(ThePropose-and-Reject Algorithm)</h2><p>Note 上就是这么命名的，也称盖尔-沙普利算法(Gale–Shapleyalgorithm)。</p><ol type="1"><li>每个职位（男士）向自己优先列表中尚未拒绝的最优先候选人提出邀请。</li><li>每位候选人（女士）收集所有在这一次收到的邀请，对于她最喜欢的邀请，他回应“可以”，对于其他排名的邀请，她直接拒绝这些提议。</li><li>每个被拒绝的职位将拒绝的候选人从其列表中划掉</li></ol><p>上述循环每天重复，直到没有邀请被拒绝。</p><h2 id="提议与拒绝算法的性质">提议与拒绝算法的性质</h2><ul><li>这个算法总是会停止。</li></ul><p>证明：论证很简单：在算法未停止的每一天，至少有一个职位必须从其列表中删除一些候选人（否则算法的停止条件将会被触发）。由于每个列表有<span class="math inline">\(n\)</span> 个元素，而总共有 <spanclass="math inline">\(n\)</span> 个列表，这意味着算法最多在 <spanclass="math inline">\(n^2\)</span> 次迭代（天）后终止。</p><h3 id="稳定性">稳定性</h3><p>一个好的匹配应该具有什么性质？或许我们希望最大化首选的数量？或者，我们可以最小化最后选择的数量。或者理想情况下，我们可以最小化选择排名的总和，这可以被视为最大化平均幸福感。</p><p>在本讲中，我们将专注于一个更基本的标准，这个标准根植于自主性的理念，即<strong>稳定性</strong>。如果存在一个职位（男士）和一个候选人（女士），他们都希望与对方合作，而不是与他们当前的匹配对象合作，那么这个匹配就是<strong>不稳定的</strong>。我们将这样的配对称为<strong>不和谐对</strong>。因此，n个职位与 n 个候选人的匹配是稳定的，如果它没有不和谐对。</p><p>在讨论如何找到一个稳定的匹配之前，让我们先问一个更基本的问题：<strong>稳定的匹配总是存在吗？</strong>答案显然是肯定的。对于任何不稳定的匹配，从上面的不稳定的定义来看，总可以找到一个其他的人，来拆散当前的匹配对象。</p><h3 id="分析稳定性">分析稳定性</h3><ul><li><strong>引理1：</strong> 如果职位 <spanclass="math inline">\(J\)</span> 在第 <spanclass="math inline">\(k\)</span> 天向候选人 <spanclass="math inline">\(C\)</span> 提出提议，那么在随后的每一天 <spanclass="math inline">\(C\)</span> 都会收到一个她至少和 <spanclass="math inline">\(J\)</span>一样喜欢的职位提议（即“在手中的”职位）。</li></ul><p>证明不证了，看了大概，只能看懂，开了一个坑，等后面这个课结束了在来填。</p><ul><li><p><strong>引理2：</strong>提议与拒绝算法总是终止于一个匹配。</p></li><li><p><strong>定理1：</strong> 该算法生成的匹配总是稳定的。</p></li></ul><p>证明：这次我们从职位的角度来证明稳定性，我们直接证明在算法生成的匹配中，没有职位会涉及不和谐对。考虑最终匹配中的任何一对<span class="math inline">\((J, C)\)</span>，假设 <spanclass="math inline">\(J\)</span> 更喜欢某个候选人 <spanclass="math inline">\(C_{*}\)</span> 而不是<spanclass="math inline">\(C\)</span>。我们将论证 <spanclass="math inline">\(C_{*}\)</span> 更喜欢她的职位而不是 <spanclass="math inline">\(J\)</span>，因此 <span class="math inline">\((J,C_*)\)</span>不能构成不和谐对。由于 <spanclass="math inline">\(C_*\)</span> 在 <spanclass="math inline">\(J\)</span> 的列表中比 <spanclass="math inline">\(C\)</span> 靠前，<spanclass="math inline">\(J\)</span> 必然在向C提出提议之前先向 <spanclass="math inline">\(C_*\)</span> 提出了提议。因此，根据改善引理，<spanclass="math inline">\(C_*\)</span> 至少和 <spanclass="math inline">\(J\)</span>一样喜欢她最终获得的职位，因此更喜欢她的职位而不是 <spanclass="math inline">\(J\)</span>。因此，没有职位会涉及不和谐对，匹配是稳定的。</p><p>上面我们证明了这个算法总会存在稳定的匹配。但是在现实生活中不会仅仅追求这个，还要追求最好，那么最优性应运而生。</p><ul><li><strong>定义1 （职位的最佳候选人）</strong>对于给定职位J，J的最佳候选人是所有稳定匹配中J可以配对的最高排名<em>候选人</em>（注意候选人是双方都看得上的）。</li><li><strong>定义4.3 （候选人的最佳职位）</strong>对于给定候选人C，C的最佳职位是所有稳定匹配中C可以配对的最高排名的职位。</li></ul><p><strong>定理2：</strong>提议与拒绝算法输出的匹配总是对于一方最优的。</p><p>假设不是对于一方最优的，我们先举个栗子，可能不是对雇主最优的。那么，在某一天(第k 天)，J 被他的最佳候选人 C 拒绝，C 选择了 K的位置，那么根据最佳候选人的定义，必然存在一个稳定匹配，其中 J 与 T配对，那么这个稳定匹配为 <span class="math inline">\(\{\dotsc \{J,T\},\{C,K\} \dotsc\}\)</span>。</p><p>下面来证明(T,K) 是不和谐对。按照上面的逻辑，T更喜欢K而不是J。由于第 k天是某个职位第一次被其最佳候选人拒绝的日子，在第k天之前，职位 T没有被其最佳候选人拒绝过。由于 T 在第 k 天向 K 提出了提议，这表明 T至少和它的最佳候选人一样喜欢C*，因此至少和它在稳定匹配T中的配对 K一样喜欢T。因此，(T,K)在匹配中形成了一个不和谐对，所以匹配中不是稳定的。</p><h2 id="相关代码">相关代码</h2><p>就是很经典的题目，男士与女士结婚配对。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stable_Marriage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始话女士与男士的对象</span><br><span class="hljs-built_in">memset</span>(man,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(man));<br><span class="hljs-built_in">memset</span>(woman,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(woman));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)rank[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 开始匹配</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!man[i])&#123;    <span class="hljs-comment">// 如果男士不是单身狗</span><br><span class="hljs-keyword">int</span> g = men[i][rank[i] ++];     <span class="hljs-comment">// 向没有被拒绝的女士发出邀请</span><br><span class="hljs-keyword">if</span>(!woman[g])&#123; <br>                    <span class="hljs-comment">// 如果女士也没有对象</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>                <span class="hljs-comment">// 如果有了，判断现在的男士提出的申请是否比原来的对象，如果好。就换一个</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sc_woman[g][i] &lt; sc_woman[g][woman[g]])&#123;<br>man[woman[g]] = <span class="hljs-number">0</span>;  <br>                    <span class="hljs-comment">// 把原来的甩了</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>sign = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 如果所有的男士都有对象，那么这个匹配已经OK了</span><br><span class="hljs-keyword">if</span>(!sign)<span class="hljs-keyword">break</span>;<br>&#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,woman[man[i]],man[i]);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Stable Matching</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCB CS70: discrete Math and probability theory</title>
    <link href="/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/"/>
    <url>/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="集合的复习以及数学标记">集合的复习以及数学标记</h2><h3 id="集合">集合</h3><p>集合可以包含任何东西，包括集合，任何元素。如过元素 <spanclass="math inline">\(x\)</span> 在集合 <spanclass="math inline">\(A\)</span> 中，那么记作 <spanclass="math inline">\(x \in A\)</span>。如果 <spanclass="math inline">\(y\)</span> 不属于 <spanclass="math inline">\(A\)</span> 中，那么记作 <spanclass="math inline">\(y \notin A\)</span>。</p><p>集合的基本属性：</p><ul><li>集合中不存在顺序</li><li>如果<span class="math inline">\(A,B\)</span>两个集合相等，那么记作<span class="math inline">\(A = B\)</span><br /></li></ul><h3 id="基数cardinality">基数(Cardinality)</h3><p>集合中的元素的个数，记作基数，比如 <span class="math inline">\(A =\{1,2,2,4\}\)</span>，基数为 4，记作 <span class="math inline">\(\midA\mid=4\)</span>.</p><p>如果基数为0，那么被称为空集，记作 <spanclass="math inline">\(\emptyset\)</span>。</p><h3 id="集合的基本运算">集合的基本运算</h3><h4 id="并运算">并运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 中的所有元素汇集而成的集合称为集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 的 并。记作 <spanclass="math inline">\(A \cup B\)</span>。即：</p><p><span class="math inline">\(A \cup B = \{x \mid x\in A \vee x \inB\}\)</span></p><p>基本推理：</p><ul><li><span class="math inline">\(A \cup B = B \cup A\)</span></li><li><span class="math inline">\(A \cup \emptyset = A\)</span></li></ul><h4 id="交运算">交运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 中的公共元素汇集而成的集合称为集合<span class="math inline">\(A\)</span> 和集合 <spanclass="math inline">\(B\)</span> 的 并。记作 <spanclass="math inline">\(A \cap B\)</span>。即：</p><p><span class="math inline">\(A \cap B=\{x \mid x\in A \wedge x \inB\}\)</span></p><p>基本推论： * <span class="math inline">\(A \cap B = B \cap A\)</span>* <span class="math inline">\(A \cap \emptyset = \emptyset\)</span></p><h4 id="差运算">差运算</h4><p>设 <span class="math inline">\(A,B\)</span> 为两个集合，则由属于集合<span class="math inline">\(A\)</span> 但不属于集合 <spanclass="math inline">\(B\)</span> 的所有元素汇集的集合称为集合 <spanclass="math inline">\(A\)</span> 与集合 <spanclass="math inline">\(B\)</span> 的差。记作 <spanclass="math inline">\(A\backslash B\)</span> 或 <spanclass="math inline">\(A − B\)</span>。即：</p><p><span class="math inline">\(A\backslash B= \{x \in A \mid x \notinB\}\)</span></p><p>基本推论： * <span class="math inline">\(A \backslash B =\emptyset\)</span> * <span class="math inline">\(A \backslash \emptyset= A\)</span> * <span class="math inline">\(\emptyset \backslash A =\emptyset\)</span></p><h3 id="基本集合标记">基本集合标记</h3><ul><li><span class="math inline">\(\mathbb{N}\)</span>表示所有自然数的数集</li><li><span class="math inline">\(\mathbb{Z}\)</span>表示所有整数的数集</li><li><span class="math inline">\(\mathbb{Q}\)</span>表示所有有理数：<span class="math inline">\(\{\frac{a}{b} \mid  a,b \in\mathbb{Z},b \neq 0\}\)</span></li><li><span class="math inline">\(\mathbb{R}\)</span> 表示所有实数集</li><li><span class="math inline">\(\mathbb{C}\)</span> 表示所有复数集</li></ul><h3 id="笛卡尔积cartesian-product">笛卡尔积（Cartesian product）</h3><p>笛卡尔积，记作 <span class="math inline">\(A \timesB\)</span>，表示两个集合中的 元素的有序对，即：</p><p><span class="math inline">\(A \times B = \{(a,b) \mid a \in A,b \inB\}\)</span></p><h3 id="幂集">幂集</h3><p>幂集，就是原集合中所有的子集（包括全集和空集）构成的集。</p><p><span class="math inline">\(S: \{T | T \subseteq S\}\)</span></p><p>举个栗子，如果 <span class="math inline">\(S = \{1,2,3\}\)</span>,<span class="math inline">\(S\)</span>的幂集: <spanclass="math inline">\(P(S) =\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\},\{1,2,3\}\}\)</span>。</p><p>如果 <span class="math inline">\(\mid S \mid = k\)</span>，那么 <spanclass="math inline">\(\mid P(S) \mid = 2^k\)</span>。</p><h2 id="命题逻辑">命题逻辑</h2><h3 id="命题">命题</h3><p>能判断对错指代清楚的叫命题。例如： * 今天会下雨 * 根号三是无理数</p><h3 id="逻辑符号">逻辑符号</h3><ol type="1"><li>合取：记作 <span class="math inline">\(q \landp\)</span>，只有两个都为真，结果才为真。</li><li>析取：记作 <span class="math inline">\(q \lorp\)</span>，两个只要有一个真，结果就为真。</li><li>否定：记作 <span class="math inline">\(\lnot p\)</span>，p的否定，非 p。</li></ol><p>永真式：表示无论变量如何，永远为真的式子。例如：<spanclass="math inline">\(P \lor \lnot Q\)</span></p><p>矛盾式：表示无论变量如何，永远为假的式子。例如：<spanclass="math inline">\(P \land \lnot Q\)</span></p><table><thead><tr><th><span class="math inline">\(P\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(P \land Q\)</span></th><th><span class="math inline">\(P \lor Q\)</span></th><th><span class="math inline">\(\lnot P\)</span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td></tr></tbody></table><ol start="4" type="1"><li><p>蕴含式：<span class="math inline">\(P \implies Q\)</span>（P 蕴含Q），若 <span class="math inline">\(P\)</span> 为真，则 <spanclass="math inline">\(Q\)</span> 为真。</p><ul><li>简单关系：<span class="math inline">\((P \implies Q) \equiv (\lnot P\lor Q)\)</span>。</li><li>如果 <span class="math inline">\(P \implies Q\)</span> 和 <spanclass="math inline">\(Q \implies P\)</span> 都为真，记作 <spanclass="math inline">\(P \iff Q\)</span>，等价号。</li></ul></li></ol><p>已知 <span class="math inline">\(P \impliesQ\)</span>，我们可以定义： * 逆否命题为真：<spanclass="math inline">\(\lnot Q \implies \lnot P\)</span> * 逆命题：<spanclass="math inline">\(Q \implies P\)</span></p><table style="width:100%;"><colgroup><col style="width: 3%" /><col style="width: 3%" /><col style="width: 10%" /><col style="width: 10%" /><col style="width: 15%" /><col style="width: 15%" /><col style="width: 29%" /><col style="width: 12%" /></colgroup><thead><tr><th><span class="math inline">\(P\)</span></th><th><span class="math inline">\(Q\)</span></th><th><span class="math inline">\(\lnot P\)</span></th><th><span class="math inline">\(\lnot Q\)</span></th><th><span class="math inline">\(P \implies Q\)</span></th><th><span class="math inline">\(Q \implies P\)</span></th><th><span class="math inline">\(\lnot Q \implies \lnot P\)</span></th><th><span class="math inline">\(P \iff Q\)</span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table><h3 id="量词">量词</h3><p>全称量词：全称量词表示命题对所有元素都成立，通常用符号 <spanclass="math inline">\(\forall\)</span> 表示。</p><p>存在量词：存在量词表示命题对至少一个元素成立，通常用符号 <spanclass="math inline">\(\exists\)</span> 表示。</p><p>我们从高中用到大学，不再赘述了。</p><h3 id="处理否定的一些定律">处理否定的一些定律</h3><h4 id="德摩根定律">德摩根定律</h4><p><span class="math display">\[\lnot (P \land Q) \equiv (\lnot P \lor\lnot Q)\]</span> <span class="math display">\[\lnot (P \lor Q) \equiv(\lnot P \land \lnot Q)\]</span></p><h4 id="有关量词的一些定律">有关量词的一些定律</h4><p><span class="math inline">\(\lnot (\forall x P(x))\equiv \exists x\lnot P(x)\)</span></p><p><span class="math inline">\(\lnot (\exists x P(x))\equiv \forall x\lnot P(x)\)</span></p><p>下面还有更复杂一些的：</p><p><span class="math display">\[\lnot (\forall x \exists y P(x,y))\equiv \exists x \lnot(\exists y P(x,y))\equiv \exists x \forall y \lnot P(x,y)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Discrete mathematics</category>
      
      <category>CS70</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Discrete mathematics</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50笔记（查漏补缺）</title>
    <link href="/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/"/>
    <url>/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准备一个暑假在跑外卖的时候干点有用的事，就从学习CS50开始吧，正好学点自己不知道到的知识。</p><p><strong>2024-07-17~2024-08-17</strong>结束正好用时一个月，也终于结束了，因为不是零基础，所以有些课程跳了，有的太简单了，还是挺有感慨的，以前发现自己编程同龄人无敌，现在才发现任重道远，开学后要好好学学指针。</p><h2 id="并归排序">并归排序</h2><p>还是基础功不太扎实，连这个都不知道。</p><p>归并排序基于分治思想将数组分段排序后合并，主要思想是将两个<strong>已经排好序</strong>的数合并在一起。</p><ol type="1"><li><p>注意：这个算法必须申请<strong>至少两倍空间</strong>，首先，设定两个指针，这两个指针在两个已经排好的数组的起始位置。</p></li><li><p>合并：从左向右，枚举两个数组<code>a[i]</code>和<code>b[i]</code>，找出最小的数放入新数组，直到有一个数组为空时，把另一个数组的剩下的元素放入新数组。</p></li><li><p>分治：如果数组长度为1，该数组就是有序的，不用排序。如果数组长度大于1，此时应将该数组分为两段，等分成左边和右边，检查有无序，无序重复此操作，左边有序后检查右边，两变边都有序了，合并（见2操作）。</p></li></ol><p>给一张动图吧，好理解一些，网上的：<imgsrc="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif"alt="sort" /></p><h2 id="c-标准库-string.h">C 标准库 &lt;string.h&gt;</h2><h3 id="strcmp">strcmp()</h3><p><code>int strcmp(const char *str1, const char *str2)</code></p><p>str1 ------ 要进行比较的第一个字符串</p><p>str2 ------ 要进行比较的第二个字符串</p><p>返回值如下： * 如果返回值小于 0，则表示 str1 小于 str2。 *如果返回值大于 0，则表示 str1 大于 str2。 * 如果返回值等于 0，则表示str1 等于 str2。</p><h3 id="strcpy">strcpy()</h3><p><code>char *strcpy(char *dest, const char *src)</code></p><p>dest -- 指向用于存储复制内容的目标数组。<br />src -- 要复制的字符串。</p><h2 id="c-标准库-stdlib.h">C 标准库 &lt;stdlib.h&gt;</h2><h3 id="malloc">malloc()</h3><p>C 库函数 <code>void *malloc(size_t size)</code>分配所需的内存空间，并返回一个指向它的指针。</p><p><code>void *malloc(size_t size)</code></p><p>size -- 内存块的大小，以字节为单位。</p><h3 id="free">free()</h3><p>C 库函数 <code>void free(void *ptr)</code> 释放之前调用calloc、malloc 或 realloc 所分配的内存空间。</p><p><code>void free(void *ptr)</code></p><p>ptr -- 指针指向一个要释放内存的内存块，该内存块之前是通过调用malloc、calloc 或 realloc进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。</p><p>C 标准库 &lt;stdio.h&gt;</p><h3 id="文件操作">文件操作</h3><h4 id="fopen">fopen()</h4><p>可以使用 fopen()函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE的一个对象，类型 FILE包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><p><code>FILE *fopen( const char *filename, const char *mode );</code></p><p>filename ----- 字符串，用来命名文件。</p><p>mode --------- 访问模式，有下面几种格式：</p><table><colgroup><col style="width: 9%" /><col style="width: 90%" /></colgroup><thead><tr><th><strong>模式</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件。</td></tr><tr><td>w</td><td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td>a</td><td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件。</td></tr><tr><td>w+</td><td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td>a+</td><td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><h4 id="fclose">fclose()</h4><p>为了关闭文件，请使用 fclose() 函数。函数的原型如下：</p><p><code>int fclose( FILE *fp );</code></p><p>如果成功关闭文件，fclose()函数返回零，如果关闭文件时发生错误，函数返回 EOF。</p><h4 id="fprintf">fprintf()</h4><p>函数 fprintf()函数根据指定的格式发送信息到由stream（流）指定的文件。因此 fprintf()可以使得信息输出到指定的文件。</p><p><code>int fprintf( FILE *stream, const char *format, ... );</code></p><p>第一个参数是文件指针，第二个和后面都和printf()一样的。将内容输出到字符串中。</p><h4 id="fread">fread()</h4><p>C 库函数 size_t fread(void <em>ptr, size_t size, size_t nmemb, FILE</em>stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</p><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code></p><p>参数：</p><ul><li>ptr -- 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。</li><li>size -- 这是要读取的每个元素的大小，以字节为单位。</li><li>nmemb -- 这是元素的个数，每个元素的大小为 size 字节。</li><li>stream -- 这是指向 FILE 对象的指针，该 FILE对象指定了一个输入流。</li></ul><h2 id="sql">SQL</h2><h3 id="select">SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>column1, column2,...</strong>：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</p></li><li><p><strong>table_name</strong>：要查询的表名称。</p></li><li><p>注意：在 <code>SELECT</code> 后在加 <code>DISTINCT</code>可以去重</p></li></ul><h3 id="where">WHERE</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></div></td></tr></table></figure><p>WHERE 相当于 if ，<code>condition</code> 是条件。</p><h4 id="order-by">ORDER BY</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>column1, column2,...</strong>：要排序的字段名称，可以为多个字段。</li><li><strong>ASC</strong>：表示按升序排序。</li><li><strong>DESC</strong>：表示按降序排序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS50</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>SQL</tag>
      
      <tag>Python</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 库 Matplotlib 学习</title>
    <link href="/2024/05/22/Python%E5%BA%93Matplotlib%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/05/22/Python%E5%BA%93Matplotlib%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在数学建模选拔赛中需要写一点画个图，秉承着需要啥就学啥的原则，来学一点Python中的强大的库</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>画图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 学习（长期）</title>
    <link href="/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/"/>
    <url>/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="git">Git</h1><h2 id="背景">背景</h2><p>最经换电脑了，电脑里的东西全得转移，真的麻烦，搞这个博客就花了好长时间来git，借此机会想来学习一下 git 相关知识，慢慢学。</p><h2 id="版本控制系统">版本控制系统</h2><ol type="1"><li><p>集中式版本控制系统：</p><p>集中式的版本控制系统，所有的版本库是放在中央服务器中的，也就是说我们每一次的修改上传都是保存在中央服务器中的。中央服务器就是个大仓库，大家把产品都堆里面，每一次需要改进和完善的时候，需要去仓库里面把文件给提出来，然后再操作。</p><p>但是有缺点，如果主服务器出现了问题，所有人就无法上传或下载，而且会有延迟，可能下载下来的版本不是最新的。</p></li><li><p>分布式版本控制系统：分布的含义不是说每台计算机上只留有版本库的一部分。恰恰相反，分布的含义是每台计算机上都还有一个完整的版本库。这个时候，你的修改仅仅需要提交给本地的版本库进行保存就可以了。</p><p>而 Git 就是一个优秀分布式版本控制系统。</p></li></ol><h2 id="新建仓库">新建仓库</h2><p>一共有两种，第一种就是直接在自己本地电脑上新建一个，第二种就是从远程服务器克隆一个仓库。</p><p>方式一：<code>git init</code></p><p>方式二：<code>git clone</code></p><p>不管是哪样，都会在本地文件夹中生成一个 <code>.git</code>目录，这个目录中存放着许多有关git信息的重要文件。</p><p>...... 未完待续</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 学习 1</title>
    <link href="/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="linux-文件权限学习">Linux 文件权限学习</h1><h2 id="用户与用户组">用户与用户组</h2><ol type="1"><li><p>文件拥有者(root)</p></li><li><p>一般用户组</p></li><li><p>其他人</p></li></ol><h2 id="文件权限">文件权限</h2><p>在终端输入 <code>ls -al</code>后，就会出现一堆东西，其中在每一行的前面的是文件的权限，共有10个字符，</p><ul><li><p>第一个字符代表这个文件是目录、文件或链接文件。</p><ul><li><p><code>d</code> 则是目录</p></li><li><p><code>-</code> 则是文件</p></li><li><p><code>l</code> 则是链接文件</p></li></ul></li><li><p>接下来三个为一组，共三组；其中 <code>r</code>表示可读，<code>w</code> 表示可写，<code>x</code> 表示可执行</p><ul><li><p>第一组 <strong>文件拥有者(root)</strong> 可具备的权限</p></li><li><p>第二组 <strong>一般用户</strong> 的权限</p></li><li><p>第三组 <strong>没有加入本用户组的其他账号</strong>的权限</p></li></ul></li></ul><h2 id="修改文件属性">修改文件属性</h2><ul><li><p><code>chgrp</code></p><ul><li><p>修改文件所属用户组</p></li><li><p>参数 <code>-R</code> ：进行递归修改</p></li><li><p>语法：<code>chgrp [-R][user] dir/file</code></p></li></ul></li><li><p><code>chown</code></p><ul><li><p>修改文件拥有者</p></li><li><p>语法：<code>chown [-R] [owner][:group] file</code></p></li></ul></li><li><p><code>chmod</code></p><ul><li><p>修改权限</p></li><li><p>数字类型修改权限：<code>r=4,w=2,x=1</code>，每种身份的的权限需要累加的，例如<code>owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=0+0+0=0</code>，所以权限数字是770，</p></li><li><p>符号类型修改权限：身份<code>u=user,g=group,o=others</code>，<code>+(加入),-(移除),=(设置)</code></p></li><li><p>语法：<code>chmod [-R] [xyz] file/dir</code> 或者<code>chmod [ugo...][[+-=][rwxX]] file/dir</code></p></li></ul></li></ul><h2 id="目录与文件的权限意义">目录与文件的权限意义</h2><h3 id="权限对文件的重要性">权限对文件的重要性</h3><ul><li><p>r(read)：可读取此文件的实际内容</p></li><li><p>w(write)：可以编辑，修改此文件的内容</p></li><li><p>x(execute)：该文件具有被系统执行的权限</p></li></ul><p>注意，文件是否能被执行，与文件名后缀无关，与 x 权限有关，记得与Windows 区分开</p><p>有 w 权限，但并不具备有删除文件本身的权限</p><h3 id="权限对目录的重要性">权限对目录的重要性</h3><ul><li><p>r：具有读取目录结构的权限</p></li><li><p>w：改动该目录结构列表的权限</p></li><li><p>x：用户能否进入该目录成为工作目录（目前所在的目录）</p></li></ul><p>开放目录给任何人看时，应该至少给予 r 或 x 的权限。</p><p>先这样吧，有时间在来整理。</p>]]></content>
    
    
    <categories>
      
      <category>学习随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python opencv 缩放图像</title>
    <link href="/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>突发奇想来用 Python 来缩放图像，搜到可以用 opencv来实现功能，就稍微了解一下，当然 opencv 的功能不只这些。</p><p><strong>注意</strong>：此处所有 <code>cv</code> 在实际写时改成<code>cv2</code> 或者在导入库时加入一句<code>import cv2 as cv</code></p><h2 id="基本功能">基本功能</h2><h3 id="读取图像">读取图像</h3><p>可以用 <code>cv.imread()</code>来读取图像，一共有两个参数，第一个提供图片所在目录，第二个是一个标志，表示读取的方式：</p><ul><li><p>cv.IMREAD_COLOR ：加载彩色图像，默认</p></li><li><p>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</p></li><li><p>cv.IMREAD_UNCHANGED：加载图像</p></li></ul><p><strong>注意</strong>：即使图像路径错误，它也不会引发任何错误，但是<code>print img</code> 会给出 <code>None</code></p><h3 id="显示图像">显示图像</h3><p>使用函数 <code>cv.imshow()</code>在窗口上显示图像，窗口自动适合图像尺寸。</p><p>第一个参数是字符串，表示窗口名，第二个参数是我们需要显示的图片的参数。</p><p>一般配合以下函数使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">cv.imshow(<span class="hljs-string">&#x27;img&#x27;</span>,img)<br>cv.waitKey(<span class="hljs-number">0</span>)<br>cv.destoryAllWindows()<br></code></pre></div></td></tr></table></figure><p><code>cv.waitKey()</code>是一个控制键盘的函数。其参数是以毫秒为单位的时间。如果您在这段时间内按下任何键，程序将继续运行。如果<code>0</code> 被传递，它将无限期地等待一次敲击键。</p><h3 id="写入图像">写入图像</h3><p>使用 <code>cv.imwrite()</code>保存图像，第一个参数是文件名，第二个参数是要保存的图像。</p><h3 id="缩放">缩放</h3><p>使用函数 <code>cv.resize()</code>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">resize(src, dsize, dst=<span class="hljs-literal">None</span>, fx=<span class="hljs-literal">None</span>, fy=<span class="hljs-literal">None</span>, interpolation=<span class="hljs-literal">None</span>)<br></code></pre></div></td></tr></table></figure><p><code>scr</code>：是需要缩放的图片的对象</p><p><code>dsize</code>：目标图像大小。当 dsize 为 0时，通过以下公式计算得出：</p><ul><li><code>disize = Size(round(fx*scr.cols) , round(fy*src.rows))</code></li></ul><p>所以 <code>disze</code> 与 <code>(fx , fy)</code> 不能同时为 0</p><p><code>fx,fy</code>：水平和垂直轴的比例因子。当它为零时，计算公式如下：<code>(double)dsize.width/src.cols</code>和 <code>(double)dsize.width/src.cols</code></p><p><code>interpolation</code> ：插值方法，具体我也不太懂，最好使用<code>cv.INTER_LINEAR</code> 参数</p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Distant-Skys</span><br><span class="hljs-comment"># To make a picture smaller or bigger.</span><br><br><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>image = cv.imread(<span class="hljs-string">&#x27;1.jpg&#x27;</span>)<br><br>res = cv.resize(image,<span class="hljs-literal">None</span>,fx=<span class="hljs-number">0.7</span>,fy=<span class="hljs-number">0.7</span>,interpolation=cv.INTER_CUBIC)<br><span class="hljs-comment"># if want to make picture bigger ,let ((fx and fy) &gt; 1).</span><br><br><span class="hljs-comment"># print the result picture.</span><br><span class="hljs-comment"># cv.imshow(&#x27;result image&#x27;,res)</span><br><span class="hljs-comment"># cv.waitKey(0)</span><br><span class="hljs-comment"># cv.destroyAllWindows()</span><br><br>cv.imwrite(<span class="hljs-string">&#x27;1_result.jpg&#x27;</span>,res)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习笔记</title>
    <link href="/2022/01/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java-学习">Java 学习</h1><ul><li><p>Java 的<strong>基本</strong>模板：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">// Do somethings;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>Java 的输入不是像 c++一样有简单的函数，而是先要创建一个输入类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Scanner cin = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></div></td></tr></table></figure><p>读入的话，可以使用其中的方法：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">n = cin.next();<br><span class="hljs-comment">// 可以读到下一个空格之前</span><br>n = cin.nextLine();<br><span class="hljs-comment">// 可以读一整行</span><br></code></pre></div></td></tr></table></figure><p><strong>注意</strong>：<code>cin.next()</code>不能读带有空格的字符串，<code>cin.nextLine()</code>可以读带有空格的字符串，也可以获得空白。</p><p>当然，int 和 float 有 <code>nextInt()</code> <code>nextFloat()</code>。读入之前最好用 <code>hasNextInt()</code> <code>hasNextFloat()</code> 来验证。</p></li><li><p>Java 的输出较为简单：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">System.out.println(n);    <span class="hljs-comment">// 输出完换行</span><br>System.out.print(n);    <span class="hljs-comment">// 输出完不换行</span><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC235E-MST+1题解</title>
    <link href="/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="abc235e-mst1-题解">ABC235E MST+1 题解</h1><h2 id="题目大意">题目大意</h2><p>给你一个图 <span class="math inline">\(G\)</span> 含有 <spanclass="math inline">\(n\)</span> 个顶点和 <spanclass="math inline">\(m\)</span> 条边，给出 <spanclass="math inline">\(Q\)</span> 次询问，询问所多输入的边加上原图 <spanclass="math inline">\(G\)</span> 的最小生成树是否是存在 <spanclass="math inline">\(e_i\)</span>，存在输出 <code>Yes</code> 不存在输出<code>No</code>。</p><h2 id="思路">思路</h2><p>首先我们可以想到用最简单的方法，在每次询问时都做一次 Kruskal算法，如果这个边被取到了，那么输出<code>Yes</code>，反之亦然。时间复杂度为 <spanclass="math inline">\(\mathcal{O}(Q \times n  \logn)\)</span>，太慢。</p><p>因为每个询问是相互独立的，而且询问的边 <spanclass="math inline">\(e_i\)</span> 对于 并查集的不会产生影响，所以可以想到只用一次 Kruskal算法，把所有的边都涵盖上。</p><p>在遍历时每条边的处理方法：</p><ul><li><p>如果是询问的 <span class="math inline">\(e_i\)</span> 的边</p><ul><li><p>如果 <span class="math inline">\(e_i\)</span> 的所连的两个顶点<span class="math inline">\(u,v\)</span> 没有连通，则标记为<code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是询问的 <span class="math inline">\(e_i\)</span> 的边</p><ul><li><p>如果 <span class="math inline">\(e_i\)</span> 的所连的两个顶点<span class="math inline">\(u,v\)</span> 没有连通，则标记为<code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是 <span class="math inline">\(G\)</span> 的边        </p><ul><li>将两个顶点在并查集内合并</li></ul></li></ul><p>时间复杂度 <span class="math inline">\(\mathcal{O}((n+Q) \log (n +Q))\)</span>。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200005</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w,Is,num;&#125;;<br><span class="hljs-keyword">int</span> fa[maxn];<br>Edge e[maxn*<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> ans[maxn];<br><span class="hljs-keyword">int</span> n,m,q;<br>vector&lt;Edge&gt; qe;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-keyword">const</span> Edge &amp;a,<span class="hljs-keyword">const</span> Edge &amp;b)&#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (a.u == b.u &amp;&amp; a.v == b.v &amp;&amp; a.w == b.w);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">found</span>(fa[x]);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x,Edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w &lt; y.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init_Onion</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)    fa[x] = x;<br>    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>        e[i].Is = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[m+i].u,&amp;e[m+i].v,&amp;e[m+i].w);<br>        e[m+i].Is = <span class="hljs-number">1</span>;e[m+i].num = i;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+q+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-built_in">Init_Onion</span>();<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m+q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(e[i].Is == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(e[i].v) != <span class="hljs-built_in">found</span>(e[i].u))<br>                ans[e[i].num] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> u = e[i].u,v = e[i].v;<br>        <span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(u),t = <span class="hljs-built_in">found</span>(v);<br>        fa[t] = f;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);#<span class="hljs-number">191B</span>1C<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATCoder ABC 001</title>
    <link href="/2021/11/06/ATCoder-ABC-001/"/>
    <url>/2021/11/06/ATCoder-ABC-001/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="atcoder-abc-001">ATCoder ABC 001</h1><p><a href="https://atcoder.jp/contests/abc001/tasks">题目链接</a></p><h2 id="a-题">A 题</h2><p>太简单了，不放代码了。</p><h2 id="b-题">B 题</h2><p>其实，就是模拟，只是需要注意边界问题，是一个左开右闭的区间。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; m &lt;= <span class="hljs-number">5000</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1000</span>)<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">5000</span> &amp;&amp; m &lt;= <span class="hljs-number">30000</span>)<br>        cout &lt;&lt; m / <span class="hljs-number">1000</span> + <span class="hljs-number">50</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">30000</span> &amp;&amp; m &lt;= <span class="hljs-number">70000</span>)<br>        cout &lt;&lt; (m / <span class="hljs-number">1000</span> - <span class="hljs-number">30</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">80</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-number">89</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="c-题">C 题</h2><p>同样是模拟，只是 <code>else if</code>的数量有点多，注意边界，同上。</p><p>这道题目需要求一个保留两位小数的浮点数，所以需要自己手写函数<code>Around</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Around</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k)*x+<span class="hljs-number">0.5</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k);<br>    <span class="hljs-comment">// 保留两位小数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">int</span> cmp,meter;<span class="hljs-keyword">double</span> speed,sid;<br>    cin&gt;&gt;sid&gt;&gt;meter;<br>    speed = meter / <span class="hljs-number">60.0</span>;<br>    speed = <span class="hljs-built_in">Around</span>(speed,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">112.5</span> &amp;&amp; sid &lt;= <span class="hljs-number">337.5</span>)        s = <span class="hljs-string">&quot;NNE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">337.5</span> &amp;&amp; sid &lt; <span class="hljs-number">562.5</span>)    s = <span class="hljs-string">&quot;NE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">562.5</span> &amp;&amp; sid &lt; <span class="hljs-number">787.5</span>)    s = <span class="hljs-string">&quot;ENE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">787.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1012.5</span>)    s = <span class="hljs-string">&quot;E&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1012.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1237.5</span>)    s = <span class="hljs-string">&quot;ESE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1237.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1462.5</span>)    s = <span class="hljs-string">&quot;SE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1462.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1687.5</span>)    s = <span class="hljs-string">&quot;SSE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1687.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1912.5</span>)    s = <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1912.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2137.5</span>)    s = <span class="hljs-string">&quot;SSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2137.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2362.5</span>)    s = <span class="hljs-string">&quot;SW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2362.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2587.5</span>)    s = <span class="hljs-string">&quot;WSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2587.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2812.5</span>)    s = <span class="hljs-string">&quot;W&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2812.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3037.5</span>)    s = <span class="hljs-string">&quot;WNW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3037.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3262.5</span>)    s = <span class="hljs-string">&quot;NW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3262.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3487.5</span>)    s = <span class="hljs-string">&quot;NNW&quot;</span>;<br>    <span class="hljs-keyword">else</span>    s = <span class="hljs-string">&quot;N&quot;</span>;<br><br>    <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">0.2</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C 0\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.3</span> &amp;&amp; speed &lt;= <span class="hljs-number">1.5</span>)    cmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">1.6</span> &amp;&amp; speed &lt;= <span class="hljs-number">3.3</span>)    cmp = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">3.4</span> &amp;&amp; speed &lt;= <span class="hljs-number">5.4</span>)    cmp = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">5.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">7.9</span>)    cmp = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">8.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">10.7</span>)    cmp = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">10.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">13.8</span>)    cmp = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">13.9</span> &amp;&amp; speed &lt;= <span class="hljs-number">17.1</span>)    cmp = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">17.2</span> &amp;&amp; speed &lt;= <span class="hljs-number">20.7</span>)    cmp = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">20.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">24.4</span>)    cmp = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">24.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">28.4</span>)    cmp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">28.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">32.6</span>)    cmp = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">else</span>    cmp = <span class="hljs-number">12</span>;<br><br><br>    cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cmp&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="d-题">D 题</h2><p>比较简单的思维题。</p><p>输入时，注意时间为 5 分钟为增量舍入时间，观察题目发现时间总是从 <spanclass="math inline">\(0000 \Rightarrow9999\)</span>。所以可以想到开一个桶，第 <spanclass="math inline">\(i\)</span> 个桶表示第 <spanclass="math inline">\(i\)</span>个时间是否有雨。最后重新遍历一次桶，记录下开始和结束的节点并输入。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">110000</span>;<br><span class="hljs-keyword">int</span> g[maxn];<br><span class="hljs-keyword">int</span> t;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;x,&amp;y);<br>        x -= (x%<span class="hljs-number">5</span>);y += (<span class="hljs-number">5</span> - y%<span class="hljs-number">5</span>) % <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(y%<span class="hljs-number">100</span>&gt;=<span class="hljs-number">60</span>)&#123;<br>            y+=<span class="hljs-number">100</span>;<br>            y-=<span class="hljs-number">60</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=x;j&lt;y;j++)    g[j] ++;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> on=<span class="hljs-number">0</span>,be=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">110000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[i])&#123;<br>            <span class="hljs-keyword">if</span>(!on)be=i;<br>            on=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(on)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d-%04d\n&quot;</span>,be,i);<br>            on=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ATCoder</tag>
      
      <tag>简单题</tag>
      
      <tag>模拟</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并查集">并查集</h1><figure><img src="https://z3.ax1x.com/2021/10/06/4x2h9K.png" alt="并查集" /><figcaption aria-hidden="true">并查集</figcaption></figure><p>并查集是一种树形的数据结构，可以很高效的解决一些问题。</p><h2 id="操作">操作</h2><p>有三个操作：</p><ul><li>初始化</li><li>查找</li><li>合并</li></ul><h2 id="初始化">初始化</h2><p>初始时，每个点都是自己的父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fa[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>    fa[i] = i;<br></code></pre></div></td></tr></table></figure><h3 id="查找">查找</h3><p><img src="https://z3.ax1x.com/2021/10/06/4xWYiq.png" /></p><p>上图中，想要找 <span class="math inline">\(5\)</span> 的祖先，先通过<span class="math inline">\(2-5\)</span> 这条边找到 <spanclass="math inline">\(2\)</span> ，通过同样的办法找到祖先 <spanclass="math inline">\(1\)</span>，<span class="math inline">\(1\)</span>没有祖先就得到答案了。<br />就像上面一样递归找到每个点的祖先，在返回答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == fa[x])<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并">合并</h3><p>显而易见，就是将两个集合合并。</p><figure><img src="https://z3.ax1x.com/2021/10/06/4zwqgA.png" alt="union" /><figcaption aria-hidden="true">union</figcaption></figure><p>挺简单的，就直接上代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(v);<br>    fa[u] = v;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>设操作次数为 <span class="math inline">\(m\)</span>，平均时间复杂度为<span class="math inline">\(\mathcal{O}(m \logn)\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(mn)\)</span>。</p><h2 id="优化">优化</h2><p>在上面的操作中还是不够快，所以我们想办法优化。</p><h3 id="路径压缩">路径压缩</h3><p>如果一个关系像一条链（如下图）一样，那么查找最下面的数的祖先的时间复杂度得退化到<span class="math inline">\(\mathcal{O}(n)\)</span> 。</p><figure><img src="https://z3.ax1x.com/2021/10/06/4z0LiF.png" alt="chain" /><figcaption aria-hidden="true">chain</figcaption></figure><p>这样一层一层找太浪费时间，直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。<strong>把在路径上的每个节点都直接连接到根上</strong>。</p><p><em>代码</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="启发式合并">启发式合并</h3><p>查找都优化了，那合并总不能不优化吧。</p><p>我们思考一个问题：如果一个点与一个含有 <spanclass="math inline">\(100\)</span> 个点的集合合并，是一个点合并到 <spanclass="math inline">\(100\)</span> 个点的集合快？还是 <spanclass="math inline">\(100\)</span>个点合并到一个点快？答案是显然的。<br />在题目中我们通常维护 点数 或 深度 来作为估价函数来合并</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(sz[u] &gt; sz[v])<br>        <span class="hljs-built_in">swap</span>(u，v);<br>    fa[u] = v;<br>    sz[v] += sz[u];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="优化后的时间复杂度">优化后的时间复杂度</h3><ul><li>只使用路径压缩的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m\alpha(n))\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \log n)\)</span></li><li>只使用启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \log n)\)</span>，最坏时间复杂度为<span class="math inline">\(\mathcal{O}(m \log n)\)</span>。</li><li>路径压缩 + 启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m\alpha(n))\)</span>，最坏时间复杂度为 <spanclass="math inline">\(\mathcal{O}(m \alpha(n))\)</span>。</li></ul><p>这里 <span class="math inline">\(\alpha(n)\)</span>表示阿克曼函数的反函数增长很慢，可以认为是常数(<ahref="https://oi-wiki.org/ds/dsu/#_7">具体在这</a>)。</p><h2 id="应用">应用</h2><h3 id="带权并查集">带权并查集</h3><p>我们可以在并查集上维护一些东西，比如元素和，元素个数。</p><p>比如说<a href="https://www.luogu.com.cn/problem/UVA11987">AlmostUnion-Find</a>这道题。它就是在并查集上维护一个元素和与元素个数，唯一不同的是这道题要一个虚点并查集，防止在第二个操作中下面的元素一起移动。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> fa[i] = n+i;<br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=n+n;i++)<br>fa[i] = i,sz[i] = <span class="hljs-number">1</span>,sum[i] = i-n;<br><br><span class="hljs-comment">// 第二个操作，仅仅将一个节点移动到另一个集合上。</span><br><br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(u != v)&#123;<br>fa[x] = v;<br>sz[u] --;sz[v] ++;<br>sum[u] -= x;sum[v] += x;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2021/09/18/%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/09/18/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="矩阵">矩阵</h1><h2 id="定义">定义</h2><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。</p><p>就像下面一样：</p><p><span class="math display">\[\begin{bmatrix}    1&amp;2&amp;3\\1&amp;2&amp;3\end{bmatrix}\]</span></p><p>特别的，主对角线上为 1，其余位置为 0 的叫做单位矩阵 <spanclass="math inline">\(I\)</span>：</p><p><span class="math display">\[\begin{bmatrix}    1&amp;0&amp;\cdots&amp;0\\    \vdots&amp;1&amp;\ddots&amp;0\\    0&amp;0&amp;\dots&amp;1\\\end{bmatrix}\]</span></p><h2 id="矩阵的运算">矩阵的运算</h2><p>矩阵的加减法是逐个元素进行的。</p><h3 id="乘法">乘法</h3><p>矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。</p><p>设 <span class="math inline">\(P\)</span> 为 <spanclass="math inline">\(M \times N\)</span> 的矩阵，<spanclass="math inline">\(Q\)</span> 是 <span class="math inline">\(N \timesQ\)</span> 的矩阵，<span class="math inline">\(C\)</span> 矩阵为 <spanclass="math inline">\(C = PQ\)</span>，则 <spanclass="math inline">\(C\)</span> 矩阵上 <spanclass="math inline">\(i\)</span> 行 <spanclass="math inline">\(j\)</span> 列的元素为。</p><p><span class="math display">\[c_{i,j} =\sum\limits_{k=1}^{M}P_{i,k}Q_{k,j}\]</span></p><p>没有看懂，没事，有一种<del>比较简单</del>的方法。</p><p>设 <span class="math inline">\(A\)</span> 矩阵为:</p><p><span class="math display">\[\begin{bmatrix}    a&amp;b\\    c&amp;d\\\end{bmatrix}\]</span></p><p>设 <span class="math inline">\(B\)</span> 矩阵为:</p><p><span class="math display">\[\begin{bmatrix}    e\\f\end{bmatrix}\]</span></p><p>所以 <span class="math inline">\(A\)</span> 与 <spanclass="math inline">\(B\)</span> 的乘积是：</p><p><span class="math display">\[e\begin{bmatrix}    a\\c\end{bmatrix} + f\begin{bmatrix}    b\\d\end{bmatrix}\]</span></p><p>注意，<strong>矩阵乘法满足结合律，不满足一般的交换律</strong>。</p><p>给出一个封装好的矩阵乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[N][N];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   c[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mat</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat &amp;M)&#123;<br>mat ans;<br><span class="hljs-built_in">memset</span>(ans.c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans.c);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>ans.c[i][j] += (c[i][k] * M.c[k][j]) % P,ans.c[i][j] %= P;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果算一个矩阵的 <spanclass="math inline">\(A^k\)</span>，可以使用快速幂来加速到 <spanclass="math inline">\(\mathcal{O}(n^3 \log k)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-function">mat <span class="hljs-title">qpow</span><span class="hljs-params">(mat x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    mat ans.<span class="hljs-built_in">unit</span>();<br>    <span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * x;<br>        y = y / <span class="hljs-number">2</span>;<br>        x = x * x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="矩阵的应用">矩阵的应用</h2><h3 id="快速求斐波拉契数列">快速求斐波拉契数列</h3><p>斐波拉契数列形如： <span class="math display">\[F_1 = F_2 = 1,F_i =F_{i-1} + F_{i-2}  (i  \geq 3)\]</span><br />当然可以使用递推的方法来求，时间复杂度 <spanclass="math inline">\(\mathcal{O}(n)\)</span> ，还挺快。 但是遇到<ahref="https://www.luogu.com.cn/problem/P1962">这道题目</a>就不行了，<spanclass="math inline">\(2^{63}\)</span> 绝对会TLE，所以可以用矩阵加速递推。</p><p>我们可以设 <span class="math display">\[f(n) = \begin{bmatrix}F_{n}&amp; F_{n-1}\end{bmatrix}\]</span> ，我们希望可以从 <spanclass="math inline">\(f(n-1)\)</span> 推出它。</p><p>正好我们之前学了矩阵的乘法，所以我们可以尝试设一个矩阵 <spanclass="math inline">\(\text{base}\)</span> ，使得 <spanclass="math inline">\(f(n) = \text{base} \timesf(n-1)\)</span>，也就是：</p><p><span class="math display">\[ \begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} = \text{base} \times\begin{bmatrix}F_{i-1} &amp; F_{i-2}\end{bmatrix}\]</span></p><p>因为前后都是 <span class="math inline">\(1 \times 2\)</span>的矩阵，所以可以知道 <span class="math inline">\(\text{base}\)</span>矩阵是 <span class="math inline">\(2 \times 2\)</span> 的矩阵。</p><p>所以 <span class="math inline">\(\text{base} = \begin{bmatrix}a &amp; b \\c &amp; d \\\end{bmatrix}\)</span></p><p>xxxxxxxxxx17 1# Distant-Skys2# To make a picture smaller orbigger.3​4import cv2 as cv5import numpy as np6​7image =cv.imread('1.jpg')8​9res =cv.resize(image,None,fx=0.7,fy=0.7,interpolation=cv.INTER_CUBIC)10# ifwant to make picture bigger ,let ((fx and fy) &gt; 1).11​12# print theresult picture.13# cv.imshow('result image',res)14# cv.waitKey(0)15#cv.destroyAllWindows()16​17cv.imwrite('1_result.jpg',res)python</p><p><span class="math display">\[\begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} =F_{i-1} \times \begin{bmatrix}a &amp; b\end{bmatrix} + F_{i-2} \times\begin{bmatrix}c &amp; d\end{bmatrix}\]</span></p><p><span class="math display">\[\begin{bmatrix}F_i &amp; F_{i-1}\end{bmatrix} =\begin{bmatrix}a F_{i-1} + c F_{i-2}  &amp; b F_{i-1} + d F_{i-2}\end{bmatrix}\]</span></p><p>又因为 <span class="math display">\[F_i = F_{i-1} +F_{i-2}\]</span>，所以 <span class="math display">\[a = 1,c = 1,b = 1,d= 0\]</span>。</p><p>综上所述， <span class="math display">\[\text{base} = \begin{bmatrix}1 &amp; 1\\1 &amp; 0\end{bmatrix}\]</span>。</p><p>那么因为初始项为 <span class="math inline">\(F_1,F_2\)</span>。所以<span class="math inline">\(F_n = \begin{bmatrix} F_1 &amp; F_2\end{bmatrix} \times \text{base}^{n-2}\)</span></p><p>好好品品。</p><p><span class="math inline">\(\text{base}^{n-2}\)</span>矩阵可以通过上面的快速幂来求，所以时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span>。</p><p>这题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">mat</span>() &#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat&amp; M)&#123;<br>mat res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)<br>res.c[i][j] = (res.c[i][j] + c[i][k]*M.c[k][j]) % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br><br>mat base,ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>base.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = base.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = base.c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>ans = ans * base;<br>y = y / <span class="hljs-number">2</span>;<br>base = base * base;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>其实矩阵可以干事情的很多，就写这么多吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习线段树总结</title>
    <link href="/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天在复习 qbxt 的知识，学到了线段树，就来总结一下。</p><h1 id="线段树">线段树</h1><p><img src="https://z3.ax1x.com/2021/08/17/f4sLWR.png" /></p><p>上面这张图显然是线段树，线段树就是一个处理区间的一个数据结构，将整个线段划分成一个树的结构，将长度不是1的段划分成两个子区间来求解，通过合并两个区间的信息来求解，这也是一个高效的数据结构。</p><p>总体时间复杂度为 <span class="math inline">\(O(\log n)\)</span></p><ul><li>适用范围：区间的最小值或最大值，区间的修改，区间求和</li></ul><h2 id="操作">操作</h2><p>在所有操作开始之前，可以观察到一个根节点为 <spanclass="math inline">\(p\)</span> 的左儿子为 <spanclass="math inline">\(p^2\)</span> ，右儿子为 <spanclass="math inline">\(p^2+1\)</span></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;&lt;<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 左儿子 left sons</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 右儿子 right sons</span><br></code></pre></div></td></tr></table></figure><h3 id="建树">建树</h3><p>我们可以想到像树上 DFS 一样，可以一直访问儿子节点，直到儿子节点长度为1，我们可以通过数据上的值去更改子节点的值，再有子节点来合并（更新）父节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">// 建树 [l,r] 为当前的区间，p 为当前的节点编号</span><br>lazy[p] = <span class="hljs-number">1</span>;<span class="hljs-comment">// lazy_tag 后面会讲到</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果 长度为 1 </span><br>d[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 递归求解</span><br><span class="hljs-built_in">built</span>(l,mid,<span class="hljs-built_in">ls</span>(p));<span class="hljs-built_in">built</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)] ;  <span class="hljs-comment">// 由儿子更新父亲，合并</span><br>    <span class="hljs-comment">// 如果是求最大值，改成 d[p] = max(d[ls(p)],d[rs(p)]);最小值同样 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间查询">区间查询</h3><p>首先，我们可以想到还是像建树一样递归求解，如果这个区间在所要求的区间上了，直接返回，如果左儿子的子区间和原答案有交集，那么就递归到相应的节点上求解。那么思路就讲好了，代码怎么写呢？下面放上几张图就了解了</p><p>设所在区间为 <span class="math inline">\([l,r]\)</span> , 查询区间为<span class="math inline">\([s,t]\)</span> 。</p><figure><img src="https://z3.ax1x.com/2021/08/20/fj97CQ.jpg" alt="tree" /><figcaption aria-hidden="true">tree</figcaption></figure><p>那么根据这张图可以很显然的推出所在区间在查询区间的判断方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)<br></code></pre></div></td></tr></table></figure><p>设中间位置为 <span class="math inline">\(mid =\dfrac{(l+r)}{2}\)</span> 。</p><p><img src="https://z3.ax1x.com/2021/08/20/fjiS1J.jpg" /></p><p>可以很<del>简单</del>的看出，进入左儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &gt;= s)<br></code></pre></div></td></tr></table></figure><p>进入右儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &lt; t)<br></code></pre></div></td></tr></table></figure><p>综上，我们可以得出查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,t 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> d[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">pushdown</span>(p,l,r); <br>LL sum = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,t,<span class="hljs-built_in">ls</span>(p));    <span class="hljs-comment">// 如果是求最大值，就改成</span><br><span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同样</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="单点修改">单点修改</h3><p>在讲区间修改之前，我先来讲一下最基础的单点修改。单点修改也是递归找需要更改的点，然后再返回合并父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 当前 p 节点的范围，f 是修改的点的编号， c 是修改的值</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果递归到所达到的点了</span><br>d[p] = c;<br><span class="hljs-comment">// 如果是加上 c ，改成</span><br><span class="hljs-comment">// d[p] += c;</span><br>        <span class="hljs-comment">// 减去同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= f)<span class="hljs-comment">// 如果所要修改的点在左儿子上，进入左儿子</span><br><span class="hljs-built_in">update</span>(l,mid,f,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,f,c,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)];<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// d[p] = max(d[ls(p)] + d[rs(p)]);</span><br>    <span class="hljs-comment">// 最小值同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间修改">区间修改</h3><ul><li><p>懒标记</p><p>简单来说，就是通过<strong>延迟</strong>对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><div class="hljs code-wrapper"><pre><code>                                                                                                                                                              ----- OI-Wiki</code></pre></div></li></ul><p>这段话<del>深刻的阐释了</del>懒标记的作用，如果不用懒标记时间复杂度将会达到<span class="math inline">\(\mathcal{O}(n \log n)\)</span>有点慢，这样一来时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span> 的。</p><p>听我这样一讲有点蒙先来看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 为当前的, [s,t] 为询问的</span><br><span class="hljs-keyword">if</span>(l &gt;= s &amp;&amp; r &lt;= tt)&#123;<br>t[p] += (r-l+<span class="hljs-number">1</span>)*c;lazy[p] += c  <span class="hljs-comment">//懒标记;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p] &amp;&amp; l!=r)&#123; <span class="hljs-comment">// 懒标记的更新</span><br>t[<span class="hljs-built_in">ls</span>(p)] += (mid-l+<span class="hljs-number">1</span>)*lazy[p];t[<span class="hljs-built_in">rs</span>(p)] += (r-mid) * lazy[p];<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br><span class="hljs-built_in">update</span>(l,mid,s,tt,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(tt &gt; mid)<br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,s,tt,c,<span class="hljs-built_in">rs</span>(p));<br>t[p] = t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举个例子吧：</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpaTg0.png" alt="step1" /><figcaption aria-hidden="true">step1</figcaption></figure><p>如果我想要更改 <span class="math inline">\([9,10]\)</span>的每个数加上 5，我们可以先直接在这个区间上改，并给它们打上标记。</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpdV5d.png" alt="step2" /><figcaption aria-hidden="true">step2</figcaption></figure><p>虽然，子节点没有更新值，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>现在，来查询一下 <span class="math inline">\([9,9]\)</span>的值，当递归到 <span class="math inline">\([9,10]\)</span>时，因为懒标记不为 0 ，所以将该区间的子区间更新并清零。</p><figure><img src="https://z3.ax1x.com/2021/08/22/hpduxP.png" alt="step3" /><figcaption aria-hidden="true">step3</figcaption></figure><p>当然为了编写的简单性，修改懒标记可以写一个单独的函数<code>pushdown</code> 。</p><p>带乘法的查询也同理，只是新加一个乘法懒标记而已</p><h3 id="带懒标记的查询">带懒标记的查询</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,tt 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> t[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p])&#123;<br>t[<span class="hljs-built_in">ls</span>(p)] += lazy[p] * (mid-l+<span class="hljs-number">1</span>);t[<span class="hljs-built_in">rs</span>(p)] += lazy[p] * (r-mid);<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br>LL sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,tt,<span class="hljs-built_in">ls</span>(p));<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同理</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="习题">习题</h2><p>基本上有了这些操作就可以写以下几道题目：</p><ul><li><p>x 1// 初始化2​3for(int i=1;i&lt;=n;i++)4 fa[i] = n+i;5       6for(int i=n+1;i&lt;=n+n;i++)7 fa[i] = i,sz[i] = 1,sum[i] = i-n;8​9//第二个操作，仅仅将一个节点移动到另一个集合上。10​11int u = find(x),v =find(y);12if(u != v){13 fa[x] = v;14 sz[u] --;sz[v] ++;15 sum[u] -=x;sum[v] += x;16}cpp</p><p>这道题是个纯模板题</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷 P3373【模板】线段树 2</a></p><p>这道题也差不多是个模板题，只是要注意：<strong>先乘后加</strong>懒标记</p></li><li><p><a href="https://vjudge.net/problem/HDU-1166">HDU-1166敌兵布阵</a></p><p>单点修改的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1754">HDU-1754 I HateIt</a></p><p>单点修改，查询最大值的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1394">HDU-1394 MinimumInversion Number</a></p><p>线段树解决逆序对问题</p></li><li><p><a href="https://vjudge.net/problem/POJ-3468">POJ-3468 A SimpleProblem with Integers</a></p><p>区间修改的模板题</p></li></ul><p>模板题/好题未完待续 <span class="math inline">\(\dots\dots\)</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1160题解</title>
    <link href="/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置知识">前置知识</h2><ul><li>并查集</li></ul><p>简单的查找（带路经压缩）:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>    <span class="hljs-comment">// fa[i] 为并查集的数组</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>查找（这里可以数据小完全不需要用启发式合并）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br>    fa[f] = t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>查阅资料可知，只用路径压缩，不用启发式合并的平均时间复杂度为 <spanclass="math inline">\(\mathcal{O}(\alpha (n))\)</span>，最坏时间复杂度为 <span class="math inline">\(\mathcal{O}(m \logn)\)</span> 。</p><h2 id="思路">思路</h2><p>首先可以将每个元素看成点，化合物看成边，因为如果有超过 3个物品互相形成化合物就会爆炸，所以会爆炸的条件可以看成两个是在同一祖先（在同一集合）中，（如果这两个点有一个祖先的话，合并就会有3 个物品在一起的）。</p><p>每一次都将不在一个集合中两个数合并。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) == <span class="hljs-number">1</span>)&#123;    \\ 注意输入<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100010</span>;i++)fa[i] = i;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(f == t)ans ++;<br><span class="hljs-keyword">else</span><br>fa[f] = t;    <span class="hljs-comment">// 如果不会爆炸，就合并</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
      <tag>并查集</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现爬取UVA题库的PDF</title>
    <link href="/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/"/>
    <url>/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我在一次看洛谷日报时了解到了有一个软件可以下载 UVA 的 PDF ，我试了一下连接不上，可能是软件的作者太久没有更新了无法下载了，我便自己写了一个Python ,可能有些不好的地方。</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;https://uva.onlinejudge.org/external/1/p&#x27;</span><br><br>urllib3.disable_warnings()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">name,url</span>):</span><br>    response = requests.get(url,verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 就是这个地方不能用异步，有没有大佬知道为什么</span><br>    <span class="hljs-built_in">print</span>(response)<br>    f = <span class="hljs-built_in">open</span>(name,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    f.write(response.content)<br>    f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------------------&quot;</span>)<br>        i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你所需要的 UVA 题号 ： &quot;</span>))<br>        time.sleep(<span class="hljs-number">3</span>)<br>        download(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>,url + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>注 ： 还会根据我的需要不定时更新</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11426 GCD - Extreme (II)</title>
    <link href="/2021/07/28/UVA11426-GCD-Extreme-II/"/>
    <url>/2021/07/28/UVA11426-GCD-Extreme-II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="uva11426-gcd---extreme-ii">UVA11426 GCD - Extreme (II)</h1><p>这几天我看了 LRJ的书看到了这一题，就把这道题写了，正好这道题挺不错的。</p><h2 id="题目">题目</h2><p><ahref="https://uva.onlinejudge.org/external/114/p11424.pdf">题目PDF</a></p><h2 id="知识">知识</h2><h3 id="欧拉函数">欧拉函数</h3><ul><li>定义： <span class="math inline">\(\varphi(n)\)</span> 为小于等于<span class="math inline">\(n\)</span> 与 <spanclass="math inline">\(n\)</span> 互质的数的个数</li></ul><p>它有一些有趣的性质：</p><ul><li><span class="math inline">\(\varphi(n)\)</span> 是积性函数 ： 如果有<span class="math inline">\(\gcd(i,j) = 1\)</span> 那么就有 <spanclass="math inline">\(\varphi(i \times j) = \varphi(i) \times\varphi(j)\)</span></li></ul><h3 id="如何求欧拉函数">如何求欧拉函数：</h3><p>用一个类似于筛法求素数的方法，时间复杂度相似于埃氏筛法 <spanclass="math inline">\(\mathcal{O}(n\log \log n)\)</span></p><p><strong>模板代码</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> phi[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">table</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i ++)<br>        phi[i] = <span class="hljs-number">0</span>;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;= n;j ++)&#123;<br>    <span class="hljs-keyword">if</span>(!phi[j])phi[j] = j;<br>    phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>    &#125;<br>   <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="思路">思路</h2><p>首先，我们能想到暴力，每一次将每一个的 <spanclass="math inline">\(\gcd\)</span> 求出 ，最差时间复杂度为 <spanclass="math inline">\(\mathcal{O}(n^2\log n )\)</span>，太慢，在这个数据目前无能为力，所以想办法优化。</p><p>设 <span class="math display">\[\large f(n) =\sum\limits_{i=1}^{n-1}\gcd(i,n)\]</span> ，</p><p>所以答案为 <span class="math display">\[\large S(n) =\sum\limits_{i=1}^{n} f(i)\]</span>。</p><p><del>易证</del> ，<span class="math inline">\(\gcd(i,n)\)</span>的值都是 n 的约数，我们好好看看这个柿子有什么优化的地方</p><p>设 <span class="math inline">\(\dfrac{x}{i}\)</span> ，所以 <spanclass="math inline">\(\gcd(\dfrac{x}{i},\dfrac{n}{i}) = 1\)</span></p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(\dfrac{x}{i}\)</span> 与 <spanclass="math inline">\(\dfrac{n}{i}\)</span> 互质</p><p>所以小于等于 <span class="math inline">\(\dfrac{n}{i}\)</span>的互质的 <span class="math inline">\(\dfrac{x}{i}\)</span> 一共有 <spanclass="math inline">\(\varphi(\dfrac{n}{i})\)</span> 个</p><p>又 <span class="math inline">\(\because\)</span> <spanclass="math inline">\(\gcd(i,n)\)</span> <spanclass="math inline">\(\leqslant n\)</span></p><p>$$ <span class="math inline">\(\large f(n) = \sum\limits_{i\subset A}i \times \varphi(\dfrac{n}{i})\)</span> <span class="math inline">\(( A= n\)</span> 的约数 <span class="math inline">\()\)</span></p><p>上面的柿子就是我们所需要的，时间复杂度与求欧拉筛法同阶。</p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">4000000</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> phi[maxn],s[maxn],f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_c</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)phi[i] = <span class="hljs-number">0</span>;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(!phi[i])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;<br><span class="hljs-keyword">if</span>(!phi[j])<br>phi[j] = j;<br>phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">phi_c</span>();<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i*<span class="hljs-number">2</span>;j&lt;=maxn;j+=i)<br>f[j] += i*phi[j/i];<br><br>s[<span class="hljs-number">2</span>] = f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&lt;=maxn;j++)<br>s[j] = s[j<span class="hljs-number">-1</span>] + f[j];<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天的竞赛期末考试中遇到了组合数的题目，就是 <ahref="https://www.luogu.com.cn/problem/P2822">NOIP2016 组合数问题</a>原题，正好现在数学学到了一点点排列组合，就来整理一下吧。</p><h2 id="组合数">组合数</h2><p>就是从 <span class="math inline">\(n\)</span> 个不同元素中，抽取<span class="math inline">\(m\)</span> 个元素的方案数。</p><p>组合数公式为：</p><p><span class="math display">\[\dbinom{n}{m}= \dfrac{n!}{m! \times(n-m)!}\]</span></p><p>通过杨辉三角可得到递推公式：</p><p><span class="math inline">\(\dbinom{i}{j} = \dbinom{i-1}{j-1} +\dbinom{i-1}{j}\)</span></p><p>还有一个递推公式（可证明）：</p><p><span class="math display">\[\dbinom{i}{j} = \dfrac{n-k+1}{k} \times\dbinom{i}{j-1}\]</span></p><p>但是这个可能会乘法溢出</p><details><summary>证明</summary><img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1}{k\cdot(k-1)\dots\cdot1\cdot(n-k)\cdot(n-k-1)\dots\cdot1}" /><br><br><img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k-1} \cdot \dfrac{n-k+1}{k} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1\cdot(n - k + 1)}{k\cdot(k-1)\dots\cdot1\cdot(n-k+1)\cdot(n-k-1)\dots\cdot1}" /><br><br><img src="http://latex.codecogs.com/gif.latex? = \dbinom{n}{k}" /><br><br><img src="http://latex.codecogs.com/gif.latex?\therefore" />证明完毕</details><h2 id="题目思路">题目思路</h2><ul><li><p>暴力</p><p>暴力，暴力，暴力！</p></li><li><p>预处理</p><p>用第一个递推公式先递推出来所有的数，然后对于每一次查询进行判断是否 %k == 0，时间复杂度为 <spanclass="math inline">\(\mathcal{O}(q+tn^2)\)</span>，还是有点慢</p></li><li><p>预处理优化</p><p>我们可以想到每一判断都 % k 有点慢所以可以在预处理时 % k，判断是否等于0 ，开过 <span class="math inline">\(O2\)</span> 95pts，还需要优化。</p></li><li><p>前缀和+预处理</p><p>我们可以二维前缀和等于 0 的个数，然后每一次查询即可，时间复杂度变成了<span class="math inline">\(\mathcal{O}(q+t)\)</span> ,可以过了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n,m,k,t;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">complet</span><span class="hljs-params">()</span></span>&#123;<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2000</span>;i++)&#123;<br>c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + c[i<span class="hljs-number">-1</span>][j]) % k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];\\ 前缀和<br>        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-number">0</span>)f[i][j] ++;<br>        &#125;<br>        f[i][i+<span class="hljs-number">1</span>] = f[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-built_in">complet</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m &gt; n)<br>m = n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA问题</title>
    <link href="/2021/06/23/LCA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/23/LCA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="lca">LCA</h1><p>LCA 的问题是很经典的，我这一次就来讲解一下 LCA的求法，就先从一道模板题入手吧</p><h2 id="题目">题目</h2><p><a href="https://www.luogu.com.cn/problem/P3379">P3379【模板】最近公共祖先（LCA）</a></p><h3 id="输入格式">输入格式</h3><p>第一行包含三个正整数 <span class="math inline">\(N,M,S\)</span>分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 <span class="math inline">\(N-1\)</span> 行每行包含两个正整数<span class="math inline">\(x, y\)</span> 表示 <spanclass="math inline">\(x\)</span> 结点和 <spanclass="math inline">\(y\)</span>结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 <span class="math inline">\(M\)</span> 行每行包含两个正整数<span class="math inline">\(a, b\)</span> 表示询问 <spanclass="math inline">\(a\)</span> 结点和 <spanclass="math inline">\(b\)</span> 结点的最近公共祖先。</p><h3 id="输出格式">输出格式</h3><p>输出包含 <span class="math inline">\(M\)</span>行，每行包含一个正整数，依次为每一个询问的结果。</p><h3 id="说明提示">说明/提示</h3><p>对于 <span class="math inline">\(30\%\)</span> 的数据，<spanclass="math inline">\(N\leq 10，N \leq 10\)</span>。</p><p>对于 <span class="math inline">\(70\%\)</span> 的数据，<spanclass="math inline">\(N\leq 10000，N \leq 10000\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(N\leq 500000 ， N \leq 500000\)</span></p><h2 id="方法">方法</h2><h3 id="lca-的一些性质">LCA 的一些性质</h3><ul><li>两点的距离 ： $ d(u,v) = h(u) + h(v) + h((u,v) )$ ，<spanclass="math inline">\(h\)</span> 代表某一点的深度</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li></ul><h3 id="朴素算法">朴素算法</h3><p>首先，我们想到最暴力的方法，先把整个树 DFS一下，顺便将每个点的深度记录下来，将要查找的两个点中每次找深度最大的点，然后向上跳一格，最后两个点一定会相遇，相遇的点就一定是他们的LCA 。</p><p>下面是 DFS 的代码</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;     <span class="hljs-comment">// fa 为父亲节点，u 为当前节点， dep 为节点深度</span><br>    f[u] = fa;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 因为是 DFS ，每个节点是从它的父亲来的，父亲与儿子的深度相差 1 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i = nex[i])&#123;        <span class="hljs-comment">// 链式前向星</span><br>        <span class="hljs-keyword">int</span> v = to[i]; <br>        <span class="hljs-keyword">if</span>(v != fa)<br>            <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是 LCA 的核心代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(x != y)&#123;<br>        <span class="hljs-keyword">if</span>(dep[x] &gt;= dep[y])    x = f[x];<br>        <span class="hljs-keyword">else</span> y = f[y];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br></code></pre></div></td></tr></table></figure><p>很简单，就不详细讲了， 预处理时间复杂度是 <spanclass="math inline">\(\mathcal{O}(n)\)</span> ， 单次查询时间复杂度为<span class="math inline">\(\Theta(n \log n)\)</span> （随机树上)，时间有点慢，遇到大数据就不行了，我们需要优化</p><h3 id="倍增-lca">倍增 LCA</h3><p>这里先来了解一下<strong>倍增</strong>（<ahref="https://blog.csdn.net/jarjingx/article/details/8180560">更容易理解</a>），顾名思义，一倍一倍的增加，就比如一步一步跳7 格，但是我们可以先跳 <span class="math inline">\(2^2= 4\)</span>次，再跳 <span class="math inline">\(2\)</span> 次，最后跳 <spanclass="math inline">\(1\)</span> 次，原本需要跳 7 次，通过倍增只需要跳 3次。</p><p>这里可以倍增首先基于一个推论 ：</p><ul><li><p>任意整数可以表示成若干个 2 的次幂项的和</p><p><span class="math inline">\(eg. 7 = 2^2 + 2^1 + 2^0\)</span></p><p><span class="math inline">\(10 = 2^3 + 2^1\)</span></p></li></ul><p>下面来讲一下倍增 LCA :</p><p>显然可以将一步一步跳变成倍增，在 DFS 时可以通过 <spanclass="math inline">\(2^i = 2^{i-1}+2^{i-1}\)</span> 预处理 <spanclass="math inline">\(fa_i\)</span> 的位置。</p><p>在查询时可以从小到大倍增（<spanclass="math inline">\(2^0,2^1,2^2\dots\)</span>）来将 <spanclass="math inline">\(u,v\)</span> 跳到同一深度，在同时跳的时候从大到小倍增（<span class="math inline">\(2^i,2^{i-1}\dots2^1,2^0\)</span>），如果两个父亲不一样，就跳，那么最后的 LCA 是 <spanclass="math inline">\(fa_0\)</span></p><p>倍增 LCA 预处理时间复杂度为 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> ，单次查询时间为 <spanclass="math inline">\(\mathcal{O}(\log n)\)</span> 。</p><p>这个时间复杂度大部分题目都是可以接受的。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    dep[u] = dep[v] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)<br>        fa[u][i] = fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(G[u][i] == v)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(G[u][i],u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x] &gt; dep[y])        <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">int</span> tmp = dep[y] - dep[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;tmp;i++,tmp &gt;&gt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">1</span>)<br>            y = fa[y][i];<br>    <span class="hljs-keyword">if</span>(x == y)    <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; x != y;i--)<br>        <span class="hljs-keyword">if</span>(fa[x][i] != fa[y][i])&#123;x = fa[x][i];y = fa[y][i];&#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1A Theatre Square</title>
    <link href="/2021/05/16/CF1A-Theatre-Square/"/>
    <url>/2021/05/16/CF1A-Theatre-Square/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目">题目</h1><h2 id="题目描述">题目描述</h2><p>用 <span class="math inline">\(a \times a\)</span> 的石板覆盖 <spanclass="math inline">\(n \times m\)</span>的长方形广场，允许石板覆盖的区域超出广场，不允许打破石板，石板的两侧应平行于广场两侧，要求覆盖完广场所需的石板数量最少是多少。</p><h1 id="输入格式">输入格式</h1><p>输入有三个数字 <span class="math inline">\(n,m,a\)</span> (<spanclass="math inline">\(1≤n,m,a≤10^9\)</span>)</p><h1 id="思路">思路</h1><p>首先，我们看到是广场是长方形的，而石板是正方形的，<del>很容易就想到</del>可能会出现一中特殊情况：（广场的面积不足以铺一个石板），还会想到将长和宽一起除以石板边长，就是这个边所可以容纳多少个石板边长，最后再将所得的个数相乘，就是我们的答案了。<img src="https://z3.ax1x.com/2021/05/16/gcWxnP.png"alt="gcWxnP.png" /></p><p><span class="math inline">\(AC\)</span> 代码： <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,a;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a;<br>cout&lt;&lt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(<span class="hljs-built_in">ceil</span>(n/(<span class="hljs-keyword">double</span>)a)*<span class="hljs-built_in">ceil</span>(m/(<span class="hljs-keyword">double</span>)a))&lt;&lt;endl;<span class="hljs-comment">//注意一定要long long 不然就会强制转换为科学计数法</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单题</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3383 【模板】线性筛素数</title>
    <link href="/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目">题目</h1><p><a href="https://www.luogu.com.cn/problem/P3383">P3383【模板】线性筛素数</a> ## 题目描述</p><p>如题，给定一个范围<span class="math inline">\(n\)</span>，有<spanclass="math inline">\(q\)</span>个询问，每次输出第<spanclass="math inline">\(k\)</span>小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,q\)</span>，分别表示查询的范围和查询的个数。</p><p>接下来<span class="math inline">\(q\)</span>行每行一个正整数<spanclass="math inline">\(k\)</span>，表示查询第<spanclass="math inline">\(k\)</span>小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出<spanclass="math inline">\(q\)</span>行，每行一个正整数表示答案。</p><h2 id="数据范围">数据范围</h2><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n =10^8,1≤q≤10^6\)</span>，保证查询的素数不大于<spanclass="math inline">\(n\)</span>。</p><h1 id="知识题解">知识/题解</h1><p>这题是一道筛法模版题，第一个先想到的应该是暴力枚举，但是暴力枚举时间复杂度显然太高，然后经过一番搜寻，找到了埃式筛。</p><h3 id="埃式筛">埃式筛</h3><p>这个筛法的时间复杂度为<span class="math inline">\(O(n\log\logn)\)</span>,算的上是比较优秀了。</p><blockquote><p>如果<span class="math inline">\(x\)</span>是合数，那么<spanclass="math inline">\(x\)</span>的倍数也一定是合数。</p></blockquote><p>这个规则很容易就知道了是对的，是吧，这样我们要求100以内的数就只需将1到10以内的倍数枚举并标记，没有标记的数就是质数，这个筛法就是这个思想。<br />埃式筛的代码如下： <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="hljs-number">1</span>;<br>  is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>      prime[p++] = i;  <span class="hljs-comment">// prime[p]是i,后置自增运算代表当前素数数量</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)<br>          <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span><br>          <span class="hljs-comment">// 的倍数开始，提高了运行速度</span><br>          is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><p>但是这个还是有点慢，这个数据可能会过不了，所以我们又找到了另一个更快的算法：欧拉筛（线性筛）。</p><h3 id="线性筛">线性筛</h3><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记，所以线性筛就是来解决这个事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>      prime[cnt++] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * i * prime[j] &gt;= MAXN) <span class="hljs-keyword">break</span>;<br>      vis[i * prime[j]] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 换言之，i 之前被 pri[j] 筛过了</span><br>        <span class="hljs-comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是</span><br>        <span class="hljs-comment">// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break</span><br>        <span class="hljs-comment">// 掉就好了</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="本题ac代码">本题AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">100000010</span>];<br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">6000010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shai</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!visited[i])prime[cnt++] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br><span class="hljs-keyword">if</span>(i * prime[j] &gt; n)<br><span class="hljs-keyword">break</span>;<br>visited[i * prime[j]] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,x;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">shai</span>(n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,prime[x<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1029 [NOIP2001 普及组] 最大公约数和最小公倍数</title>
    <link href="/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目">题目</h1><h2 id="题目描述">题目描述</h2><p>输入两个正整数<span class="math inline">\(x_0,y_0\)</span>，求出满足下列条件的<span class="math inline">\(P,Q\)</span>的个数:<br />1. <span class="math inline">\(P,Q\)</span> 是正整数。 2. 要求 <spanclass="math inline">\(P, Q\)</span> 以 <spanclass="math inline">\(x_0\)</span>为最大公约数，以<spanclass="math inline">\(y_0\)</span>为最小公倍数。</p><p>试求：满足条件的所有可能的<span class="math inline">\(P,Q\)</span>的个数。 ## 输入格式 一行两个正整数<spanclass="math inline">\(x_0, y_0\)</span>。 ## 输出格式一行一个数，表示求出满足条件的<span class="math inline">\(P,Q\)</span>个数。</p><h1 id="知识讲解">知识讲解</h1><p>这一题是关于最大公约数（gcd）和最小公倍数（lcm）的，首先要算最大公约数，最好的算法是<ahref="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352">欧几里得算法</a>（辗转相除法）然而本人是个蒟蒻，所以还是要来证明一下的：### 最大公约数 设 <span class="math inline">\(a=bk+c\)</span> 则有 <spanclass="math inline">\(c= a\bmod b\)</span> ,设有一个数 <spanclass="math inline">\(d \mid a~,d \midb\)</span>（这个符号表示前者是后者的因数，能整除）, 则存在 <spanclass="math inline">\(c=a-bk\)</span> ， <spanclass="math inline">\(\dfrac{c}{d} = \dfrac{a-b}{d}k\)</span>。<br />显而易见，<span class="math inline">\(\dfrac{c}{d}\)</span>为整数，所以对于 <span class="math inline">\(a\)</span> 与 <spanclass="math inline">\(b\)</span> 的最大公约数为 <spanclass="math inline">\(a\bmod b\)</span> 的最大公约数（因为c为<spanclass="math inline">\(c= a\bmod b\)</span>），<br />所以 $ (a,b) = (a,ab)$,而这，就是欧几里得算法的核心内容。(终于结束了)下面给出欧几里得算法的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br>下面我们来讲最小公倍数的算法，最小公倍数可以通过最大公约数来求.</p><h3 id="最小公倍数">最小公倍数</h3><p>首先我们介绍这样一个定理——算术基本定理：</p><blockquote><p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p></blockquote><p>这个有一个通式 <span class="math inline">\(\largex=p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots b p_s^{k_s}\)</span></p><p>设 <span class="math display">\[\largea=p_1^{k_{a_1}}p_2^{k_{a_2}}p_3^{k_{a_3}} \dots p_s^{k_{a_s}} ,\largeb=p_1^{k_{b_1}}p_2^{k_{b_2}}p_3^{k_{b_3}}\dotsbp_s^{k_{b_s}}\]</span></p><p>可以得到，最大公约数为：<br /><span class="math display">\[\largep_1^{\min(k_{a_1},k_{b_1})}p_2^{\min(k_{a_2},k_{b_2})}\dotsbp_s^{\min(k_{a_s},k_{b_s})}\]</span></p><p>最小公倍数为：<br /><span class="math display">\[\largep_1^{\max(k_{a_1},k_{b_1})}p_2^{\max(k_{a_2},k_{b_2})}\dotsbp_s^{\max(k_{a_s},k_{b_s})}\]</span></p><p>将以上两个式子相乘，可以得到: &gt; $ (a,b)(a,b)=ab$</p><p>将上面的式子进行移项，就终于得到了这个重要的计算方法（呼，累死我了）：</p><blockquote><p><span class="math inline">\(\large \operatorname{lcm}(a,b) = a\timesb \div \gcd(a,b)\)</span></p></blockquote><h2 id="题解思路">题解思路</h2><p>那么，这道题基本的知识都讲完了，总结一下思路： 首先我们可以枚举<spanclass="math inline">\(P\)</span>，那么<spanclass="math inline">\(Q\)</span>可通过已经给的最小公倍数和最大公约数来求，然后再算出本身这两个数的最小公倍数和最大公约数，判断它们是否相等。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//最大公约数的算法</span><br><span class="hljs-keyword">return</span>  b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL n,m,ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(m*n);i++)&#123;  <span class="hljs-comment">//枚举到sqrt个即可</span><br><span class="hljs-keyword">if</span>(n==m)&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> j = m*n/i;  <br>LL x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>LL cnt = <span class="hljs-built_in">gcd</span>(i,j);<br><span class="hljs-keyword">if</span>(cnt == n &amp;&amp; i*j/cnt == m)   <span class="hljs-comment">//i*j/cnt 是算最大公约数的算法</span><br>ans += <span class="hljs-number">2</span>;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCM</tag>
      
      <tag>GCD</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树(模板)</title>
    <link href="/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目">题目</h1><p>这是个模板题 <strong>链接</strong>:<ahref="https://www.luogu.com.cn/problem/P3366">P3366【模板】最小生成树</a> ## 题目描述如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个整数 $ N,M $ ，表示该图共有 $ N $ 个结点和 $ M $条无向边。 接下来 $ M $ 行每行包含三个整数 $ X_i,Y_i,Z_i $,示有一条长度为 $ Z_i $ 的无向边连接结点 $ X_i,Y_i $。</p><h2 id="输出格式">输出格式</h2><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出orz。</p><h2 id="数据规模">数据规模</h2><p>对于 20% 的数据，$ N≤5，M≤20 $ 。</p><p>对于 40% 的数据，$ N≤50，M≤2500 $ 。</p><p>对于 70% 的数据，$ N≤500，M≤10 $ 。</p><p>对于 100%100% 的数据：$ 50001≤N≤5000， 1≤M≤2×10^5 $ 。</p><h1 id="题解">题解</h1><p>Kruskal 算法的主要思路： 1. 先以边的权值来给边排序，从小到大</p><figure><img src="https://z3.ax1x.com/2021/09/08/hb8YcQ.png" alt="dis0" /><figcaption aria-hidden="true">dis0</figcaption></figure><ol start="2" type="1"><li>然后开始由小到大遍历边，也就是一步一步的点的扩展</li></ol><figure><img src="https://z3.ax1x.com/2021/09/08/hb8J1g.png" alt="dis1" /><figcaption aria-hidden="true">dis1</figcaption></figure><ol start="3" type="1"><li>然后判断这个点的是否在已拓展的点内，如果不在就将答案加上它的边权，并且加入并查集</li></ol><figure><img src="https://z3.ax1x.com/2021/09/08/hb8G9S.png" alt="dis2" /><figcaption aria-hidden="true">dis2</figcaption></figure><figure><img src="https://z3.ax1x.com/2021/09/08/hb81tf.png" alt="dis3" /><figcaption aria-hidden="true">dis3</figcaption></figure><figure><img src="https://z3.ax1x.com/2021/09/08/hb83h8.png" alt="dis4" /><figcaption aria-hidden="true">dis4</figcaption></figure><p><strong>注意一下，这个是用邻接表edge写的（u，v为边的两个点，为边权），没有用领接矩阵</strong></p><p>基本上这个模板就这样了，代码如下：</p><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span> <br><span class="hljs-keyword">int</span> u,v,w;    <span class="hljs-comment">//定义一个边的结构体，u、v为边的两个定点，w为边的边权</span><br>&#125;;<br><br><br><br>edge e[<span class="hljs-number">200005</span>];<br><span class="hljs-keyword">int</span> father[<span class="hljs-number">5005</span>];      <span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge&amp; a,<span class="hljs-keyword">const</span> edge&amp; b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;        <span class="hljs-comment">//sort（）的判断，以边权的由大到小的顺序来排序 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;          <span class="hljs-comment">//并查集的寻找父亲</span><br><span class="hljs-keyword">return</span> father[x] == x ? x : father[x] = <span class="hljs-built_in">found</span>(father[x]);        <span class="hljs-comment">//压行，并且压缩路径，这样可以将之后的查找时间变为常数级</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(e,e+m,cmp);    <span class="hljs-comment">//kruskal 算法的重要部分：按照边权的大小来排序</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)father[j] = j;  <span class="hljs-comment">//初始化，每一个点都是一个自己的父亲</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(k == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">int</span> v = e[j].v,u = e[j].u;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(v) != <span class="hljs-built_in">found</span>(u))        <span class="hljs-comment">//如果没有这个边所在的点没有加入，就执行下面</span><br>&#123;<br>k++;   <span class="hljs-comment">//注意一点：这一句话一定要在这里写，我已经掉过坑里了</span><br>ans += e[j].w;    <span class="hljs-comment">//加入答案：最小生成树的总长</span><br><br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(v),t = <span class="hljs-built_in">found</span>(u);<br>father[t] = f;          <span class="hljs-comment">//使这个的边的这个点加入路径</span><br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(father[i] == i)<br>                cnt++;<br><br><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>&lt;&lt;endl;        <span class="hljs-comment">//如果有边不联通，就输出“orz”</span><br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过河卒</title>
    <link href="/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
    <url>/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="过河卒">过河卒</h1><p><strong>本题链接</strong>：<ahref="https://www.luogu.com.cn/problem/P1002">p1002 过河卒</a> ##题目描述</p><p>棋盘上 $ A $ 点有一个过河卒，需要走到目标$ B$点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $ C $点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$ A $ 点 $ (0,0) $ 、$ B $ 点 $ (n,m) $，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从 $ A $ 点能够到达 $ B $点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。<br />## 输入格式</p><p>一行四个正整数，分别表示 $ B $ 点坐标和马的坐标。 ## 输出格式一个整数，表示所有的路径条数。</p><h2 id="说明提示">说明/提示</h2><p>对于100%的数据, $ 1≤n,m≤20 $ ，$ 0≤ $ 马的坐标 $ ≤20 $。</p><h1 id="求解">求解</h1><p>我看到这题时，我就想到用递推来做这题</p><h4 id="根据题意并根据样例第一步可以写出下列-简单的-表格">1.根据题意并根据样例，第一步可以写出下列 <del>（简单的）</del> 表格：</h4><table><colgroup><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /></colgroup><thead><tr><th style="text-align: right;"></th><th style="text-align: right;">[0]</th><th style="text-align: right;">[1]</th><th style="text-align: right;">[2]</th><th style="text-align: right;">[3]</th><th style="text-align: right;">[4]</th><th style="text-align: right;">[5]</th><th style="text-align: right;">[6]</th></tr></thead><tbody><tr><td style="text-align: right;">[0]</td><td style="text-align: right;">0</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td><td style="text-align: right;">1</td></tr><tr><td style="text-align: right;">[1]</td><td style="text-align: right;">1</td><td style="text-align: right;">2</td><td style="text-align: right;">3</td><td style="text-align: right;">4</td><td style="text-align: right;">5</td><td style="text-align: right;">6</td><td style="text-align: right;">7</td></tr><tr><td style="text-align: right;">[2]</td><td style="text-align: right;">1</td><td style="text-align: right;">3</td><td style="text-align: right;">6</td><td style="text-align: right;">10</td><td style="text-align: right;">15</td><td style="text-align: right;">21</td><td style="text-align: right;">28</td></tr><tr><td style="text-align: right;">[3]</td><td style="text-align: right;">1</td><td style="text-align: right;">4</td><td style="text-align: right;">10</td><td style="text-align: right;">20</td><td style="text-align: right;">35</td><td style="text-align: right;">56</td><td style="text-align: right;">84</td></tr><tr><td style="text-align: right;">[4]</td><td style="text-align: right;">1</td><td style="text-align: right;">5</td><td style="text-align: right;">15</td><td style="text-align: right;">35</td><td style="text-align: right;">70</td><td style="text-align: right;">135</td><td style="text-align: right;">219</td></tr><tr><td style="text-align: right;">[5]</td><td style="text-align: right;">1</td><td style="text-align: right;">6</td><td style="text-align: right;">21</td><td style="text-align: right;">56</td><td style="text-align: right;">126</td><td style="text-align: right;">261</td><td style="text-align: right;">370</td></tr><tr><td style="text-align: right;">[6]</td><td style="text-align: right;">1</td><td style="text-align: right;">7</td><td style="text-align: right;">28</td><td style="text-align: right;">84</td><td style="text-align: right;">210</td><td style="text-align: right;">471</td><td style="text-align: right;">841</td></tr></tbody></table><p><del>（显而易见）</del>，这里可以利用<ahref="https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86/7538330?fr=aladdin">加法原理</a>，写出<strong>递推式</strong>：</p><p><span class="math display">\[f[i][j]=f[i-1][j]+f[i][j-1];(start:f[0][0]=1)\]</span></p><h4 id="第二步再加上马的影响">2. 第二步再加上马的影响</h4><table><colgroup><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /><col style="width: 12%" /></colgroup><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">[0]</th><th style="text-align: center;">[1]</th><th style="text-align: center;">[2]</th><th style="text-align: center;">[3]</th><th style="text-align: center;">[4]</th><th style="text-align: center;">[5]</th><th style="text-align: center;">[6]</th></tr></thead><tbody><tr><td style="text-align: center;">[0]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">[1]</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">[2]</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">[3]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[4]</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[5]</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">[6]</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">6</td></tr></tbody></table><p>根据这个表格，我们可以想到先把马的控制点，也就是马能到达的地方（包括他本身的这个点，做一个预处理，之后递推的时候，如果到达马的控制点，直接跳过，继续下一个点。</p><p>基本思路就是这样，但是在测评中发现了第三个点：只有longlong类型才能AC。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,x,y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> map[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>]=&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;  \\递推开始式为f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> horse[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> hx[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>&#125;,  \\马的位移<br>hy[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">8</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx=x+hx[i],yy=y+hy[i];<br><span class="hljs-keyword">if</span> (xx&gt;n||xx&lt;<span class="hljs-number">0</span>||yy&gt;m||yy&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>horse[xx][yy]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!horse[<span class="hljs-number">0</span>][++k]&amp;&amp;k&lt;=m)<br>map[<span class="hljs-number">0</span>][k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!horse[++l][<span class="hljs-number">0</span>]&amp;&amp;l&lt;=n)<br>map[l][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-keyword">if</span> (!horse[i][j])<br>map[i][j]=map[i<span class="hljs-number">-1</span>][j]+map[i][j<span class="hljs-number">-1</span>];   \\递推式<br>cout&lt;&lt;map[n][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
