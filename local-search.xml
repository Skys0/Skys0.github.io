<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>COPT求解器</title>
    <link href="/2025/02/18/COPT%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    <url>/2025/02/18/COPT%E6%B1%82%E8%A7%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="COPT"><a href="#COPT" class="headerlink" title="COPT"></a>COPT</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>杉数求解器COPT（Cardinal Optimizer）是杉数自主研发的针对大规模优化问题的高效数学规划求解器套件，也是支撑杉数端到端供应链平台的核心组件，是目前同时具备大规模混合整数规划、线性规划（单纯形法和内点法）、半定规划、（混合整数）二阶锥规划以及（混合整数）凸二次规划和（混合整数）凸二次约束规划问题求解能力的综合性能数学规划求解器。</p><p>其实现在感觉这个 COPT 在国内挺冷门的，自己就来看看官方文档以及一些课程，同步写在这篇文档下吧。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在写代码找到了一些很难被发现的东西，就写在这里吧。</p><ul><li>对于COPT的变量，在<code>addVar()</code>中默认<code>lb=0,rb=COPT.INFINITY</code>，也就是 $[0,+\infty)$</li></ul><h3 id="模型的求解状态"><a href="#模型的求解状态" class="headerlink" title="模型的求解状态"></a>模型的求解状态</h3><p>可以通过访问<code>Model.status</code>查看模型求解状态，<code>COPT.UNSTARTED</code>表示当前模型未开始求解。下面列出4个常见的求解状态。</p><div class="table-container"><table><thead><tr><th>模型求解状态</th><th>对应取值</th></tr></thead><tbody><tr><td><code>COPT.UNSTARTED</code></td><td>0</td></tr><tr><td><code>COPT.OPTIMAL</code></td><td>1</td></tr><tr><td><code>COPT.INFEASIBLE</code></td><td>2</td></tr><tr><td><code>COPT.UNBOUNDED</code></td><td>3</td></tr></tbody></table></div><h3 id="求解器的优化参数"><a href="#求解器的优化参数" class="headerlink" title="求解器的优化参数"></a>求解器的优化参数</h3><p>通过 <code>Model.setParam()</code>设置求解器的优化参数</p><p><code>setParam(paramname, newval)</code></p><p><code>paramname</code> 为指定的优化参数，<code>newval</code> 为指定的优化参数新值。</p><p>下面有一些可能会用到的优化参数，<a href="https://guide.coap.online/copt/zh-doc/parameter.html#chapparam">可以随时查看全部</a>：</p><ul><li><p><code>TimeLimit</code></p><ul><li>浮点数参数，优化求解的时间限制（秒）。</li><li><strong>默认值</strong> $10^{20}$</li><li><strong>最小值</strong> $0$</li><li><strong>最大值</strong> $10^{20}$</li></ul></li><li><p><code>LpMethod</code></p><ul><li>整数参数，求解线性规划问题的算法。</li><li><strong>默认值</strong> -1</li><li><strong>可选值</strong><ul><li>-1：自动选择：对于线性规划问题，选择对偶单纯形法，对于混合整数线性规划问题，选择对偶单纯形法或内点法之一。</li><li>1：对偶单纯形法。</li><li>2：内点法</li><li>3：直接Crossover。</li><li>4：并发求解（同时启动单纯形法与内点法求解）。</li><li>5：基于稀疏和数值范围等特征自动选择单纯形法或者内点法。</li><li>6：使用一阶算法（PDLP)求解。</li></ul></li></ul></li></ul><h3 id="结果获取及分析"><a href="#结果获取及分析" class="headerlink" title="结果获取及分析"></a>结果获取及分析</h3><p>求解完成后，若模型有最优解，则可以获取模型求解状态、决策变量最优解、目标函数最优值等信息，通过访问<code>Model</code>, <code>Val</code>类的成员属性获取。</p><p><code>Model.getVars()</code>获取模型中所有的决策变量，<code>Model.getConstrs()</code>获取模型中所有的约束条件。</p><p><strong>获取模型结果的主要成员属性和方法</strong>如下表所示：</p><div class="table-container"><table><thead><tr><th>信息项</th><th>成员属性/方法</th></tr></thead><tbody><tr><td>模型求解状态</td><td><code>Model.status</code></td></tr><tr><td>目标函数值</td><td><code>Model.objval</code></td></tr><tr><td>所有决策变量</td><td><code>Model.getVars()</code></td></tr><tr><td>变量名称</td><td><code>Var.name</code>, <code>Var.getName()</code></td></tr><tr><td>变量取值</td><td><code>Var.x</code></td></tr><tr><td>变量状态</td><td><code>Var.basis</code></td></tr></tbody></table></div><p><code>Model.status == COPT.OPTIMAL</code> 表示模型成功求得最优解，更多模型可能状态如下表所示：</p><div class="table-container"><table><thead><tr><th>模型求解的状态</th><th>含义</th></tr></thead><tbody><tr><td><code>COPT.UNSTARTED</code></td><td>未开始求解</td></tr><tr><td><code>COPT.OPTIMAL</code></td><td>成功求解</td></tr><tr><td><code>COPT.INFEASIBLE</code></td><td>模型无解</td></tr><tr><td><code>COPT.UNBOUNDED</code></td><td>最优值无界</td></tr><tr><td><code>COPT.INF_OR_UNB</code></td><td>模型无解或最优值无界</td></tr><tr><td><code>COPT.NUMERICAL</code></td><td>求解遇到数值问题</td></tr><tr><td><code>COPT.NODELIMIT</code></td><td>节点限制前未成功求解</td></tr><tr><td><code>COPT.TIMEOUT</code></td><td>时间限制前未成功求解</td></tr><tr><td><code>COPT.UNFINISHED</code></td><td>求解终止。但由于数值问题，求解器无法给出结果</td></tr></tbody></table></div><h3 id="multidict"><a href="#multidict" class="headerlink" title="multidict()"></a><strong>multidict</strong>()</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p><code>multidict(data)</code></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>将输入的字典对象拆分为键与多个字典对象并返回。</p><p>可以将输入的字典对象<code>data</code>拆分为键和多个字典对象。参数<code>data</code>是待拆分的字典对象，每个<code>key</code>映射 <strong>n</strong> 个值，拆分后会形成 <strong>n</strong> 个新的字典对象。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">nutrition, minNutrition, maxNutrition = multidict(&#123;<br>    <span class="hljs-string">&#x27;Vitamin A&#x27;</span>:  [<span class="hljs-number">700</span>, <span class="hljs-number">10000</span>],<br>    <span class="hljs-string">&#x27;Vitamin C&#x27;</span>:  [<span class="hljs-number">700</span>, <span class="hljs-number">10000</span>],<br>    <span class="hljs-string">&#x27;Vitamin B1&#x27;</span>: [<span class="hljs-number">700</span>, <span class="hljs-number">10000</span>],<br>    <span class="hljs-string">&#x27;Vitamin B2&#x27;</span>: [<span class="hljs-number">700</span>, <span class="hljs-number">10000</span>]&#125;)<br><span class="hljs-comment"># nutrition = [&#x27;Vitamin A&#x27;, &#x27;Vitamin C&#x27;, &#x27;Vitamin B1&#x27;, &#x27;Vitamin B2&#x27;]</span><br><span class="hljs-comment"># minNutrition = &#123;&#x27;Vitamin A&#x27;: 700, &#x27;Vitamin C&#x27;: 700, &#x27;Vitamin B1&#x27;: 700, &#x27;Vitamin B2&#x27;: 700&#125;</span><br><span class="hljs-comment"># maxNutrition = &#123;&#x27;Vitamin A&#x27;: 10000, &#x27;Vitamin C&#x27;: 10000, &#x27;Vitamin B1&#x27;: 10000, &#x27;Vitamin B2&#x27;: 10000&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="Model-addGenConstrAnd"><a href="#Model-addGenConstrAnd" class="headerlink" title="Model.addGenConstrAnd()"></a>Model.addGenConstrAnd()</h3><h4 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h4><p><code>addGenConstrAnd(resvar, vars, name=&quot;&quot;)</code></p><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>添加一条逻辑 <code>and</code> 约束，$y=x_1 \ \text{and} \ x_2 \dots\text{and} \ x_n$ 至模型中。</p><h4 id="参量"><a href="#参量" class="headerlink" title="参量"></a>参量</h4><p><code>resvar</code> ：等式左端项  <code>y</code>，二进制型</p><p><code>vars</code>：用 <code>and</code> 连接的变量，一般为列表类型</p><p><code>name</code>：约束名称，可选参数</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Add logical constraint: y = x1 &amp; x2</span><br>model.addGenConstrAnd(y, [x1, x2], name=<span class="hljs-string">&quot;and_constr&quot;</span>)<br></code></pre></div></td></tr></table></figure><p>同理，添加一条逻辑 <code>or</code> 约束，为<code>Model.addGenConstrOr()</code>，这里不再赘述。</p><h3 id="Model-addGenConstrAbs"><a href="#Model-addGenConstrAbs" class="headerlink" title="Model.addGenConstrAbs()"></a>Model.addGenConstrAbs()</h3><h4 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a>摘要</h4><p><code>addGenConstrAbs(resvar, argvar, name=&quot;&quot;)</code></p><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>添加⼀条形如 $cy+d=|ax+b|$ 的约束到模型中。</p><h4 id="参量-1"><a href="#参量-1" class="headerlink" title="参量"></a>参量</h4><p><code>resvar</code>：$cy+d$ ，可取值为 <code>Var</code> 类、 <code>MVar</code> 类、 <code>LinExpr</code> 类 或 <code>MLinExpr</code> 对象。</p><p><code>argvar</code>：$ax+b$ ，可取值为 <code>Var</code> 类、 <code>MVar</code> 类、 <code>LinExpr</code> 类 或 <code>MLinExpr</code> 对象。</p><p><code>name</code>：约束名称，可选参数</p><h3 id="Model-addGenConstrMin"><a href="#Model-addGenConstrMin" class="headerlink" title="Model.addGenConstrMin()"></a>Model.addGenConstrMin()</h3><h4 id="摘要-3"><a href="#摘要-3" class="headerlink" title="摘要"></a>摘要</h4><p><code>addGenConstrMin(resvar, vars, constant=None, name=&quot;&quot;)</code></p><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>添加⼀条形如 $y=\min{x_1,x_2,\dots,x_n,c}$ 的约束到模型中。</p><h4 id="参量-2"><a href="#参量-2" class="headerlink" title="参量"></a>参量</h4><p><code>resvar</code>：等式左端项 <code>y</code> </p><p><code>vars</code>：等式右端 $\min{}$ 函数的变量</p><p><code>constant</code>：等式右端 $\min{}$ 函数中的常数项，可选参数</p><p><code>name</code>：约束名称，可选参数</p><p>添加最大值同理：<code>Model.addGenConstrMax()</code></p><h3 id="Model-addGenConstrPWL"><a href="#Model-addGenConstrPWL" class="headerlink" title="Model.addGenConstrPWL()"></a>Model.addGenConstrPWL()</h3><h4 id="摘要-4"><a href="#摘要-4" class="headerlink" title="摘要"></a>摘要</h4><p><code>addGenConstrPWL(xvar, yvar, xpts, ypts, name=&quot;&quot;)</code></p><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>添加形如 $y=f(x)$ 的约束。</p><h4 id="参量-3"><a href="#参量-3" class="headerlink" title="参量"></a>参量</h4><p><code>xvar</code>：<code>x</code> ，可取值为 <code>Var</code> 类对象或 <code>MVar</code> 类对象。</p><p><code>yvar</code>：等式左端项 <code>y</code> </p><p><code>xpts</code>： $\hat{x}$，分段点的横坐标，需按照取值从小到大的顺序排列，可取值为 <code>List</code> 类。</p><p><code>ypts</code>：$\hat{y}$，分段点的纵坐标，可取值为 <code>List</code> 类。</p><p><code>name</code>：约束名称，可选参数 </p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Set non-linear functions f(x) and g(z) (converting to PWL constraints)</span><br>npts = <span class="hljs-number">101</span><span class="hljs-comment"># 分成 100 份</span><br>ptu = []<br>ptf = []<br>ptg = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(npts):<br>    ptu.append(lb + (ub - lb) * i / (npts - <span class="hljs-number">1</span>))<span class="hljs-comment"># ptu 是间断的 100 个点</span><br>    ptf.append(f(ptu[i]))<span class="hljs-comment"># ptf 是对应 f(x) 的 100 个点的函数值</span><br>    ptg.append(g(ptu[i]))<span class="hljs-comment"># ptg 是对应 g(x) 的 100 个点的函数值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ptu:&quot;</span>, ptu)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ptf:&quot;</span>, ptf)<br>m.addGenConstrPWL(x, s, ptu, ptf, name=<span class="hljs-string">&#x27;f_exp&#x27;</span>)<br>m.addGenConstrPWL(z, t, ptu, ptg, name=<span class="hljs-string">&#x27;g_sqrt&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="quicksum"><a href="#quicksum" class="headerlink" title="quicksum()"></a>quicksum()</h3><h4 id="摘要-5"><a href="#摘要-5" class="headerlink" title="摘要"></a>摘要</h4><p><code>quicksum(data)</code></p><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>快速构建表达式，求和</p><h4 id="参量-4"><a href="#参量-4" class="headerlink" title="参量"></a>参量</h4><p><code>data</code>：生成表达式待加项</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">cp.quicksum(fixed_costs[i] * y[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lines)<br><span class="hljs-comment"># 可以这种写法：列表推导式</span><br></code></pre></div></td></tr></table></figure><p>这里提一下这里的写法有点奇怪：<strong>列表推导式</strong>的基本语法如下：<code>[表达式 for 元素 in 可迭代对象 if 条件]</code>，这种可以比较优美的写出一个列表，感觉还挺符合阅读习惯的。</p><h3 id="Model-addGenConstrIndicator"><a href="#Model-addGenConstrIndicator" class="headerlink" title="Model.addGenConstrIndicator()"></a>Model.addGenConstrIndicator()</h3><h4 id="摘要-6"><a href="#摘要-6" class="headerlink" title="摘要"></a>摘要</h4><p><code>addGenConstrIndicator(binvar, binval, lhs, sense=None, rhs=None, type=COPT.INDICATOR_IF, name=&quot;&quot;)</code></p><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>添加一个指定类型的指示约束(Indicator)到模型中</p><h4 id="参量-5"><a href="#参量-5" class="headerlink" title="参量"></a>参量</h4><p><code>binvar</code>：Indicator变量。</p><p><code>binval</code>：Indicator变量的取值，可取值为 <code>True</code> 或 <code>False</code> 。</p><p><code>lhs</code>：Indicator约束中线性约束的左端项或线性约束构建器。</p><p><code>sense</code>：Indicator约束中线性约束的<strong>类型</strong>。可选参量（其实可以省略，直接放到 <code>lhs</code> 上一起写））</p><p><code>rhs</code>：Indicator约束中线性约束的左端项或线性约束构建器。（其实可以省略，直接放到 <code>lhs</code> 上一起写）</p><p><code>type</code>：Indicator约束的类型。可选参量。有以下参数可以选：</p><ul><li><p><code>COPT.INDICATOR_IF</code>（If-Then约束）</p></li><li><p><code>COPT.INDICATOR_ONLYIF</code> （Only-If约束）</p></li><li><p><code>COPT.INDICATOR_ONLYIF</code>（If-and-Only-If约束）</p></li></ul><h3 id="model-addVars"><a href="#model-addVars" class="headerlink" title="model.addVars()"></a>model.addVars()</h3><h4 id="摘要-7"><a href="#摘要-7" class="headerlink" title="摘要"></a>摘要</h4><p><code>addVars(*indices, lb=0.0, ub=COPT.INFINITY, obj=0.0, vtype=COPT.CONTINUOUS, nameprefix=&quot;C&quot;)</code></p><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>添加一组变量到模型中，并返回一个 tupledict 类对象， 其键为变量的下标，值为相应的 Var 类对象。</p><p>这里的 <code>lb,ub,vtype</code> 与 <code>addVar()</code> 中一致，但是其中 <code>*indices</code>和<code>nameprefix</code>两个参数的设置有所区别，如下表所示：</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td><code>*indices</code></td><td>变量下标</td><td>2种指定方式</td></tr><tr><td><code>nameprefix</code></td><td>变量名称前缀</td><td>默认C，实际名称：前缀+下标</td></tr></tbody></table></div><p>参数 <code>*indices</code> 指定决策变量的下标，方式有如下两种：</p><ol><li><p>指定决策变量的维度规模（dense的形式）</p><p><code>model.addVars(2)</code>创建2个决策变量，存储在一维数组中，形如$x[0],x[1],x[2]$</p><p><code>model.addVars(2,3)</code>创建6个决策变量，存储在二维数组中，形如$x[0,0],x[0,1],…,x[1,2]$</p><p><code>model.addVars(2,3,4)</code>创建24个决策变量，存储在三维数组中，形如$x[0,0,0],x[0,0,1],…,x[1,1,2]$</p></li><li><p>通过提供具体的下标列表(tuplelist)(sparse的形式)，tuplelist是list的子类，其中的每个元素是tuple类型：</p></li></ol><p>可以看<a href="https://coridm.d2d.ai/courses/32/supplement/782">这个例子</a>，</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>线性规划</tag>
      
      <tag>COPT求解器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《大学生数学建模竞赛指南》摘抄</title>
    <link href="/2025/02/03/%E3%80%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B%E6%8C%87%E5%8D%97%E3%80%8B%E6%91%98%E6%8A%84/"/>
    <url>/2025/02/03/%E3%80%8A%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B%E6%8C%87%E5%8D%97%E3%80%8B%E6%91%98%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数学建模论文的部分"><a href="#数学建模论文的部分" class="headerlink" title="数学建模论文的部分"></a>数学建模论文的部分</h3><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>摘要就是一篇建模比赛论文的整体面貌，评委对论文第一轮评审就是通过对摘要进行筛选，所以对于每个参赛队来说，写好摘要，是获奖的较为重要的一步，也是为论文进一步的得到评委审批的关键。</p><p>摘要的字数一般在400～800字，但其内容却包含了参赛队对题意理解、模型类型、<br>建模思路、采用的求解方法及求解思路、算法特点、灵敏度分析、模型检验、主要数值结<br>果和结论等。</p><p>在摘要下一行还需选取3～5个关键词，用来彰显竞赛论文的主要内容。</p><h4 id="问题重述（或问题的提出与重述）"><a href="#问题重述（或问题的提出与重述）" class="headerlink" title="问题重述（或问题的提出与重述）"></a>问题重述（或问题的提出与重述）</h4><p>通过自己对题意的理解，用自己的语言重新描述问题。如果问题本身很简短，可以抄题，一般情况下不建议抄题。有些情况，可以结合问题的背景进行简要扼明说明解决问题的意义所在。</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>需要抓住题目的关键词和主要目地及要求，分析要中肯、确切。依据原理要明确，描述要简明扼要，可列出关键步骤，切记不要长，繁琐。对问题的分析，可以作为第三部分，也可以将其针对每个问题写在模型建立中。建议采用流程图，使思路表述更清晰。</p><h4 id="模型假设"><a href="#模型假设" class="headerlink" title="模型假设"></a>模型假设</h4><p>在对问题进行分析后，发现有些因素或条件，还无法进行考虑或估算；或是针对问题的主要因素，舍弃次要因素的影响，采用假设的方式，是我们解决的问题简化，模型更合理化。这部分内容，可以单独写，也可以在模型建立时根据所需要情况再进行描述。</p><h4 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h4><p>对模型使用的变量加以说明，以简要的文字表述各字母的意义，其中各个主要符号的大小写、英语和阿拉伯语，要与正文中符号一致。符号说明太多时，建议采用表格形式。有时可将其分布在模型建立中，也可以用表格形式。</p><h4 id="模型的建立"><a href="#模型的建立" class="headerlink" title="模型的建立"></a>模型的建立</h4><p>明确题意后，简述基本思路。首先，简要介绍利用的基本原理和基本思想，再进行构建基本模型，如数学表达式、构建方案、构造图、算法流程图等，要明确说明解题的思想和思路，有逻辑性、合理性、可行性，完整叙述。结合实际问题，进行改进和完善基本模型，使其能有效、实用解决问题。</p><h4 id="模型的求解"><a href="#模型的求解" class="headerlink" title="模型的求解"></a>模型的求解</h4><p>采用蚁群算法、模拟退火、遗传算法、元胞自动机、蒙特卡洛等一些智能算法时，要简要写明算法步骤，要阐明使用理由。计算时将一些必要的步骤列出来，不用将中间的计算过程一一列出。</p><h4 id="模型的检验"><a href="#模型的检验" class="headerlink" title="模型的检验"></a>模型的检验</h4><p>在模型求解后，采用一些方法进行检验。有的可以采用原始数据和查找的数据处理效果进行对比检验；有的采用对结果的t检验、f检验等，若误差较大时，可分析原理，进行改进或修正。</p><h4 id="模型评价和推广"><a href="#模型评价和推广" class="headerlink" title="模型评价和推广"></a>模型评价和推广</h4><p>这里需要强调的是，衡量一个模型的优劣全在于它的应用效果，而不是采用了多么高深的数学方法。进一步说，如果对于某个实际问题，我们用初等的方法和所谓的高等方法建立了两个模型，它们的应用效果相差无几，那么受到人们欢迎并采用的一定是前者而非后者。模型推广，可以采用将原题要求进行扩展，进一步讨论模型的实用性和可行性；还可以提出问题的展望。</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>论文提及或是直接引用的文献、引用数据的出处等，需要在这部分进行罗列出来。</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>这部分不属于论文的正文内容，是一些很重要的计算过程、算法程序、一些数据表格等。古训有云：读万卷书，行万里路。一个优秀的学习者并不仅仅是掌握理论上的知识，更应将所学的知识应用到实际中，不断的在实践中提升自我。这也是素质教育对于同学们的要求。</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
      <tag>摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排队论</title>
    <link href="/2025/01/24/%E6%8E%92%E9%98%9F%E8%AE%BA/"/>
    <url>/2025/01/24/%E6%8E%92%E9%98%9F%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>输入过程：</p><p>顾客源：可以是无限的，也可以是有限的</p><p>顾客的到达方式：单个到达或者是成批到达</p><p>顾客到达时间间隔分布：负指数分布（单位时间顾客到达数服从 $\lambda$ 为参数的指数分布）</p><p>排队规则：</p><p>排队系统类型：如果所有服务台都正被占用，等候的称为等待制，随即离去的称为损失制</p><p>排队队列可以是单列，也可以是多列</p><p>接受服务的顺序：先到先服务（FCFS）、后到先服务（FCFS）、随机服务（SIRO）、优先服务（PR）</p><p>服务机构：一般有五种</p><p>单对单服务台：一条队对一个服务台</p><p>单队对多服务台<strong>并联</strong>式</p><p>多队对多服务台<strong>并联</strong>式</p><p>单队对多服务台<strong>串联</strong>式</p><p>单队对多服务台<strong>串并联</strong>混合式 </p><p>排队系统模型表示：$A/B/C/D/E/F$</p><p>分别表示：顾客到达时间间隔分布/服务时间分布/服务台数目/系统中顾客容量限制/顾客源数目/服务规则  </p><ol><li>顾客到达时间间隔分布：$M$ ——负指数分布</li><li>服务时间分布：$M$ ——负指数分布</li><li>服务台数目：$1$——一个服务台，$C$——多个服务台</li><li>系统中顾客容量限制：$\infty$——系统中顾客容量无限制，$N$——系统最多容纳 $N$ 个顾客</li><li>顾客源数量：$\infty$——顾客源数量无限多，$N$——顾客源的总体一共有 $N$ 个</li><li>服务规则：$FCFS$——先到先服务</li></ol><p>排队系统的指标：</p><ul><li>状态概率分布 $P_n$：系统中有 $n$ 个顾客的概率</li><li>队长 $L$：系统的平均顾客数</li><li>排队长 $L_q$：系统中排队等待的平均顾客数</li><li>顾客平均停留时间 $W$</li><li>顾客平均等待时间 $W_q$ </li></ul><h2 id="马尔可夫排队模型"><a href="#马尔可夫排队模型" class="headerlink" title="马尔可夫排队模型"></a>马尔可夫排队模型</h2><p>将一个新顾客到来看作为生，将一个顾客服务完离开看作死，设置 $N(t)$ 为任意时刻 $t$ 排队系统的状态。满足下列生灭过程特征的排队模型称为马尔科夫排队模型：</p><ul><li><p>给定 $N(t)=n$，到下一个顾客到达的间隔时间服从参数为 $\lambda_n(n=0,1,2,\dots)$ 的负指数分布；</p></li><li><p>给定 $N(t)=n$，到下一个顾客离开的间隔时间服从参数为 $\mu_n(n=0,1,2,…)$ 的负指数分布；</p></li><li>同一时刻只有一个顾客达到或离去。</li></ul><h3 id="状态平衡方程："><a href="#状态平衡方程：" class="headerlink" title="状态平衡方程："></a>状态平衡方程：</h3><p>对于 $N(t)$ 的分布，在平稳状态下，就是状态平衡方程</p><p><strong>平稳状态</strong>：对于任一状态 $n$，流入的等于流出。</p><p>那么可以得出：</p><script type="math/tex; mode=display">\begin{align*}状态 0: & P_1\mu_1 = P_0\lambda_0   & P_1=\frac{\lambda_0}{\mu_1} P_0\\状态 1: & P_0\lambda_0 + P_2\mu_2 = P_1\mu_1 + P_1\lambda_1   & P_2=\frac{\lambda_1\lambda_0}{\mu_2\mu_1}P_0 \\状态 2: & P_1\lambda_1 + P_3\mu_3 = P_2\mu_2 + P_2\lambda_2   & P_3 = \frac{\lambda_2\lambda_1\lambda_0}{\mu_3\mu_2\mu_1}P_0 \\&\vdots \\状态 n: & P_{n-1}\lambda_{n-1} + P_{n+1}\mu_{n+1} = P_{n}\mu_{n} + P_{n}\lambda_{n}   & P_n = \frac{\lambda_{n-1}\lambda_{n-2}\cdots\lambda_0}{\mu_{n-1}\mu_{n-2}\cdots\mu_1} P_0 \\\end{align*}</script><p>通过 $P_0 + P_1 + P_2 \cdots + P_n = 1$ 可以算出 $P_0$ 那么进一步可以算出其他的</p><h2 id="M-M-1-∞-∞-FCFS-排队模型"><a href="#M-M-1-∞-∞-FCFS-排队模型" class="headerlink" title="M/M/1/∞/∞/FCFS 排队模型"></a>M/M/1/∞/∞/FCFS 排队模型</h2><p>模型含义：顾客到达过程服从泊松流，服务时间服从负指数分布，单服务台，系统容量和顾客来源无限，先到先服务。设单位时间内顾客平均到达率为 $\lambda$，单位时间内服务台平均服务率为 $\mu$。</p><h3 id="状态平衡方程"><a href="#状态平衡方程" class="headerlink" title="状态平衡方程"></a>状态平衡方程</h3><script type="math/tex; mode=display">\begin{align*}状态 0: & P_1\mu = P_0\lambda   & P_1=\frac{\lambda}{\mu} P_0 = \rho P_0\\状态 1: & P_0\lambda + P_2\mu = P_1\mu + P_1\lambda   & P_2=\rho^2 P_0 \\状态 2: & P_1\lambda + P_3\mu = P_2\mu + P_2\lambda   & P_3 = \rho^3 P_0 \\&\vdots \\状态 n: & P_{n-1}\lambda + P_{n+1}\mu = P_{n}\mu + P_{n}\lambda   & P_n = \rho^n  P_0 \\\end{align*}</script><p>通过 $P_0 + P_1 + P_2 \cdots + P_n = 1$ 可以算出 $P_0 = 1 - \rho$，$P_n = \rho^n(1-\rho)$ </p><p>队长：$L = \Sigma_{n=0}^{\infty} nP_n = \frac{\rho}{1-\rho}$</p><p>排队长：$L_q = \frac{\rho^2}{1-\rho}$</p><p>顾客平均停留时间：$W = \frac{1}{\mu - \lambda}$</p><p>顾客平均等待时间：$W_q = \frac{\lambda}{\mu(\mu - \lambda)}$</p><h2 id="M-M-C-∞-∞-FCFS排队模型"><a href="#M-M-C-∞-∞-FCFS排队模型" class="headerlink" title="M/M/C/∞/∞/FCFS排队模型"></a>M/M/C/∞/∞/FCFS排队模型</h2><p>顾客到达过程服从泊松流，每个服务台的服务时间均服从负指数分布，$C$ 个服务台，系统容量和顾客<br>来源无限，先到先服务。设单位时间内顾客平均到达率为 $\lambda$，单位时间内每个服务台平均服务率为 $\mu$。</p><p>系统的平均服务率：$\mu_n = \begin{cases} n\mu  &amp;0\leq n\leq C \ C\mu &amp; C\leq n \end{cases}$</p><p>服务台的繁忙度：$\rho = \frac{\lambda}{C\mu}$</p><p>系统中没有顾客的概率：</p><script type="math/tex; mode=display">P_0 = [\Sigma_{i-0}^{C-1} \dfrac{1}{i!}(\dfrac{\lambda}{\mu})^i + \dfrac{1}{1-\rho} \dfrac{1}{C!}(\dfrac{\lambda}{\mu})^C]^{-1}</script><p>排队长：$L_q =\dfrac{1}{C!} (\dfrac{\lambda}{\mu})^C\dfrac{\rho}{(1-\rho)^2} P_0$</p><p>顾客平均停留时间：$W = \dfrac{L}{\lambda}$</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>排队论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储论</title>
    <link href="/2025/01/21/%E5%AD%98%E5%82%A8%E8%AE%BA/"/>
    <url>/2025/01/21/%E5%AD%98%E5%82%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="存储论"><a href="#存储论" class="headerlink" title="存储论"></a>存储论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>存储问题的费用：</p><ul><li>生产费：<ul><li>订购费：与订货次数有关，一般固定</li><li>货物成本费：与订货数量有关，一般变动</li></ul></li><li>生产费<ul><li>装配费：与生产次数有关，一般固定</li><li>生产成本费：与生产数量有关，一般变动</li></ul></li><li>存储费</li><li>缺货费</li></ul><p>储存模型：</p><ul><li>需求是否确定：确定型存储模型，随机型存储模型</li><li>订货还是生产：批量订货（备货时间短），批量生产（生产需时间）</li><li>允不允许缺货：允许缺货，不允许缺货</li></ul><h3 id="不允许缺货、瞬时到货模型（经济订货批量模型）"><a href="#不允许缺货、瞬时到货模型（经济订货批量模型）" class="headerlink" title="不允许缺货、瞬时到货模型（经济订货批量模型）"></a>不允许缺货、瞬时到货模型（经济订货批量模型）</h3><h4 id="模型基本假设"><a href="#模型基本假设" class="headerlink" title="模型基本假设"></a>模型基本假设</h4><ol><li>不允许缺货，缺货费正无穷</li><li>存储量为零时，可<strong>立即</strong>得到补充</li><li>需求是连续均匀的，需求速度为常数 $R$</li><li>每次订货量不变，订购费不变</li><li>单位时间的存储</li></ol><h4 id="模型计算"><a href="#模型计算" class="headerlink" title="模型计算"></a>模型计算</h4><p>假设每次订货的订购费用为 $c_3$</p><p>假设 $货物成本费 = 成本费单价 \times 订货量=KQ=KRt$</p><p>其中 $K$ 为货物成本费单价，$Q$ 为订货量，$R$ 为需求速度，$t$ 为每间隔时间 $t$ 补充一次存储</p><p>存储费：$t$ 时间内的平均存储量：$\frac{1}{2}Q = \frac{1}{2}Rt$，我们在这里假设单位时间内单位货物存储费为 $c_1$</p><p>怎么来的呢？求积分得到上面的式子的：$\dfrac{存储量之和}{t} = \dfrac{\int_{0}^{t}RT\,dT}{t} = \dfrac{1}{2}Rt$</p><p>那么我们的 $t$ 时间内的总平均费用（一般省略 $KR$）：</p><script type="math/tex; mode=display">C(t)=\frac{c_3}{t} + KR + \frac{1}{2}Rtc_1</script><p>我们用这个式子对 $t$ 求一次导数，求极值点</p><p>得到最优订货周期为：$t_0 = \sqrt{\dfrac{2c_3}{c_1R}}$</p><p>最优订货量：$Q_0 = Rt_0 = \sqrt{\dfrac{2c_3R}{c_1}}$</p><h3 id="不允许缺货，逐步均匀到货模型"><a href="#不允许缺货，逐步均匀到货模型" class="headerlink" title="不允许缺货，逐步均匀到货模型"></a>不允许缺货，逐步均匀到货模型</h3><h4 id="模型基本假设-1"><a href="#模型基本假设-1" class="headerlink" title="模型基本假设"></a>模型基本假设</h4><ol><li>不允许缺货，缺货费正无穷</li><li>存储量为零时开始生产，生产速度为常数 $P$</li><li>需求是连续均匀的，需求速度为常数 $R$</li><li>每次订货量不变，装配费不变</li><li>单位时间的存储费不变</li></ol><h4 id="模型计算-1"><a href="#模型计算-1" class="headerlink" title="模型计算"></a>模型计算</h4><p>首先假设每次生产的装配费用为 $c_3$，那么 $t$ 时间内平均装配费为 $\frac{c_3}{t}$</p><p>$t$ 时间内的平均<strong>存储量</strong>为：$\frac{1}{2}(P-R)t_1$，其中 $t_1$ 是所需生产时间</p><p>我们用 $t \to t_0$，那么平均<strong>储存费</strong>就等于 $\dfrac{c_1R(P-R)}{2P}t$</p><p>那么将两个加在一起就是总平均费用：</p><script type="math/tex; mode=display">C(t) = \frac{c_3}{t} + \frac{c_1 R(P-R)}{2P} t</script><p>求极值点，那么可得最优周期为：$t_0 = \sqrt{\dfrac{2c_3P}{c_1 R (P - R)}}$</p><p>最优生产量为：$Q_0 = \sqrt{\dfrac{2c_3PR}{c_1(P-R)}}$</p><p>最小总平均费用为：$C_0 = \sqrt{2c_1c_3R\dfrac{P-R}{P}}$</p><h3 id="允许缺货，瞬时到货模型"><a href="#允许缺货，瞬时到货模型" class="headerlink" title="允许缺货，瞬时到货模型"></a>允许缺货，瞬时到货模型</h3><h4 id="模型基本假设-2"><a href="#模型基本假设-2" class="headerlink" title="模型基本假设"></a>模型基本假设</h4><ol><li>允许缺货</li><li>备货时间很短，可立即得到补充</li><li>需求是连续均匀的，需求速度为常数 $R$</li><li>每次订货量不变，订购费不变</li><li>单位时间内的存储费不变</li></ol><h4 id="模型计算-2"><a href="#模型计算-2" class="headerlink" title="模型计算"></a>模型计算</h4><p>我们只算一个周期 $t$ 的一个费用。</p><p>假设每次订货的订购费用为 $c_3$， 单位存储费为 $c_1$</p><p>那么储存费为 $\frac{1}{2}c_1\frac{S^2}{R}$，其中 $S = Rt_1$，$t_1$ 表示有货的那段时间</p><p>假设单位时间内单位物品缺货费为 $c_2$</p><p>那么总缺货费为 $\frac{1}{2} c_2 \frac{(Rt- S)^2}{R}$</p><p>那么我们总的费用就是三项加起来：</p><script type="math/tex; mode=display">C(t) = \frac{1}{2}c_1\frac{S^2}{R}+\frac{1}{2}c_2\frac{(Rt-S)^2}{R}+c_3</script><p>多元函数求极值，得到最优周期为：$t_0 = \sqrt{\dfrac{2c_3(c_1+c_2)}{c_1c_2R}}$</p><p>最大存储量：$S_0 = \sqrt{\dfrac{2c_2c_3R}{c_1(c_1+c_2)}}$</p><p>最优进货量：$Q_0 = \sqrt{\dfrac{2Rc_3(c_1+c_2)}{c_1c_2}}$</p><p>最小总平均费用：$C_0 = \sqrt{\dfrac{2c_1c_2c_3R}{c_1 + c_2}}$</p><p>观察第一个模型与这个的区别，其实可以发现其实第一个的式子就是这个的特殊情况，将$c_2\to +\infty,\dfrac{c_2}{c_1+c_3} \to 1$ 加上。</p><h3 id="允许缺货，逐步均匀到货模型"><a href="#允许缺货，逐步均匀到货模型" class="headerlink" title="允许缺货，逐步均匀到货模型"></a>允许缺货，逐步均匀到货模型</h3><h4 id="模型基本假设-3"><a href="#模型基本假设-3" class="headerlink" title="模型基本假设"></a>模型基本假设</h4><ol><li>允许缺货</li><li>生产需一定时间，生产速度为常数 $P$</li><li>需求是连续均匀的，需求速度为常数 $R$</li><li>每次订货量不变，装配费不变</li><li>单位时间的存储费不变</li></ol><p>首先假设每次生产的装配费用为 $c_3$，单位时间内单位物品缺货费为 $c_2$，那么 $t$ 时间内平均装配费为 $\frac{c_3}{t}$，其中 $t_2$ 表示从开始到库存里有货这一段时间</p><p> $t$ 时间内的总存储费为：$\dfrac{1}{2}c_1\dfrac{R(P-R)}{P}(t-t_2)^2$</p><p> $t$ 时间内的总缺货费：$\dfrac{1}{2}c_2\dfrac{R(P-R)}{P}t_2^2$</p><p>那么我们总的费用就是三项加起来：</p><script type="math/tex; mode=display">C(t) = \frac{1}{2}c_1\frac{R(P-R)}{P}(t-t_2)^2+\frac{1}{2}c_2\frac{R(P-R)}{P}t_2^2+c_3</script><p>多元函数求极值，可得最优生产量为：$Q_0 = \sqrt{\dfrac{2c_3(c_1+c_2)PR}{c_1c_2(P-R)}}$</p><p>最大储存量为：$S_0 = \sqrt{\dfrac{2c_2c_3R(P-R)}{c_1(c_1+c_2)P}}$</p><p>最小总平均费用：$C_0 = \sqrt{\dfrac{2c_1c_2c_3R(P-R)}{c_1(c_1+c_2)P}}$</p><p>最大缺货量：$B_0 = \sqrt{\dfrac{2c_1c_3R(P-R)}{c_2(c_1+c_2)P}}$</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>存储论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分析并查集的时间复杂度</title>
    <link href="/2025/01/20/%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2025/01/20/%E5%88%86%E6%9E%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并查集的时间复杂度"><a href="#并查集的时间复杂度" class="headerlink" title="并查集的时间复杂度"></a>并查集的时间复杂度</h1><p>其实自从高二开始学习并查集就发现这个数据结构真的奇妙，能解决许多问题，但是对时间复杂度就不太理解，大二退役之后我开始想去知道为什么是这个奇妙的时间复杂度，遂有此文。</p><p>本文参考了：<a href="https://oiwiki.org/ds/dsu/">OI-Wiki</a>，<a href="https://www.coursera.org/lecture/algorithms-greedy/path-compression-the-hopcroft-ullman-analysis-i-advanced-optional-KdbbU">coursera上的算法课程</a></p><p>这里证明并没有引入势能分析，但是相关东西异曲同工。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。</p><p>并查集支持两种操作：</p><ul><li>合并（Union）：合并两个元素所属集合（合并对应的树）</li><li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li></ul><h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><p>查询：我们需要沿着树向上移动，直至找到根节点。</p><p>合并：要合并两棵树，我们只需要将一棵树的根节点连到另一棵树的根节点。</p><p>那么这样的时间复杂度有多少呢？</p><h3 id="排名（Rank）"><a href="#排名（Rank）" class="headerlink" title="排名（Rank）"></a>排名（Rank）</h3><p>对于并查集的中的每个树，其中 $V$ 是节点集合，$E$ 是边集合，$r$ 为树的叶节点，对于任意节点 $v \in V$，定义节点 $v$ 的排名 $\text{rank}$ 为：</p><ul><li>如果 $v$ 没有叶节点 ，则 $\text{rank}(v) = 0$</li><li>如果 $v$ 有叶节点 ，则 $\text{rank}(v) = \max{\text{rank}(\text{son})} + 1$</li></ul><p>某个节点到<strong>根结点</strong>的路径上的边数的<strong>最大值</strong>为排名（Rank）</p><p>注意：下面所有秩都和 $\text{rank}$ 一个意思</p><p>那么就有以下性质：</p><ol><li>对于任意节点 $x$，$\text{rank}(x)$ 只会增加</li><li>在合并时，只有根节点的 $\text{rank}(x)$ 才有可能增加</li><li>在一条路径（从下至上）中 $\text{rank}(x)$ 严格递增</li></ol><h4 id="rank-的引理-1"><a href="#rank-的引理-1" class="headerlink" title="rank 的引理 1"></a>rank 的引理 1</h4><p>对于任意的查询Find操作，该操作中生成的图 $G$，$|G| = n$，对于所有的 $r \in {1,2,3 \dots n}$，$\text{rank} = r$ 的元素个数  $\leq \frac{n}{2^r}$</p><h5 id="证明引理-1"><a href="#证明引理-1" class="headerlink" title="证明引理 1"></a>证明引理 1</h5><ol><li><p>假设一：如果两个的不相同的点的 $\text{rank}$ 相同，那么他们的子树不可能有重合部分。</p><ul><li>反证：如果有重合部分，那么一定有一个路径 $x\to z \to y$，$z$ 为重合部分，$x,y$ 为两个 rank 相同的点，那么可以得出 $x$ 和 $y$ 之间有更大的祖先，那么就有更大的 $\text{rank}$，与假设不符。</li></ul></li><li><p>假设二：$\text{rank}=x$ 的子树的元素 $\ge 2^n$（数学归纳法）</p></li></ol><p>证明：<strong>Base</strong>：$\text{rank} = 0,size =0$</p><p><strong>inductive step</strong>：</p><ol><li><p>不一样的子树大小，$\text{rank}$ 不变</p></li><li><p>一样的子树大小， $\text{rank} + 1$</p></li></ol><p>$X_s = 合并前一个子树的大小 \geq 2^r,Y_s = 合并前另一个子树的大小 \geq 2^r$</p><p>合并后，Union(x,y)得到了新祖先 $Z$，$\text{rank}(z) = r+1$</p><p>$Z_s \geq 2^r + 2^r \geq 2^{r+1}$，假设二证明完毕</p><p>现在我们来证明引理 1：n 个元素，我们设<strong>每个</strong> $\text{rank}=x$ 的子树的大小为 $x$，假设二可知，$x \geq 2^r$</p><p>我们两边取倒数，并且同时乘一个 n，那么可以得出 $\dfrac{n}{x} \leq \dfrac{n}{2^r}$，那么可以看出左边就是 $\text{rank} = r$ 的元素个数，引理 1 也证明完毕了。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>证明了这么多，我们也能看出来 $\text{rank}$ 其实就是一个子树的深度，也是我们最多要查询的次数。</p><p>首先，$最大\text{rank}的个数=祖先的个数=1$，显然，那么根据引理1，得出：</p><script type="math/tex; mode=display">1 \leq \frac{n}{2^r} \ \Rightarrow 2^r \leq n \Rightarrow r \leq \log_{2}n</script><p>那么我们可以得到查询和合并的时间复杂度为 $O(\log_{2} n)$</p><h2 id="路径压缩-启发式合并（按秩合并）"><a href="#路径压缩-启发式合并（按秩合并）" class="headerlink" title="路径压缩+启发式合并（按秩合并）"></a>路径压缩+启发式合并（按秩合并）</h2><p>上面的朴素算法已经很快了，但是考虑一种可能，如果这个不是一个正常的树，而是一条链，而我们正常的去查询最底下的节点，那么复杂度将会退化成 $O(n)$，这并不是我们想要的，想到我们查询时有许多地方时冗余的，我们就想到了路径压缩。</p><p><strong>路径压缩</strong>：查询过程中经过的每个元素都属于该集合，我们可以将其直接连到根节点以加快后续查询。</p><p>在合并时我们又想到了这两个的 $\text{rank}$ 不同也会导致路径压缩的时候会多了一些不该有的操作。</p><p><strong>启发式合并（按秩合并）</strong>：合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。</p><p>另一种做法则是使用“秩”来比较树的大小。”秩“的定义如下：</p><ul><li>只有根节点的树（即只有一个元素的集合），秩为0；</li><li>当两棵秩不同的树合并后，新的树的秩为原来两棵树的秩的较大者；</li><li>当两棵秩相同的树合并后，新的树的秩为原来的树的秩加一。</li></ul><p>容易发现，在没有路径压缩优化时，树的秩等于树的深度减一。在有路径压缩优化时，树的秩仍然能反映出树的深度和大小。在合并时根据两棵树的秩的大小，决定新的根节点，这被称作<strong>按秩合并</strong>。</p><h3 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h3><p><strong>注意：经过路径压缩过时，$\text{rank}$ 不变，相当于被冻结了，不管压缩到哪都不会改变</strong></p><p><strong>内容：</strong>通过“按秩合并”和“路径压缩”优化后，进行 $m$ 次合并+查询的操作的时间复杂度为 $O(m \log^<em> n)$，其中 $\log^</em> n$ 表示对 $n$ 反复应用对数运算，直到结果小于等于 1 所需要的次数，一般叫迭代对数。</p><div class="table-container"><table><thead><tr><th>$x$</th><th>$\lg^* x$</th></tr></thead><tbody><tr><td>$(−\infty, 1]$</td><td>$0$</td></tr><tr><td>$(1, 2]$</td><td>$1$</td></tr><tr><td>$(2, 4]$</td><td>$2$</td></tr><tr><td>$(4, 16]$</td><td>$3$</td></tr><tr><td>$(16, 65536]$</td><td>$4$</td></tr><tr><td>$(65536, 2^{65536}]$</td><td>$5$</td></tr></tbody></table></div><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>首先我们来定义一个 $\text{rank\, blocks}$（秩块）；${0},{1},{2,3,4},{5,\dots, 2 4 },{17,18,\dots,2^{16}},<br>{65537,\dots,2^{65536}},\dots,{\dots,n}$</p><p>很显然这些块只会有 $O(\log^* n)$ 个。</p><p>我们给每个节点分类，我们现在称一个节点 $x$（可变）是好的当：</p><ol><li>$x$ 或者 $x$ 的父节点为根节点</li><li>父亲的 $\text{rank}$ 比自己的 $\text{rank}$ 大。 <strong>注意：$\text{rank} 不变$</strong></li></ol><p>如果两个条件都不符合，那么就是坏节点。</p><p><strong>我们会尽量将一个节点变成好节点。</strong></p><p>第一个要点：要点：每次查找操作只会访问 $O(\log^<em> n)$ 个好节点 （计算方式为 $2 + 秩块的数量 = O(\log^</em> n)$）</p><p>结论：在 $m$ 次操作中完成的总工作量可以表示为两种：</p><ul><li>$O(m \log^* n)$（访问好节点的次数）</li><li>访问坏节点的总次数，下面就来论证。</li></ul><p>首先我们思考，在路径压缩中，其父节点被更改为具有严格更大 $\text{rank}$ 的节点，这种情况最多只会发生 $2^k$ 次，之后 $x$ 将永久成为“好节点”。（很显然，在路径压缩中，那个节点相当于在往上跳，最多跳到这个 block 的第一个）</p><p>总时间复杂度：$O(m \log^* n) + O(访问坏节点的次数)$。</p><p>我们对一个秩块 ${k+1, k+2, \dots, 2^k}$ 分析：</p><p>对于每个最终秩处于此块的 $x$，当 $x$ 是“坏节点”时的访问次数最多为 $2^k$。</p><p>具有最终 $\text{rank}$ 处于此块的对象总数为：</p><script type="math/tex; mode=display">\sum_{i=k+1}^{2^k} \frac{n}{2^i} \leq \frac{n}{2^k}</script><p>因此，此秩块中对“坏节点”的访问总次数最多为 $n$。</p><p>因为只有 $O(\log^* n)$ 个秩块。</p><p><strong>总时间复杂度</strong>：</p><p>$O((m + n) \log^<em> n)$，在正常操作中 $m$ 与 $n$ 同阶，就可以是 $O(m \log^</em> n)$，证明完毕。 </p><h3 id="Tarjan’s-Bound"><a href="#Tarjan’s-Bound" class="headerlink" title="Tarjan’s Bound"></a>Tarjan’s Bound</h3><p>该证明在1975年由Tarjan完成，后在1989年，由Fredman证明该结构下无法找到更好的时间复杂度</p><p><strong>内容</strong>：通过“按秩合并”和“路径压缩”优化后，进行 $m$ 次合并和查找操作的时间复杂度为 $O(m \alpha(n))$，其中 $\alpha(n)$ 是反阿克曼函数。</p><h4 id="阿克曼函数"><a href="#阿克曼函数" class="headerlink" title="阿克曼函数"></a>阿克曼函数</h4><p>需要两个自然数作为输入值，输出一个自然数，它的输出值增长速度非常高。</p><p>定义：</p><script type="math/tex; mode=display">A(m,n) = \begin{cases}n + 1 & \text{如果 m=0} \\ A(m-1,1) & \text{如果 m>0 且 n=0} \\ A(m-1,A(m,n-1)) & \text{如果 m>0 且 n>0 }\end{cases}</script><p>由于这个函数的增加速率非常快，那么它的反函数就相应的增长的非常慢。</p><p><strong>反函数的定义</strong>：对于每个 $n \geq 4$，$\alpha(n)$ 是满足 $A_k(2) \geq n$ 的最小 $k$ 值，其中 $A_k(2)$ 是阿克曼函数。</p><blockquote><p>$\alpha(n) = 1 \Rightarrow n=4$</p><p>$\alpha(n) = 2 \Rightarrow n=5 \dots 8$</p><p>$\alpha(n) = 3 \Rightarrow n=9 ,10\dots 2048$</p><p>$\alpha(n) = 4 \Rightarrow n=4\dots n(n 满足 \log^*n= 2048)$</p><p>$\cdots$</p></blockquote><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>我们定义 $x$ 为不是根节点 $\delta(x)$ 是最大的 $k$ 使得 $\text{rank}(\text{parent}[x]) \geq A_k(\text{rank}(x))$</p><p>显然， $\delta(x)$ 是递增的。</p><p>这里有一个性质：只要 $\text{rank} \geq 2$ 的点，那么一定会有 $\delta(x) \leq \alpha(n)$</p><p>证明：</p><script type="math/tex; mode=display">A_{\alpha(n)}(2) \geq n \geq \text{rank}(parent[x]) \geq A_k(\text{rank}(x))</script><p>其中 $n \geq \text{rank}(parent[x])$ 很显然一定成立，左边其实就是上面反函数的定义，右边就是 $\delta(x)$ 的定义，最左边与最右边分别进行反函数，即证成立。</p><p>这里我们继续定义好节点与坏节点：</p><p>一个点为好的节点当且仅当符合下面几个条件，我们称这个节点为坏节点：</p><ol><li>$x$ 不是根节点</li><li>它的父亲不是根节点</li><li>$\text{rank}(x) \geq 2$</li><li>$x$ 存在祖先 $y$ 使得 $\delta(y) = \delta(x)$</li></ol><p>否则，$x$ 是好的节点。</p><p>同 Hopcroft-Ullman 类似，在一次路径中最多有 $\Theta(\alpha(n)) \leq 2 +2 +\alpha(n)$ 个好节点。</p><p>那么最终 $m$ 次操作（合并与查询）的总时间复杂度：$O(m\alpha(n))(访问好节点的次数)+访问坏节点的次数$</p><p>下面我们来计算一下这个坏节点的个数，我们同样只先看一次路径的：</p><p><img src="https://s2.loli.net/2025/01/23/rWEjnAXFbfmUO8w.png" alt="A path"></p><p>路径压缩：$p’$ 是 $x$ 的新父亲或者更向上，则有：</p><script type="math/tex; mode=display">\text{rank}(x的新父亲) \geq \text{rank}(p') \geq A_k(\text{rank}(y)) \geq A_k(\text{rank}(p))</script><p>中间这个过渡我们用到了上面 $\delta(x)$ 的定义，其他的都很显然。</p><p>假设 $r = \text{rank}(x)$，然后我们对 $x$ 做 $r$ 次查找（<strong>路径压缩</strong>），假设每次都是有用的，那么我的 $\delta(x)$ <strong>至少</strong> $+1$</p><p>为什么？我们不从理性的（数学的）角度去分析，而是去从感性的角度，首先想 $\text{rank}(x) = 0，1$，显然根据定义，本身就是好节点，成立。</p><p>那么 $\text{rank}(x) \geq 2$ 呢？压缩一次会压缩到好节点的同地方，下一次必然会压缩到下一个 $\delta(x) + 1$ 中，所以的证，而且是<strong>至少</strong>。</p><p>那最多可以加多少次 1 呢？$\alpha(n)$ 次</p><p>那么 $x$ 是坏的 $\leq r \alpha(n)$</p><p>那么我们开始算总共访问坏节点的次数：</p><script type="math/tex; mode=display">\begin{align*}&总共访问坏节点的次数  \\ &\leq \Sigma_{所有节点}\text{rank}(x) \cdot \alpha(n) \tag 1\\&= \alpha(n) \cdot \Sigma_{r \geq 0} \,r \,(\text{rank}=r 节点的个数) \tag2\\&\leq n \alpha(n) \Sigma_{r \geq 0} \frac{r}{2^r} \tag 3\\&= O(n \alpha(n))\end{align*}</script><p>我们来解释一下这个东西怎么来的，在 $(2) \to (3)$ 中的推导中我们用到了 rank 的引理 1，不理解的可以倒回去看看，这里我们对每个 $r$ 都用了一个引理 1 并相加，$(3)$ 中的 $\Sigma_{r \geq 0} \frac{r}{2^r}$，其实是个几何级数，最后是个常数，可以省略，就得到了坏节点的次数。</p><p>那么我们能得出总共的时间复杂度为：</p><p>$O((n+m) \alpha(n))$，同样在正常操作中 $m$ 与 $n$ 同阶，就可以是 $O(m \alpha(n))$，证明完毕。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>时间复杂度分析</tag>
      
      <tag>数学归纳法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图与网络分析基础</title>
    <link href="/2025/01/18/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/01/18/%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>没想到没几天又开始学到算法部分了，这一次定义将会学习的更加严谨。按照书上的拓展学习。</p><h1 id="图的相关概念"><a href="#图的相关概念" class="headerlink" title="图的相关概念"></a>图的相关概念</h1><p><strong>图 (graph)</strong> 是一个二元组 $G=(V(G), E(G))$。其中 $V(G)$ 是非空集，称为 <strong>点集</strong>，对于 $V$ 中的每个元素，我们称其为 <strong>顶点</strong> 或 <strong>节点</strong>，简称 <strong>点</strong>；$E(G)$ 为 $V(G)$ 各结点之间边的集合，称为 <strong>边集</strong>。</p><p>常用 $G=(V,E)$ 表示图。</p><p>当 $V,E$ 都是有限集合时，称 $G$ 为 <strong>有限图</strong>。</p><p>当 $V$ 或 $E$ 是无限集合时，称 $G$ 为 <strong>无限图</strong>。</p><p>图有多种，包括 <strong>无向图</strong>，<strong>有向图</strong>，<strong>混合图</strong> 等。</p><p>若 $G$ 为无向图，则 $E$ 中的每个元素为一个无序二元组 $(u, v)$，称作 <strong>无向边</strong>，简称 <strong>边</strong>，其中 $u, v \in V$。设 $e = (u, v)$，则 $u$ 和 $v$ 称为 $e$ 的 <strong>端点</strong>。</p><p>若 $G$ 的每条边 $e_k=(u_k,v_k)$ 都被赋予一个数作为该边的 <strong>权</strong>，则称 $G$ 为 <strong>赋权图</strong>。如果这些权都是正实数，就称 $G$ 为 <strong>正权图</strong>。与一个顶点 $v$ 关联的边的条数称作该顶点的 <strong>度</strong>，记作 $d(v)$。特别地，对于边 $(v, v)$，则每条这样的边要对 $d(v)$ 产生 $2$ 的贡献。</p><p>对于一张无向图 $𝐺=(𝑉,𝐸)$，对于 $𝑢,𝑣∈𝑉$，若存在一条途径使得 $𝑣=𝑢,𝑣𝑘=𝑣$，则称 𝑢 和 𝑣 是 <strong>连通的</strong>。由定义，任意一个顶点和自身连通，任意一条边的两个端点连通。</p><p>若无向图 $𝐺=(𝑉,𝐸)$，满足其中任意两个顶点均连通，则称 $𝐺$ 是 <strong>连通图</strong>，$𝐺$ 的这一性质称作 <strong>连通性</strong>。</p><p>最基本的就这些了。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>一个无圈的连通图称为<strong>树</strong>。</p><p>给了一个无向图$G=(V,E)$，保留 $G$ 的所有点，而删掉部分 $G$，的边或者说保留一部分 $G$ 的边，所获得的图称为$G$的<strong>生成子图</strong>。如果 $G$ 的生成子图是一个树，则称这个生产子图为一个生成树。</p><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>在一个赋权图的联通的无向图 $G$ 中找一个生成树，并使得这个生成树的所有边的权数之和最小。</p><h4 id="Kruskal-算法求最小生成树"><a href="#Kruskal-算法求最小生成树" class="headerlink" title="Kruskal 算法求最小生成树"></a>Kruskal 算法求最小生成树</h4><p>基本思想是从小到大加入边，是个贪心算法。</p><ol><li>新建图 $G$，$G$ 中拥有原图中相同的节点，但没有任何边。</li><li>将原图中所有的边按权值从小到大排序。</li><li>从权值最小的边开始，如果这条边连接的两个节点于图 $G$ 中不在同一个连通分量（不是联通的）中，则添加这条边到图 $G$ 中。</li><li>重复3，直到 $G$ 中所有的节点都在同一个联通分量中。</li></ol><p>伪代码：</p><figure class="highlight oxygene"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs oxygene">KRUSKAL-<span class="hljs-function"><span class="hljs-keyword">FUNCTION</span><span class="hljs-params">(G, w)</span></span><br><span class="hljs-function">    <span class="hljs-title">F</span> :</span>= 空集合<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> 图 G 中的顶点 v<br>        <span class="hljs-keyword">do</span> 将 v 加入森林 F<br>    所有的边(u, v) ∈ E依权重 w 递增排序<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> 边(u, v) ∈ E<br>        <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> u 和 v 不在同一棵子树<br>            <span class="hljs-keyword">then</span> F := F ∪ <span class="hljs-comment">&#123;(u, v)&#125;</span><br>                将 u 和 v 所在的子树合并<br></code></pre></div></td></tr></table></figure><p>通过使用路径压缩的并查集，平均时间复杂度为$O(\left| E \right| \log \left| V \right|)$，其中 $E,V$ 分别是图的边集和点集。</p><p>还有如果同时使用路径压缩和按秩合并的并查集，时间复杂度可以优化到$O(\left| E \right| \alpha( \left| V \right|))$，其中 $\alpha$ 表示反阿克曼函数。</p><h4 id="反阿克曼函数"><a href="#反阿克曼函数" class="headerlink" title="反阿克曼函数"></a>反阿克曼函数</h4><p>定义：</p><script type="math/tex; mode=display">A(m,n) = \begin{cases}n + 1 & \text{如果 m=0} \\ A(m-1,1) & \text{如果 m>0 且 n=0} \\ A(m-1,A(m,n-1)) & \text{如果 m>0 且 n>0 }\end{cases}</script><p>由于这个函数的增加速率非常快，那么它的反函数就相应的增长的非常慢。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了 $n-1$ 条边，即形成了一棵树。</p><p>证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。</p><p>基础：对于算法刚开始时，显然成立（最小生成树存在）。</p><p>归纳：假设某时刻成立，当前边集为 $F$，令 $T$ 为这棵 MST，考虑下一条加入的边 $e$。</p><p>如果 $e$ 属于 $T$，那么成立。</p><p>否则，$T+e$ 一定存在一个环，考虑这个环上不属于 $F$ 的另一条边 $f$（一定只有一条）。</p><p>首先，$f$ 的权值一定不会比 $e$ 小，不然 $f$ 会在 $e$ 之前被选取</p><p>然后，$f$ 的权值一定不会比 $e$ 大，不然 $T+e-f$ 就是一棵比 $T$ 还优的生成树了。</p><p>所以，$T+e-f$ 包含了 $F$，并且也是一棵最小生成树，归纳成立。</p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p>最短路问题是指对一个赋权的有向图 $D$ 中指定的两点 $v_s$ 和 $v_t$，找到一条从 $v_s$ 到 $v_t$ 的路，使得这条路上所有弧的总和最小，这条路被称为从 $v_s$ 到 $v_t$ 的最短路。这条路上所有弧的权数的总和被称为从 $v_s$ 到 $v_t$ 的距离。</p><p>我们一般讨论单源的最短路，全源最短路径得用 Floyd 算法以及 Johnson 全源最短路径算法，这里不再讨论。</p><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959 年公开发表。是一种求解 <strong>非负权图</strong> 上单源最短路径的算法。</p><h4 id="松弛"><a href="#松弛" class="headerlink" title="松弛"></a>松弛</h4><p>对于边 $(u,v)$，松弛操作对应下面的式子：$dis(v) = \min(dis(v), dis(u) + w(u, v))$。</p><p>$dis(v)$ 表示的含义是起点开始，到 $v$ 的最短路径，$w(u,v)$ 表示边 $(u,v)$ 的权值 $w$。</p><p>这么做的含义是显然的：我们尝试用 $S \to u \to v$（其中 $S \to u$ 的路径取最短路）这条路径去更新 $v$ 点最短路的长度，如果这条路径更优，就进行更新。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>将结点分成两个集合：已确定最短路长度的点集（记为 $S$ 集合）的和未确定最短路长度的点集（记为 $T$ 集合）。一开始所有的点都属于 $T$ 集合。</p><p>初始化 $dis(s)=0$，其他点的 $dis$ 均为 $+\infty$。</p><p>然后重复这些操作：</p><ol><li>从 $T$ 集合中，选取一个最短路长度最小的结点，移到 $S$ 集合中。</li><li>对那些刚刚被加入 $S$ 集合的结点的所有出边执行<strong>松弛</strong>操作。</li></ol><p>直到 $T$ 集合为空，算法结束。</p><h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p> $D(u)$ 为 $s$ 点到 $u$ 点的 <strong>实际</strong> 最短路长度。</p><p>下面用数学归纳法证明，在 <strong>所有边权值非负</strong> 的前提下，Dijkstra 算法的正确性。</p><p>简单来说，我们要证明的，就是在执行 1 操作时，取出的结点 $u$ 最短路均已经被确定，即满足 $D(u) = dis(u)$。</p><p>初始时 $S = \varnothing$，假设成立。</p><p>接下来用反证法。</p><p>设 $u$ 点为算法中第一个在加入 $S$ 集合时不满足 $D(u) = dis(u)$ 的点。因为 $u$ 点一定满足 $D(u)=dis(u)=0$，且它一定是第一个加入 $S$ 集合的点，因此将 $u$ 加入 $S$ 集合前，$S \neq \varnothing$，如果不存在 $s$ 到 $u$ 的路径，则 $D(u) = dis(u) = +\infty$，与假设矛盾。</p><p>于是一定存在路径 $s \to x \to y \to u$，其中 $y$ 为 $s \to u$ 路径上第一个属于 $T$ 集合的点，而 $x$ 为 $y$ 的前驱结点（显然 $x \in S$）。需要注意的是，可能存在 $s = x$ 或 $y = u$ 的情况，即 $s \to x$ 或 $y \to u$ 可能是空路径。</p><p>因为在 $u$ 结点之前加入的结点都满足 $D(u) = dis(u)$，所以在 $x$ 点加入到 $S$ 集合时，有 $D(x) = dis(x)$，此时边 $(x,y)$ 会被松弛，从而可以证明，将 $u$ 加入到 $S$ 时，一定有 $D(y)=dis(y)$。</p><p>下面证明 $D(u) = dis(u)$ 成立。在路径 $s \to x \to y \to u$ 中，因为图上所有边边权非负，因此 $D(y) \leq D(u)$。从而 $dis(y) = D(y) \leq D(u)\leq dis(u)$。但是因为 $u$ 结点在 1 过程中被取出 $T$ 集合时，$y$ 结点还没有被取出 $T$ 集合，因此此时有 $dis(u)\leq dis(y)$，从而得到 $dis(y) = D(y) = D(u) = dis(u)$，这与 $D(u)\neq dis(u)$ 的假设矛盾，故假设不成立。</p><p>因此我们证明了，1 操作每次取出的点，其最短路均已经被确定。命题得证。</p><p>注意到证明过程中的关键不等式 $D(y) \leq D(u)$ 是在图上所有边边权非负的情况下得出的。当图上存在负权边时，这一不等式不再成立，Dijkstra 算法的正确性将无法得到保证，算法可能会给出错误的结果。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$|E|$ 表示边数，$|V|$ 顶点数</p><p>朴素方法：$O(|E|^2)$</p><p>使用二叉堆优化方法：$O((|E| + |V|) \log |V|)$</p><h2 id="网络流问题"><a href="#网络流问题" class="headerlink" title="网络流问题"></a>网络流问题</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>网络是指一个特殊的有向图 $G=(V,E)$，其与一般有向图的不同之处在于有容量和源汇点。</p><ul><li>$E$ 中的每条边 $(u, v)$ 都有一个被称为容量的权值，记作 $c(u, v)$。当 $(u,v)\notin E$ 时，可以假定 $c(u,v)=0$。</li><li>$V$ 中有两个特殊的点：源点 $s$ 和汇点 $t$（$s \neq t$）。</li></ul><p>对于网络 $G=(V, E)$，流是一个从边集 $E$ 到整数集或实数集的函数，其满足以下性质。</p><ol><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 $0 \leq f(u,v) \leq c(u,v)$；</li><li>流守恒性（平衡条件）：除源汇点外，任意结点 $u$ 的净流量为 $0$（输入量等于输出量）。其中，我们定义 $u$ 的净流量为 $f(u) = \sum<em>{x \in V} f(u, x) - \sum</em>{x \in V} f(x, u)$。</li></ol><p>定义网络 $D$，若 $\mu$ 为网络中的一条链，给 $\mu$ 定向为从 $u<em>s$ 到 $u_t$，$\mu$ 上的弧凡与 $\mu$ 同向称为前向弧，反向为后向弧，其集合分别用 $\mu^+$ 和 $\mu ^-$ 表示。设 $f={f</em>{ij}}$ 是一个可行流，如果满足</p><script type="math/tex; mode=display">\begin{cases} 0 \leq f_{ij} \leq c_{ij} & (v_i,v_j) \in \mu^+ \\ c_{ij} \geq f_{ij} > 0 & (v_i,v_j) \in \mu^- \end{cases}</script><p>则称 $\mu$ 为从 $v_s$ 到 $v_t$ 的一条增广链。</p><p>对于给定网络 $G=(V,E,C)$ ，设 $S,T \subset V$ ，且 $S\cup T=V,S \cap T = \varnothing,v_s\in S,v_t\in T$ ，则称 $(S,T)$ 为割集</p><p>残量网络：根据原网络，定义的一个可描述每条边当前可调配流量的网络图，其中<strong>可调配残量</strong> $r(u,v)=c(u,v)−f(u,v)$ ，表明每条弧还能再有多 少流量经过。</p><h3 id="网络最大流问题（标号法）"><a href="#网络最大流问题（标号法）" class="headerlink" title="网络最大流问题（标号法）"></a>网络最大流问题（标号法）</h3><p>最大流问题：对于网络 $G = (V, E)$，给<strong>每条边指定流量</strong>，得到合适的流 $f$，使得 $f$ 的流量尽可能大。此时我们称 $f$ 是 $G$ 的最大流。</p><p>这里我们只讨论运筹书上写的标号法求最大流，不讨论更深入的。</p><h4 id="标号过程"><a href="#标号过程" class="headerlink" title="标号过程"></a>标号过程</h4><ol><li><p>源点 $v_s$ 标号$(0,+\infty)$</p></li><li><p>不断选择一个已标号的顶点 $v_i$ ，对所有与 $v_i$ 相邻而没有标号的顶点 $v_j$ 按如下规则处理：</p><ul><li><p>若 $(v<em>i,v_j)\in E$ ，并且 $f</em>{ij}&lt;c<em>{ij}$ ，则给顶点 $v_j$ 标号 $(v_i,\delta_j),\delta_j=\min(\delta_i,c</em>{ij}−f_{ij})$</p></li><li><p>若 $(v<em>j,v_i)\in E$ ，并且 $f</em>{ij}&gt;0$，则给顶点 $v<em>j$ 标号 $(v_i,\delta_j),\delta_j=\ min(\delta_i,f</em>{ji})$</p></li></ul></li><li><p>当无法选择后，若终点 $v_i$ 得到标号，说明存在增广链，转到调整阶段，否则说明不存在增广链，此时可行流 $f$ 即为最大流</p></li></ol><h4 id="调整过程"><a href="#调整过程" class="headerlink" title="调整过程"></a>调整过程</h4><ul><li>应用反向追踪法，从终点 $v_t$ 及其其他顶点的第一个标号，找出增广链</li><li>调整结束后去掉所有标号，再次进行标号过程。</li></ul><h3 id="最小费用最大流问题"><a href="#最小费用最大流问题" class="headerlink" title="最小费用最大流问题"></a>最小费用最大流问题</h3><p>最小费用最大流问题：在网络 $G = (V, E)$ 上，对每条边给定一个权值 $w(u, v)$，称为费用（cost），含义是单位流量通过 $(u, v)$ 所花费的代价。对于 $G$ 所有可能的最大流，我们称其中总费用最小的一者为最小费用最大流。</p><h4 id="增流网络"><a href="#增流网络" class="headerlink" title="增流网络"></a>增流网络</h4><p><strong>顶点</strong>：增流网络 $D_f$ 的顶点与原网络相同</p><p><strong>弧与权</strong>：</p><ul><li>在 D 中的弧 $(v<em>i,v_j)$ 若为<strong>零流弧</strong>，即 $f</em>{ij} = 0$ ，则在 $D<em>f$ 中构建一个同向的弧，$c</em>{ij}^, = c<em>{ij} - f</em>{ij},b<em>{ij}^, = b</em>{ij}$</li><li>在 D 中的弧 $(v<em>i,v_j)$ 若为<strong>饱和弧</strong>，即 $f</em>{ij} = c<em>{ij}$ ，则在 $D_f$ 中构建一个反向的弧，$c</em>{ij}^, = c<em>{ij} ,b</em>{ij}^, = -b_{ij}$</li><li>在 D 中的弧 $(v<em>i,v_j)$ 若为<strong>非饱和弧</strong>，即 $f</em>{ij} &lt; 0$ ，则在 $D<em>f$ 中构建一个同向的弧和反向的弧，同向的弧$c</em>{ij}^, = c<em>{ij} - f</em>{ij},b<em>{ij}^, = b</em>{ij}$，反向的弧 $c<em>{ij}^, = c</em>{ij} ,b<em>{ij}^, = -b</em>{ij}$</li></ul><h4 id="增流圈"><a href="#增流圈" class="headerlink" title="增流圈"></a>增流圈</h4><p>在增流网络 $D_f$ 中的负回路对应网络 $D$ 中的一个圈，在这个圈中，如果方向与负回路方向相同的所有弧都为不饱和弧，方向与负回路方向相反的所有弧都为非零流弧，则这个圈被称为增流圈。</p><h4 id="算法实际过程"><a href="#算法实际过程" class="headerlink" title="算法实际过程"></a>算法实际过程</h4><ol><li>利用最大流算法，将网络的流量调整到最大流</li><li>构建伴随网络流f的增流网络 $D_f$</li><li>在增流网络 $D<em>f$ 中，查找关于费用的负回路，令$\theta = \min c</em>{ij}^,$($c_{ij}^,$ 为负回路中各弧的容量)，若不存在负回路，则说明当前网络流已经是最小费用流，结束算法</li><li>针对负回路对应网络 $D$ 中的圈，若该圈是增流圈，则把增流圈方向上与负回路方向一若该圈致的所有弧的流量加上 $\theta$，把增流圈方向上与负回路方向相反的所有弧的流量减去 $\theta$ 不是增流圈，则转到 3 重新寻找负回路</li><li>继续寻找负回路，如果还有负回路，继续调整；否则返回 2</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络流</tag>
      
      <tag>图</tag>
      
      <tag>生成树</tag>
      
      <tag>最短路</tag>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正大杯随笔</title>
    <link href="/2025/01/18/%E6%AD%A3%E5%A4%A7%E6%9D%AF%E9%9A%8F%E7%AC%94/"/>
    <url>/2025/01/18/%E6%AD%A3%E5%A4%A7%E6%9D%AF%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天正好在学习正大杯的一些知识，正好就来做一些笔记。</p><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>数据去重：去除数据集中的重复记录。这可以通过比较记录中的唯一标识符或关键字段来实现。</p><p>缺失值处理：填补数据集中的缺失值。这可以使用插值、平均值、中位数、众数等方法进行处理。</p><p>异常值处理：检测和处理数据集中的异常值。异常值可以被删除或替换为可接受的值。</p><p>数据标准化：将数据格式标准化为一致的格式，以便于处理和分析。例如，可以将日期格式标准化为ISO格式。</p><p>数据转换：数据转换实质上是将数据的格式进行转换，其目的主要是为了便于处理和分析数据。例如，将文本格式的日期转换为日期格式。</p><p>数据验证：确保数据集中的数据准确性和完整性。</p><h2 id="信度分析"><a href="#信度分析" class="headerlink" title="信度分析"></a>信度分析</h2><p>信度，又叫可靠性，可检验同一事物重复测量结果的一致性程度，其与测量结果的正确与否无关，而是反映测量工具（如调查问卷）的稳定性或可靠性，一般用信度系数表示。</p><p>一般而言，如果信度系数达到 0.9 以上，表示该测验或量表的信度很好；信度系数在 0.8 以上，表示可以接受；如果在 0.7 以上，则应该对该测量工具进行修订，但仍不失其价值；如果低于 0.7，则此量表的调查结果很不可信，需要重新设计量表。</p><h3 id="科隆巴赫系数（Cronbach’s-alpha）"><a href="#科隆巴赫系数（Cronbach’s-alpha）" class="headerlink" title="科隆巴赫系数（Cronbach’s alpha）"></a>科隆巴赫系数（Cronbach’s alpha）</h3><p>科隆巴赫系数也叫 $\alpha$ 信度系数：</p><script type="math/tex; mode=display">\alpha = \dfrac{k}{k-1}(1 - \dfrac{\Sigma^{k}_{1} S^2_i}{S^2_x})</script><p>式中 $k$ 为题目个数，$S^2_i$ 第 $i$ 题得分的方差，$S^2_x$ 为测验总得分的总方差。</p><p>$\alpha$ 信度系数与量表的题目数量关系密切。如果一个含有约 10 个题目的量表，$\alpha$ 系数应能达到 0.8 以上；如果量表的题目增加，$\alpha$ 系数会随之升高，当题目多于 20 个时，$\alpha$ 系数会很容易地升至 0.9 以上；如果量表的题目减少，$\alpha$ 系数会随之降低。</p><h2 id="效度分析"><a href="#效度分析" class="headerlink" title="效度分析"></a>效度分析</h2><p>效度是指测量的有效性程度，是测量工具能测出所要测量特质的程度，即准确性、有用性。</p><p>在测量理论中，效度被定义为在一系列测量中，与测量目的有关的真实方差与实得分数方差的比率：</p><script type="math/tex; mode=display">r_{xv}^{2} = \dfrac{\sigma_v^2}{\sigma_x^2}</script><p>其中 $r_{xv}$ 为测量的效度系数，$\sigma_v^2$ 表示真实方差，$\sigma_x^2$ 表示实得分数方差。一般使用因子分析模型，采用 KMO 和 Bartlett 球形度检验。</p><h2 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h2><ol><li>需要对于所有问卷进行筛选，对于前后答案明显不一致，逻辑矛盾的<br>问卷，我们会将问卷作为无效问卷处理。</li><li>当发现无效问卷较多时，需要发放更多的问卷保证样本量，并及时对于所<br>收集的数据进行整理和汇总，直至满足所需要的样本量。</li></ol><h2 id="对于收集的问卷信息的分析（因子分析法）"><a href="#对于收集的问卷信息的分析（因子分析法）" class="headerlink" title="对于收集的问卷信息的分析（因子分析法）"></a>对于收集的问卷信息的分析（因子分析法）</h2><h3 id="合适度和效果检验"><a href="#合适度和效果检验" class="headerlink" title="合适度和效果检验"></a>合适度和效果检验</h3><p>使用 KMO 统计量来调查是否能存在相关关系。变量共同度分析是为查看原始变量能被提取的因子所表示的程度。在这之前我们得让变量标准化，以消除量纲的影响。</p><h4 id="KMO"><a href="#KMO" class="headerlink" title="KMO"></a>KMO</h4><p>KMO 是 Kaiser-Meyer-Olkin 的取样适当性量数，当 KMO 值愈大时，表示变量间的共同因素愈多，愈适合进行因素分析，根据专家 Kaiser（1974）观点，如果 KMO 的值小于 0.5 时，较不宜进行因素分析，</p><h4 id="标准化变量"><a href="#标准化变量" class="headerlink" title="标准化变量"></a>标准化变量</h4><p>对于样本序列$ x_1,x_2,\dots, x_n$进行标准化，有</p><script type="math/tex; mode=display">y_i = \frac{x_i - \bar x}{s_i}</script><p>产生的$y_1,y_2,\dots,y_n$ 是均值为 0，方差为 1，无量纲的数据。</p><h3 id="累计方差贡献率分析"><a href="#累计方差贡献率分析" class="headerlink" title="累计方差贡献率分析"></a>累计方差贡献率分析</h3><p>如果变量的累计方差贡献率较大，说明因子对于变量的解释能力非常好。</p><h3 id="成分矩阵"><a href="#成分矩阵" class="headerlink" title="成分矩阵"></a>成分矩阵</h3><p>成分矩阵显示的是旋转之前的因子载荷矩阵，其中有些变量在各因子上的载荷比较接近，难以对因子进行明确定义，因此，对于因子解释和命名更有指导意义的是旋转后的成分矩阵。</p><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><p>聚类分析是统计学中研究“物以类聚”问题的多元统计分析方法。</p><p>对个案进行分类：Q型聚类（平方欧式距离）</p><p>对变量进行分类：R型聚类（皮尔逊相关性）</p><h4 id="聚类的好不好？"><a href="#聚类的好不好？" class="headerlink" title="聚类的好不好？"></a>聚类的好不好？</h4><ul><li>能不能给每一类起一个名字？（显著的特征）</li><li>ANOVA显示两个或多个类别的群体，在各个变量上是否有差异，有差异说明聚类相对成功。</li><li>每个类别各有多少被试，最好比较均匀</li></ul><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="SWOT分析法"><a href="#SWOT分析法" class="headerlink" title="SWOT分析法"></a>SWOT分析法</h3><p>所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>S （Strengths）是优势、W （Weaknesses）是劣势、O （Opportunities）是机会、T （Threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。</p><h4 id="多重响应分析"><a href="#多重响应分析" class="headerlink" title="多重响应分析"></a>多重响应分析</h4><p>多重相应分析一般用于多选题的分析，一般有三种：</p><ul><li>一道多选题，每个选项用一列表示，0表示未选，1表示已选；</li><li>一道排序题，存在选项先后次序，每个选项用一列表示，列值对应选项的次序；</li><li>一道多选题，存在选项先后次序，每个次序用一列表示，列值对应选择的选项。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>市场调研大赛</tag>
      
      <tag>SPSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划基础</title>
    <link href="/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/13/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性规划基础"><a href="#线性规划基础" class="headerlink" title="线性规划基础"></a>线性规划基础</h1><p>线性规划是统筹学中最重要的一种系统优化方案，引用领域十分广泛，包括生产计划、物资调运、任务分配、资源优化配置、经济规划等问题。也有许多线性规划的应用，我们这里就用COPT的规划求解器去学习使用。</p><h2 id="线性规划的基本定义"><a href="#线性规划的基本定义" class="headerlink" title="线性规划的基本定义"></a>线性规划的基本定义</h2><p>一般形式为：</p><p>$\max (\min) z = c_1x_1+c_2x_2+ \cdots  +c_nx_n$</p><p>$s.t. \begin{cases}  a<em>{11}x_1+a</em>{12}x<em>2+\cdots + c</em>{1n}x<em>n = b_1 \ a</em>{21}x<em>1 + a</em>{22}x<em>2 + \cdots+c</em>{2n}x_n = b_2 \ \cdots \ x_1,x_2,x_3\cdots x_n \geq 0 \end{cases}$</p><p>其中$\max (\min) z = c_1x_1+c_2x_2+ \cdots  +c_nx_n$ 称为目标函数，</p><p>$a<em>{11}x_1+a</em>{12}x<em>2+\cdots + c</em>{1n}x<em>n = b_1 \ a</em>{21}x<em>1 + a</em>{22}x<em>2 + \cdots+c</em>{2n}x_n = b_2$  称为约束条件，这里的=号，可以更换成$\leq \ \geq \ \neq$</p><p>$x_1,x_2,x_3\cdots x_n \geq 0$ 称为非负约束。</p><p>线性规划问题可以由向量和矩阵表示：</p><p>$\max(\min) z = C^T X \ s.t. \begin{cases} AX \leq(=,\geq) \ b \ X \geq 0 \end{cases}$</p><p>对于正常的解法，单纯形法等方法，不在介绍，直接上COPT怎么用。</p><h2 id="COPT如何解决线性规划"><a href="#COPT如何解决线性规划" class="headerlink" title="COPT如何解决线性规划"></a>COPT如何解决线性规划</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">题目：某加工厂需要加工一批圆钢调料，规格为70cm,52cm,35cm，这三种圆钢条料的需要量为100条，150条，900条</span><br><span class="hljs-string">库房库存一批长 180cm 的圆钢坯料，先对圆钢坯料进行切割。</span><br><span class="hljs-string">问：如何下料，使总余料最少。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> coptpy <span class="hljs-keyword">as</span> cp<br><span class="hljs-keyword">from</span> coptpy <span class="hljs-keyword">import</span> COPT<br><br>env = cp.Envr() <br>model = env.createModel(<span class="hljs-string">&quot;eg2&quot;</span>)<span class="hljs-comment"># 搭建环境</span><br><br>x1 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x1&quot;</span>) <span class="hljs-comment"># 定义变量，参数lb为下界，ub为上界</span><br>x2 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x2&quot;</span>)<span class="hljs-comment"># vtype为变量类型COPT.CONTINUOUS连续型变量，COPT.BINARY二进制变量</span><br>x3 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x3&quot;</span>)<span class="hljs-comment"># COPT.INTEGER 为整数变量</span><br>x4 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x4&quot;</span>)<br>x5 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x5&quot;</span>)<br>x6 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x6&quot;</span>)<br>x7 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x7&quot;</span>)<br>x8 = model.addVar(lb=<span class="hljs-number">0</span>, name=<span class="hljs-string">&quot;x8&quot;</span>)<br><br>model.addConstr(<span class="hljs-number">2</span>*x1 + x2 + x3 + x4 &gt;= <span class="hljs-number">100</span>)<span class="hljs-comment"># 给出约束条件</span><br>model.addConstr(<span class="hljs-number">2</span>*x2 + x3 + <span class="hljs-number">3</span>*x5 + <span class="hljs-number">2</span>*x6 + x7 &gt;= <span class="hljs-number">150</span>)<br>model.addConstr(x1 + <span class="hljs-number">3</span>*x3 + <span class="hljs-number">2</span>*x6 + <span class="hljs-number">3</span>*x7 + <span class="hljs-number">5</span>*x8 &gt;= <span class="hljs-number">900</span>)<br><br>model.setObjective(<span class="hljs-number">5</span>*x1 + <span class="hljs-number">6</span>*x2 + <span class="hljs-number">23</span>*x3 + <span class="hljs-number">5</span>*x4 + <span class="hljs-number">24</span>*x5 + <span class="hljs-number">6</span>*x6 + <span class="hljs-number">23</span>*x7 + <span class="hljs-number">5</span>*x8, sense=COPT.MINIMIZE)<br><span class="hljs-comment"># 设置目标函数 setObjective(expr, sense=None)，expr为表达式，sense为目标函数的优化方向，有MAXIMIZE和MINIMIZE</span><br><br>model.solve()<br><span class="hljs-comment"># 解线性规划</span><br><br><span class="hljs-keyword">if</span> model.status == COPT.OPTIMAL: <span class="hljs-comment"># 输出规划中的一些变量值</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Objective value: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(model.objval))<br>  allvars = model.getVars()<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variable solution:&quot;</span>)<br>  <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> allvars:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; x[&#123;0&#125;]: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(var.index, var.x))<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Variable basis status:&quot;</span>)<br>  <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> allvars:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; x[&#123;0&#125;]: &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(var.index, var.basis))<br></code></pre></div></td></tr></table></figure><h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>跟线性规划没有什么差距，就只是将连续型的变量变成了离散的，只能取整数 <code>COPT.INTEGER</code>。</p><p>所有变量全取整数的规划叫纯整数规划，部分变量取整数的规划称为混合整数规划。所有变量都取0,1两个值的规划叫0-1规划，部分的叫0-1混合规划。</p><h3 id="指示约束"><a href="#指示约束" class="headerlink" title="指示约束"></a>指示约束</h3><p>指示约束（Indicator Constraints）是一类特殊的约束，通常用于涉及二进制变量的优化问题中。这类约束帮助我们通过控制一个二进制决策变量的状态（是 0 还是 1）来影响其他变量或约束的行为。</p><ol><li>If-Then 约束：这个约束表示如果某个条件为真，那么另一个条件也必须成立。这个约束的意思是：如果某个条件为真，那么另一个条件必须也为真</li><li>Only-If 约束：只有当第二个条件为真时，第一个条件才能成立。“只有当 B 成立时，A 才能成立“</li><li>If-and-Only-If 约束：两个条件互为必要且充分条件，即一个条件成立时，另一个条件必定成立，反之亦然。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>线性规划</tag>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>也该结束了</title>
    <link href="/2025/01/13/%E4%B9%9F%E8%AF%A5%E7%BB%93%E6%9D%9F%E4%BA%86/"/>
    <url>/2025/01/13/%E4%B9%9F%E8%AF%A5%E7%BB%93%E6%9D%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=501829&auto=0&height=66"></iframe><p>（最喜欢的音乐，也很契合）</p><blockquote><p>   时间、运气、命运对 OIer 们来说是残酷的字眼。再强的 OIer，也有退役的时刻。再努力的 OIer，也难以保证他在省选或 NOI 一定能够有和他的付出对等的回报。这是很多 OIer 心知肚明的事实，也是我们无力感的根源。</p><p>  也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p><p>   他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打 CF，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是 100 分与 0 分之差，一个部分分之差就可能是 20 多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p></blockquote><p>想了这么长时间，也该结束这些没有做完的梦了，作为一名 OI 选手是不负责任的，在高中花了许多时间却没有任何成绩，所谓的那些也只是虚无缥缈的一些标准，也仅仅是一些学长们出的题目的一些标准。（笑</p><p>想了怎么久，发现很长时间没有用C++写一些代码题目发现感觉不习惯，也只能让他这样下去了。我也是决定不打 OI/ACM 相关的比赛了。说真的，很想去打 ACM 比赛，但是也是因为我实力不是太强，没有一个像样的成绩，如果高中那次参加了比赛，至少还有个省二的奖项，至少现在还是能打的。但是就是没有，想单独参加至少圆一个高中当时的梦想，可惜都不行。可惜，都没办法以一个正规选手的身份去参加一个省级赛事。</p><p>想起当初我在床上关着灯，怕被父母发现，偷偷一个人打着CF，最后就拿到了1000分，想起当时不随大流，他们在教室里晚自习，而我申请在机房晚自习，将每天基本作业写完了就开始写代码了，那段时光，虽然累但是有光，而现在，已经无力回天。</p><p>再见了，OI，我引以为傲的OI。</p><p>下面不会更新OI的一些题目了，会写写自己的学数学建模的一些东西。:(</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round 69</title>
    <link href="/2024/11/26/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound-69/"/>
    <url>/2024/11/26/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound-69/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近一直很忙没什么时间去写题目，也就是抽空来看了几道题，周二下午没课来集中写了写。</p><h2 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h2><p>很简单，学过高中知识就会写。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>cout&lt;&lt;(a+(a - b))&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h2><p>和上道题差不多，唯一不同的就是加了一个字符串处理（将string 变成 int）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string s;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> l,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r)</span></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=r;i&gt;=l;i--)&#123;<br>ans += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)*base;<br>base = base * <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n = s.<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>end = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = <span class="hljs-built_in">num</span>(start,end);<br><br>start = end+<span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=end+<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;,&#x27;</span>)&#123;<br>end = i<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b = <span class="hljs-built_in">num</span>(start,end),c = <span class="hljs-built_in">num</span>(end+<span class="hljs-number">6</span>,n<span class="hljs-number">-1</span>);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> d = (b - a);<br><br>cout&lt;&lt;(c - b) / d - <span class="hljs-number">1</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h2><p>就是数学加物理题，根据镜面反射的原理，很显然我们需要将 $z$ 轴的坐标镜面对称。最后同时除以他们的最大公约数就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,k;<br><br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,y,z;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>z = <span class="hljs-number">2</span>*k - z;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">gcd</span>(x,y),z);<br><span class="hljs-keyword">if</span>(x % t == <span class="hljs-number">0</span>)x = x / t;<br><span class="hljs-keyword">if</span>(y % t == <span class="hljs-number">0</span>)y = y / t;<br><span class="hljs-keyword">if</span>(z % t == <span class="hljs-number">0</span>)z = z / t;<br><br><br>cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;z&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-题"><a href="#D-题" class="headerlink" title="D 题"></a>D 题</h2><p>稍微有点难，但是稍微想想也能出来。</p><p>看了数据范围为全都 $\leq 7$，每个计划只有取和不取两种选择，那么我们最多的方案有 $2^7 = 128$，所以很简单枚举每一种就行了，但是怎么让方案数与每一种的方案关联处理呢？</p><p>联系到快速幂，我们可以想到与二进制结合起来。这样就很简单就可以算出来了，剩下的就是循环和判断的事了，对了，题目默认方案之间可以有重叠（错过一次）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxq = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">int</span> t[maxn][maxn],a[maxn][maxn][maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,q;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>t[i][j] = (s[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)<br>a[i][j][k] = (s[k] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> anscnt = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,q),ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,q);i++)&#123;<br><span class="hljs-function">bitset&lt;maxq&gt; <span class="hljs-title">bits</span><span class="hljs-params">(i)</span></span>;<br><span class="hljs-comment">// cout&lt;&lt;bits&lt;&lt;endl;</span><br><span class="hljs-keyword">int</span> scheme[maxn][maxn],cnt = bits.<span class="hljs-built_in">count</span>();<br><span class="hljs-built_in">memset</span>(scheme,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(scheme));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;q;j++)&#123;<br><span class="hljs-keyword">if</span>(bits[j] == <span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;n;x++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;m;y++)<br>scheme[x][y] += a[j][x][y];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;n;x++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;m;y++)&#123;<br><span class="hljs-keyword">if</span>(t[x][y] == <span class="hljs-number">1</span> &amp;&amp; scheme[x][y] == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t[x][y] == <span class="hljs-number">0</span> &amp;&amp; scheme[x][y] &gt;= <span class="hljs-number">1</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span>flag = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span>(anscnt &gt; cnt)anscnt = cnt,ans = i;<br>&#125;<br><br><span class="hljs-keyword">if</span>(ans == <span class="hljs-number">-1</span>)cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;anscnt&lt;&lt;endl;<br><span class="hljs-function">bitset&lt;maxq&gt; <span class="hljs-title">bits</span><span class="hljs-params">(ans)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)<br><span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-number">1</span>)<br>cout&lt;&lt;i+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="E-题"><a href="#E-题" class="headerlink" title="E 题"></a>E 题</h2><p><del>说实话，到现在我还没有写出来，感觉是常数太大的问题，感觉时间复杂度没啥太大的问题。感觉极限能过。</del>（突然想到会退化了）</p><p>我的想法是，先用前缀和算出前 $n$ 项和，顺便再记录正数的数字位置，将每个放入 map 中。然后再枚举后面的一个划分点，然后在用 <code>lower_bound()</code> 记录算出区间里有没有正数，就 OK 了。</p><p>但是我这个想法会退化，如果数据的许多小区间中，前缀和有相同的，就比如 <code>1 -1 1 -1 1 -1 1 -1</code>， 会退化成 $O(n)$ 查找每个区间。</p><p>所以最坏时间复杂度应该为 $\Theta (n^2 \log n)$</p><p>平均时间复杂度为 $O (n \log n \log n)$</p><p>我在夜里突然想到一个很简单的结论，就是划分的三个数组一定是 $\frac{S}{3}$，那么只需要加上这个判断，那么时间复杂度就会大大下降。wok，这个第一次看我还真没想到这么显然的结论。</p><p>那么优化过的最坏时间复杂度下降到 $\Theta (n \log n)$。</p><p>平均时间复杂度为 $O (n + \log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn],sum[maxn];<br>map&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; m;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; pos;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-keyword">if</span>(a[i] &gt; <span class="hljs-number">0</span>)pos.<span class="hljs-built_in">push_back</span>(i);<br>cnt += a[i];<br>&#125;<br><br><span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">3</span> != <span class="hljs-number">0</span> || pos.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>)&#123;cout&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><br>sum[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>sum[i] = sum[i<span class="hljs-number">-1</span>] + a[i];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br><span class="hljs-keyword">if</span>(sum[i] == cnt / <span class="hljs-number">3</span>)<br>m[sum[i]].<span class="hljs-built_in">push_back</span>(i);<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-keyword">int</span> num = sum[n] - sum[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num) == <span class="hljs-number">1</span> &amp;&amp; num == cnt / <span class="hljs-number">3</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> it : m[num])&#123;<br><span class="hljs-keyword">if</span>(i &lt;= it)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">int</span> num2 = sum[i<span class="hljs-number">-1</span>] - sum[it];<br><span class="hljs-keyword">auto</span> a1 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),<span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> a2 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),it+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> a3 = <span class="hljs-built_in">lower_bound</span>(pos.<span class="hljs-built_in">begin</span>(),pos.<span class="hljs-built_in">end</span>(),i);<br><span class="hljs-keyword">if</span>(num2 == num &amp;&amp; a1 != pos.<span class="hljs-built_in">end</span>() &amp;&amp; a2 != pos.<span class="hljs-built_in">end</span>() &amp;&amp; a3 != pos.<span class="hljs-built_in">end</span>())&#123;<br><span class="hljs-keyword">if</span>(*a1 &lt;= it &amp;&amp; *a2 &lt;= i<span class="hljs-number">-1</span> &amp;&amp; *a3 &lt;= n)ans ++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-CF DIV2.ABC题-2</title>
    <link href="/2024/11/22/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CFDIV2-ABC%E9%A2%98-2/"/>
    <url>/2024/11/22/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CFDIV2-ABC%E9%A2%98-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CF-Div2"><a href="#CF-Div2" class="headerlink" title="CF Div2."></a>CF Div2.</h1><p>写了四个的 Div2 了，知道自己差不多在哪了，继续开始突破，看看一周能不能再突破一百。</p><p>现在大约在 $1200$ 左右。</p><h2 id="Codeforces-Round-980-Div-2"><a href="#Codeforces-Round-980-Div-2" class="headerlink" title="Codeforces Round 980 (Div. 2)"></a>Codeforces Round 980 (Div. 2)</h2><h3 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h3><p>本来想的是排序之后一个一个判断是否能不能超过 $k$，如果不能则需要比这个多一次才能跳到下一个数组上，没想到连样例都没过。</p><p>后来看了看样例解释就懂了，同样是排序，变成递增的，然后一个一个判断能不能这个数后面的每个都去和他一样的话，总和能不能超过所需要的饮料，能的话就需要多一次去判断是否是空的了。</p><p>如果不能，那这个不行，就只能用完这个了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> T;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,k;cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> len = (n - i + <span class="hljs-number">1</span>);<br><span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;&lt;&lt;len&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(a[i] * len &gt;= k)&#123;<br>ans += k;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>ans += (a[i] + <span class="hljs-number">1</span>);<br>k -= a[i];<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h3><p>这道题题目根本没有什么提醒让我从哪里想，题解就感觉很空穴来风，样例解释也没有什么可以往这上面靠的。</p><p>题解思路就是用这两个小数组的总和作为值从小到大排序，最后排序的结果就是答案。题解证明：注意，如果在最终的顺序中有两个相邻的数组，左边数组的元素之和大于右边数组的元素之和，那么我们可以交换它们，并且逆序对的数量不会增加。因此，我们可以通过交换相邻的数组，使得每次逆序对的数量不增加，从而将任何最优解转化为我们的解。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nums</span>&#123;</span><br><span class="hljs-keyword">int</span> a1,a2;<br><span class="hljs-keyword">int</span> sum;<br>&#125; a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(nums x,nums y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.sum &lt; y.sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;a[i].a1,&amp;a[i].a2);<br>a[i].sum = a[i].a1 + a[i].a2;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>,cmp);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d &quot;</span>,a[i].a1,a[i].a2);<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Codeforces-Round-979-Div-2"><a href="#Codeforces-Round-979-Div-2" class="headerlink" title="Codeforces Round 979 (Div. 2)"></a>Codeforces Round 979 (Div. 2)</h2><h3 id="C-题-1"><a href="#C-题-1" class="headerlink" title="C 题"></a>C 题</h3><p>这个比赛前2题没什么难度，都是 $800$ 分左右，有点简单了，C 题很显然是构造题，想了想，能想到有第一个或最后一个是 $1$ 的肯定能赢，但是后面怎么处理，根本想不到。还是只能看题解了。</p><p>如果中间的有两个 <code>true</code> 那么一定可以赢，我们可以让 Alice 最后去管理两个 <code>true</code>。首先第一个放在 <code>or</code> 之前。如果 Bob 没有将他的运算符放在两个 <code>true</code> 之间，那么 Alice 将在下一步中将 <code>or</code> 放在两个 <code>true</code> 之间并获胜。</p><p>如果没有连续的 <code>true</code>，每当 Alice 将 <code>true</code> 或相邻位置放置时，Bob 都会通过在 <code>true</code> 之后放置 <code>and</code> 来响应，这将使此子句无效为 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> x[<span class="hljs-number">200010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br>string s;<br>cin&gt;&gt;s;<br><span class="hljs-built_in">memset</span>(x,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(x));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br><span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>x[i] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">bool</span> win = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>] || x[n<span class="hljs-number">-1</span>])&#123;cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(x[i] &amp;&amp; x[i<span class="hljs-number">-1</span>])<br>win = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(win) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Codeforces-Round-979-Div-2-1"><a href="#Codeforces-Round-979-Div-2-1" class="headerlink" title="Codeforces Round 979 (Div. 2)"></a>Codeforces Round 979 (Div. 2)</h2><h3 id="B-题-1"><a href="#B-题-1" class="headerlink" title="B 题"></a>B 题</h3><p>这道题挺有意思，我发现最优的方案一定是先选出 $k$ 个最大的，然后每个减去这 $k$ 个中最小的一个数。最后将大于 $0$ 的数再存进去。重复这几个操作。这期间可以用堆来存储数字，这样每次读取只需要 $O(\log n)$ 读取每个数。这种贪心不太对，在评论区也有许多人用了这种方式，但是都无一例外的 Wa 了。</p><p>直到一位老哥的解释让我恍然大悟。他说可以看看这个样例。<br><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure></p><p>的确，答案确实和我们想的不太一样。其实最优方案是，每次将最大 $k$ 个元素取出，减去 $1$ 后再放回，但是数字要大于 $10^9$，很显然 TLE 了。</p><p>有个更简单的方法。我们最大限度的让每个客人<strong>随机</strong>去选汽车。这样最后选不够 $x$ 辆汽车之后，就会有两种情况；</p><ol><li>所有型号都将具有相同数量的剩余汽车，很显然，这种答案就是 $\lceil \dfrac{a_1+a_2+\dotsb + a_n}{x} \rceil$。</li><li>如果还有型号不为 $0$ 但是个数小于等于 $x$，那么答案为 $\max(a_1+a_2+\dotsb +a_n)$。</li></ol><p>这两种结合一下就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,r;<br>cin&gt;&gt;n&gt;&gt;r;<br><span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;cin&gt;&gt;x;<br>cnt1 += (x % <span class="hljs-number">2</span>);<br>ans += (x/<span class="hljs-number">2</span>)*<span class="hljs-number">2</span>; <br>r -= (x/<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(r &gt;= cnt1)ans += cnt1;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">int</span> t = cnt1 - r;<br>ans += (cnt1 - t*<span class="hljs-number">2</span>);<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>Div2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-CF DIv2.ABC题-1</title>
    <link href="/2024/11/19/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CF-DIv2.ABC%E9%A2%98/"/>
    <url>/2024/11/19/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-CF-DIv2.ABC%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CF-Div2"><a href="#CF-Div2" class="headerlink" title="CF Div2."></a>CF Div2.</h1><p>除了正常的学习算法以及每周一次的周赛，现在每天有时间就写写CF的div2.的前几题，具体是ABC这三题左右难度。遇到好题，以及不会的题目都会放在这里，每4场Div 2.放在一起。</p><h2 id="Codeforces-Round-987-Div-2"><a href="#Codeforces-Round-987-Div-2" class="headerlink" title="Codeforces Round 987 (Div. 2)"></a>Codeforces Round 987 (Div. 2)</h2><h3 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2031B#author=GPT_zh">中文题目</a></p><p>挺有意思的，很像冒泡排序，就是对于一个数，它与它后面一个数的差值等于 $1$ 就交换，否则不动，判断是否能成为一个有序的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>; <br><span class="hljs-keyword">int</span> a[maxn]; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br><span class="hljs-keyword">if</span>(a[i] -  a[i+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)<span class="hljs-built_in">swap</span>(a[i],a[i+<span class="hljs-number">1</span>]),cnt ++;<br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(a[i] != i)&#123;flag = <span class="hljs-number">0</span>;&#125;<br>&#125;<br>cout&lt;&lt;(flag == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2031C#author=GPT_zh">中文题面</a></p><p>刚开始想的是对于 $n$ 分成奇数与偶数判断。偶数非常简单，就是每个相邻就行了。</p><p>如果是奇数，那么一定会存在三个一样的数字，也就是符合 $x + y = z$， $x,y,z$ 都是完全平方数，我列了几项，发现确实存在。（$9,16,25$）就符合。但是具体怎么实现是根本想不到。</p><p>题解的想法非常妙就是可以说是递归实现。如果是 $n &lt; 25$ 的偶数就一定不存在方案。大于 $25$ 后可以递归实现，就是将小于25的部分分成 $1（14个）\dots 16 (15个) \dots 25$，后面的 $15$ 可以和后面 $25$ 后的一个组一个，间距也是 $25$ 个.</p><p>在实现是前面的 $25$ 个直接打表。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; n &lt;= <span class="hljs-number">25</span>)&#123;cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)<br>cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1 3 3 4 4 5 5 6 6 1 2 7 7 8 8 9 9 10 10 11 11 12 12 13 13 1 2 &quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">14</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Codeforces-Round-986-Div-2"><a href="#Codeforces-Round-986-Div-2" class="headerlink" title="Codeforces Round 986 (Div. 2)"></a>Codeforces Round 986 (Div. 2)</h2><h3 id="B-题-1"><a href="#B-题-1" class="headerlink" title="B 题"></a>B 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2028B#author=GPT_zh">中文题目</a></p><p>首先观察到如果 $b = 0$ 时，整个数列是一个常数列 $c$。 </p><p>通过分析样例以及一些其他情况可以想到 $c \geq n - 2$ 是可以变成排列，其中 $c = n-2$ 时步骤为 $n-1$，其他时候为 $n$ ,  如果小于 $n-2$ 就不存在，可以在纸上模拟模拟就了解了。</p><p>如果 $b \neq 0$，那么就更一般的情况，整个数列是一个等差数列 $b \times (i - 1) + c$，判断出来小于 $n$ 的数字不贡献操作数。</p><p>本来想着一个数一个数的列举，但是好像超时了，就直接改成了直接算个数，计算每个的时间复杂度为 $O(1)$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">bool</span>&gt; m;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>m.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,b,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;b,&amp;c);<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(c &gt;= n)cout&lt;&lt;n&lt;&lt;endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c &gt;= n<span class="hljs-number">-2</span>)cout&lt;&lt;n<span class="hljs-number">-1</span>&lt;&lt;endl;<br><span class="hljs-keyword">else</span>cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt = <span class="hljs-built_in">ceil</span>(<span class="hljs-number">1.0</span>*(n-c)/b);<br>cout&lt;&lt;(n - (cnt &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : cnt))&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="C-题-1"><a href="#C-题-1" class="headerlink" title="C 题"></a>C 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2028C#author=GPT_zh">中文题目</a></p><p>这道题本来是想用线段树来解决的，但是想了想还是想不到，感觉超越我的程度了，就看了看 Hint，就只是想到了用前缀和与类似于滑动窗口的类型解决，但是实现起来好像挺难的就放弃了，没想到题解的思路能懂，但是实现方法感觉有点看不懂了，就直接copy了一份题解（汗。</p><p>就是用 $px_i$ 来表示从 $1 \sim i$ 时能够分的最大生物数，$py_j$ 表示从 $j \sim n$ 时能够分的最大生物数。</p><p>我们可以让一个区间分成三份 $1 \sim i \sim j \sim n$，我们枚举 $i \sim j$ 也就是生物吃的区间，那么剩下两个区间就是爱丽丝能所在区间。</p><p>$px<em>i$ 和 $py_i$ 实现方法，就是用双指针的方式，刚开始都在开头，如果这个区间总和不到 $v$ ,那么后面一个指针往后移动，使窗口更大一个，如果大于 $v$ ，就可以更新了，$px</em>{end} = px_{start} + 1$。每次更新前面的。</p><p>能力有限，也就能理解到这了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn],px[maxn],py[maxn],sum[maxn];<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld&quot;</span>,&amp;n,&amp;m,&amp;v);<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br><span class="hljs-built_in">memset</span>(py,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(py));<br><span class="hljs-built_in">memset</span>(px,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(px));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>sum[i+<span class="hljs-number">1</span>] = sum[i] + a[i];<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>,end = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(start = <span class="hljs-number">1</span>;start &lt;= n;start ++)&#123;<br><span class="hljs-keyword">while</span>(end &lt;= n &amp;&amp; ans &lt; v)&#123;<br>ans += a[end];<br>++ end;<br>px[end] = <span class="hljs-built_in">max</span>(px[end],px[end<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">if</span>(ans &gt;= v)&#123;<br>px[end] = px[start] + <span class="hljs-number">1</span>;<br>&#125;<br>ans -= a[start];<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>px[i] = <span class="hljs-built_in">max</span>(px[i] , px[i<span class="hljs-number">-1</span>]);<br><span class="hljs-built_in">reverse</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><br>start = <span class="hljs-number">1</span>,end = <span class="hljs-number">1</span>,ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(start = <span class="hljs-number">1</span>;start &lt;= n;start ++)&#123;<br><span class="hljs-keyword">while</span>(end &lt;= n &amp;&amp; ans &lt; v)&#123;<br>ans += a[end];<br>++ end;<br>py[end] = <span class="hljs-built_in">max</span>(py[end],py[end<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">if</span>(ans &gt;= v)&#123;<br>py[end] = py[start] + <span class="hljs-number">1</span>;<br>&#125;<br>ans -= a[start];<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<br>py[i] = <span class="hljs-built_in">max</span>(py[i] , py[i<span class="hljs-number">-1</span>]);<br><br><span class="hljs-built_in">reverse</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">reverse</span>(py+<span class="hljs-number">1</span>,py+n+<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// for(long long i=1;i&lt;=n;i++)cout&lt;&lt;py[i]&lt;&lt;endl;</span><br><br><span class="hljs-keyword">if</span> (px[n+<span class="hljs-number">1</span>] &lt; m) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> tmp = <span class="hljs-number">0</span>,j = <span class="hljs-number">1</span>;<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">while</span>(j &lt;= n &amp;&amp; px[i] + py[j + <span class="hljs-number">1</span>] &gt;= m)++j;<br><span class="hljs-keyword">if</span>(px[i] + py[j] &gt;= m)<br>ans = <span class="hljs-built_in">max</span>(ans,sum[j]-sum[i]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Codeforces-Round-983-Div-2"><a href="#Codeforces-Round-983-Div-2" class="headerlink" title="Codeforces Round 983 (Div. 2)"></a>Codeforces Round 983 (Div. 2)</h2><h3 id="B-题-2"><a href="#B-题-2" class="headerlink" title="B 题"></a>B 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2032B#author=GPT_zh">中文题目</a></p><p>这题还挺有意思的，给你一个奇数列，从 $1 \sim n$，最后让你求能不能通过合理的划分找到给定的 $k$，使得 $k$ 为中位数。</p><p>刚开始想的是用线段树维护每一段的中位数，但是看了看线段树的定义发现好像不太行，因为每次递归就只能是奇数，没办法变成连续的一段区间，最主要是中位数不能维护。</p><p>就开始想那个第 $k$ 个数一定在子数组中一定是中位数，这样才能被选出去，那么在子数组形成的中位数数组中也一定是中位数。那么最简单可以想到直接划分为三个子数组，需要的数在中间，其他的在两边。这样就一定可以。</p><p>对了，还需要中位数一定不能再左右断点，特判就好。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,k;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> &amp;&amp; k == <span class="hljs-number">1</span>)&#123;cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span> || k &gt;= n)&#123;cout&lt;&lt;(<span class="hljs-number">-1</span>)&lt;&lt;endl;<span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">int</span> start = k,end = k;<br><span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">1</span> &amp;&amp; end &lt;= n)&#123;<br><span class="hljs-keyword">int</span> lenl  = start - <span class="hljs-number">1</span>,lenr = n - end;<br><span class="hljs-keyword">if</span>(lenl % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; lenr % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-keyword">else</span>&#123;start --;end ++;&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(start != <span class="hljs-number">1</span> &amp;&amp; end != n)&#123;<br>cout&lt;&lt;<span class="hljs-number">3</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;start&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;end+<span class="hljs-number">1</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="C-题-2"><a href="#C-题-2" class="headerlink" title="C 题"></a>C 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2032C#author=GPT_zh">中文题目</a></p><p>这道题感觉就差一点点就推出来了，但是临门一脚没想到。</p><p>题目主要是让你求出使得 $a_x + a_y \geq a_z$ 的数组的最小操作次数，每次操作都可以让任意一个 $a_i$ 变成数组里任意一个数。</p><p>可以想想上限，首先我们可以让除了$a_1,a_n$ 的所有数变成 $a_n$ 这样就全部成了，所以答案最多为 $n - 2$。</p><p>首先想到可以先排序，这样就有序了，对于每个 $i$ 用双指针的方法，判断出大于 $a_i$ 的最小和的的两个，这样我们只需要改其他的，这些的在区间因为是有序的，中间的必然符合，那么不用改变。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; a;<br><span class="hljs-keyword">int</span> T;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>a.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;<br>cin&gt;&gt;x;<br>a.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br><br><span class="hljs-keyword">int</span> ans = n - <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r=<span class="hljs-number">2</span>;r &lt; n;r++)&#123;<br><span class="hljs-keyword">if</span>(r - l &gt;= <span class="hljs-number">2</span>  &amp;&amp; a[l] + a[l+<span class="hljs-number">1</span>] &lt;= a[r])l++;<br>ans = <span class="hljs-built_in">min</span>(ans,n - (r - l + <span class="hljs-number">1</span>));<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Codeforces-Round-982-Div-2"><a href="#Codeforces-Round-982-Div-2" class="headerlink" title="Codeforces Round 982 (Div. 2)"></a>Codeforces Round 982 (Div. 2)</h2><h3 id="B-题-3"><a href="#B-题-3" class="headerlink" title="B 题"></a>B 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2027B#author=GPT_zh">中文题目</a></p><p>这道题感觉不像 1100 的，感觉看懂题都挺难的。当时看完这个题目一点思路都没有，<br>还是看了题解之后才理解题目让我干啥的，看了评论区的发现有许多人也说这次的 B 有点怪，而且感觉题目没有说清楚到底要干啥。</p><p>定义一种排序叫斯大林排序，就是如果一个数小于它前面的数，则删掉它，直到按照非递减顺序</p><p>定义一个数组为脆弱数组，就是对任意子序列任意使用这种排列可以使整个数组递减。</p><p>用贪心，当第一个为最大时，那我一定可以通过从他到倒数第二个用一次斯大林排序变成递减序列。<br>所以他后面比他大的我要全部提前删掉</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">10000</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;cin&gt;&gt;n;<br>v.<span class="hljs-built_in">clear</span>();<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> x;cin&gt;&gt;x;<br>v.<span class="hljs-built_in">push_back</span>(x);<br>&#125;<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">999999</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> sum = i - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">if</span>(v[i] &lt; v[j])sum ++;<br>ans = <span class="hljs-built_in">min</span>(ans,sum);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="C-题-3"><a href="#C-题-3" class="headerlink" title="C 题"></a>C 题</h3><p><a href="https://vjudge.net/problem/CodeForces-2027C#author=GPT_zh">中文题目</a></p><p>这道题我只会的暴力 $O(n^2)$，再进一步就想不出来了。只好看题解，才发现题解用了数组当前大小来DFS。</p><p>正解应该是，将每个 $a_i$ 能够加零的数组当前大小给存起来，然后从长度为 $n$ 开始DFS，在DFS区间内取最大值。</p><p>时间复杂度为（估计） $O(n \log n)$。</p><p>对了注意 vis 数组，要用 map 实现，因为数组没有那么大 $10^9$ 左右（就因为这个改了半天）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">300010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br>map&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;&gt; mp;<br>map&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>,<span class="hljs-keyword">bool</span>&gt; vis;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> t)</span></span>&#123;<br>vis[t] = <span class="hljs-number">1</span>;<br>ans = <span class="hljs-built_in">max</span>(ans,t);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : mp[t])&#123;<br><span class="hljs-keyword">if</span>(!vis[t + it - <span class="hljs-number">1</span>])&#123;<br><span class="hljs-built_in">dfs</span>(t + it - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><br>vis.<span class="hljs-built_in">clear</span>();<br>mp.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>mp[a[i] + i - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">dfs</span>(n);<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeForces</tag>
      
      <tag>Div2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round66</title>
    <link href="/2024/11/17/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound66/"/>
    <url>/2024/11/17/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound66/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛客周赛Round66"><a href="#牛客周赛Round66" class="headerlink" title="牛客周赛Round66"></a>牛客周赛Round66</h1><h2 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h2><p>很简单，其实就是求三个数的最大值和其他两个数之和那个打，输出最大的就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y,z;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-keyword">int</span> sum = x + y + z;<br><span class="hljs-keyword">int</span> t = <span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">max</span>(y,z));<br>cout&lt;&lt;<span class="hljs-built_in">max</span>(sum - t,t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h2><p>构造题，构造一个$p<em>i$使得$a_i = p_i + p</em>{p_{i}}$，使得重新构造的数组 $a_i$ 为一个<strong>单调不增</strong>的数列。</p><p>可以想到最简单的构造就是每一个 $a_i$ 都是相等。很简单可以想到构造$1 \dotsc n$ 使得 $a_i$ 成立。</p><p>注意最后一个的输出没有空格。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)cout&lt;&lt;i&lt;&lt;(i== <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-string">&quot; &quot;</span>);<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h2><p>可以观察到 $n$ 非常小，只有 $10$ 位，所以可以直接暴力枚举断点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> T;string s;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br>cin&gt;&gt;s;<br>string ans = s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>string s1 = s.<span class="hljs-built_in">substr</span>(i) + s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i);<br>ans = <span class="hljs-built_in">min</span>(s1,ans);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D、E-题"><a href="#D、E-题" class="headerlink" title="D、E 题"></a>D、E 题</h2><p>E 题为 D 题的加强版，没有想出来。这题可以用并查集，每次操作都会使两个区间合并，就相当于并查集里的合并。</p><p>对于区间，并查集可以维护每个区间的总长度以及水量，父亲为区间的最右点。剩下的就是并查集的部分了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[maxn];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pa[maxn],cnt[maxn];<br><span class="hljs-keyword">int</span> n,q;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> pa[x] == x ? x : <span class="hljs-built_in">Find</span>(pa[x]);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> fx = <span class="hljs-built_in">Find</span>(x),fy = <span class="hljs-built_in">Find</span>(y);<br><span class="hljs-keyword">if</span>(fx == fy)<span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">if</span>(fx &lt; fy)<span class="hljs-built_in">swap</span>(fx,fy);<br>cnt[fx] += cnt[fy];<br>a[fx] += a[fy];<br>pa[fy] = fx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)pa[i] = i,cnt[i] = <span class="hljs-number">1</span>; <br><br><span class="hljs-keyword">int</span> opt,l,r;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>cin&gt;&gt;opt;<br><span class="hljs-keyword">if</span>(opt == <span class="hljs-number">1</span>)&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=l;j&lt;r;j++)&#123;<br><span class="hljs-built_in">unite</span>(j,j+<span class="hljs-number">1</span>);<br>j = <span class="hljs-built_in">Find</span>(j) - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opt == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">int</span> x;<br>cin&gt;&gt;x;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">Find</span>(x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>,<span class="hljs-number">1.0</span>*a[f]/cnt[f]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="F-题"><a href="#F-题" class="headerlink" title="F 题"></a>F 题</h2><p>这道题其实挺可惜的，当时补题时，想出来思路了，就是不会实现，看了题解才发现，题解实现的特别妙。</p><p>显然可以发现 $Move(a)$ 是字典序最小的，因为 $a$ 提到了最前面了，字典序当然最小，其他的依次变大。</p><p>如果存在两个相同的字母，那字典序的排名该怎么算呢？</p><p>如果将一个字母放到前面来，相对顺序变化的只有移到前面来的字符以及原来后面的一个字符，其他的相对顺序不变，不会影响到字典序的排名。</p><p>假定 $s_i = a$，a 为重复的字符。</p><ol><li>如果 $s<em>i &gt; s</em>{i+1}$ : 那么是排名较小的字典序。（为什么？）因为在移动了他之后$s<em>{i+1}$的相对顺序变小了（通俗来讲就是$s_i$原本所在的位置被$s</em>{i+1}$替换），让其他字典序无法比它更小。</li><li>如果 $s<em>i &lt; s</em>{i+1}$ : 那么是排名较大的字典序。与上面的同理。</li><li>如果 $s<em>i =  s</em>{i+1}$ : 不用排名，显然与后一个相同，因为无论是移动 $s<em>i$ 还是 $s</em>{i+1}$，字符串没有变化。</li></ol><p>然后把所有排名排序，找到我们想要的那个排名字符串即可。</p><p>代码实现的非常妙，时间复杂度为 $O(n\log n)$</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> arank pair<span class="hljs-meta-string">&lt;int,int&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> T;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1000010</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">28</span>],vv[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(arank x,arank y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.second &lt; y.second;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--)&#123;<br><span class="hljs-keyword">int</span> n,k;string s;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(a));<br><span class="hljs-built_in">memset</span>(vv,<span class="hljs-number">-1</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vv));<br>cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>a[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] ++;<br><span class="hljs-comment">// cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="hljs-keyword">int</span> tar;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(k &lt;= a[i])&#123;<br>tar = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>k -= a[i];<br>&#125;<br><br><span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>,r = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span>(i == n<span class="hljs-number">-1</span>)vv[i] = r;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(s[i] &lt; s[i+<span class="hljs-number">1</span>])<br>vv[i] = r --;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt; s[i+<span class="hljs-number">1</span>])<br>vv[i] = l ++;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; vv[i] == <span class="hljs-number">-1</span>)<br>vv[i] = vv[i+<span class="hljs-number">1</span>];<br><br>vector&lt;arank&gt; vec;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] == tar + <span class="hljs-string">&#x27;a&#x27;</span>)<br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i,vv[i]));<br>&#125;<br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : vec)&#123;<br>k --;<br><span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;(<span class="hljs-keyword">char</span>)(tar + <span class="hljs-string">&#x27;a&#x27;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;it.first;i++) cout&lt;&lt;s[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=it.first+<span class="hljs-number">1</span>;i&lt;n;i++) cout&lt;&lt;s[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划-牛客周赛Round67</title>
    <link href="/2024/11/11/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound67/"/>
    <url>/2024/11/11/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound67/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛客周赛Round67"><a href="#牛客周赛Round67" class="headerlink" title="牛客周赛Round67"></a>牛客周赛Round67</h1><h2 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h2><p>很简单，暴力处理就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n;<br>string s;<br>cin&gt;&gt;n&gt;&gt;s;<br>string s1,s2,s3;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br><span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)<br>s1 += s[i];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)<br>s2 += s[i];<br><span class="hljs-keyword">else</span><br>s3 += s[i];<br>&#125;<br>cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h2><p>写起来非常简单，注意精度问题，最后比较的时候同时乘以分母可以忽略精度问题。比赛时就没想起这个东西，导致分低。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a,b,c,d;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld %lld %lld&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ay = c*b/d;<br><span class="hljs-keyword">if</span>(ay*d &gt;= b*c)ay--;<br>cout&lt;&lt;a-ay&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h2><p>其实就是限定枚举。只枚举一个，另一个可以通过 C 算出来。复杂度就降低一个。话说比赛时因为以为相加的有无限多个，而直接想错思路，应该是只有两个加分。（哭</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,c;<br>cin&gt;&gt;n&gt;&gt;c;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=c;i++)&#123;<br><span class="hljs-keyword">int</span> b = c - i;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">to_string</span>(i).<span class="hljs-built_in">length</span>() + <span class="hljs-built_in">to_string</span>(b).<span class="hljs-built_in">length</span>() + <span class="hljs-built_in">to_string</span>(c).<span class="hljs-built_in">length</span>() + <span class="hljs-number">2</span> == n)<br>ans ++;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-题"><a href="#D-题" class="headerlink" title="D 题"></a>D 题</h2><p>这道题真的可惜，比赛时差一点点就能满分了，但是整体思路没问题。看样例以及稍加分析，就可以看出最优的区间就创造一个像滑动窗口一样的组，长度为 $n-k+1$ 的一个从 $1$ 到 $n-k+1$ 的区间，然后让队头移除窗口，队尾加上刚刚移除的数，这样一定可以构造出一个 k 个的 “极大不同区间”。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200010</span>;<br><span class="hljs-keyword">int</span> a[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,k;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(n &lt; k)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span>(n == k)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;<br>els&#123;<span class="hljs-function">e</span><br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n-k+<span class="hljs-number">1</span>;i++)</span></span>&#123;cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;a[i] = i;&#125;<br>a[<span class="hljs-number">0</span>] =a[n-k+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k<span class="hljs-number">-1</span>;i++)&#123;cout&lt;&lt;a[i % (n-k+<span class="hljs-number">1</span>)]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>剩下两个都没学过了，等到后面学到了，再来补吧，每天学的太多了，基本上没有什么休息时间，全在看代码。</p>]]></content>
    
    
    <categories>
      
      <category>算法 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>牛客周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补题计划---摆花（有意思的一道dp）</title>
    <link href="/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/"/>
    <url>/2024/11/09/%E8%A1%A5%E9%A2%98%E8%AE%A1%E5%88%92-%E6%91%86%E8%8A%B1%EF%BC%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E9%81%93dp%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补题计划，也是我的oi生涯的最后一章，如果这一次能够成功，至少以一个正规选手能参加一次正规的比赛一次，为了自己那几年高中的努力，泪水，确实，该开始了，如果12月的那次校级比赛，没有得到大三的认可，那……这次的oi之旅真的要结束了。我虽然也不想让他翻篇，不想结束那些在机房里一个静静地写题，不被任何人认可的那段寂静。但天下没有不散的宴席，如果没有，那么该翻篇了。最后一次。</p><blockquote><p>时间、运气、命运对 OIer 们来说是残酷的字眼。再强的 OIer，也有退役的时刻。再努力的 OIer，也难以保证他在省选或 NOI 一定能够有和他的付出对等的回报。这是很多 OIer 心知肚明的事实，也是我们无力感的根源。</p><p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p><p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打 CF，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是 100 分与 0 分之差，一个部分分之差就可能是 20 多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p></blockquote><h2 id="摆花"><a href="#摆花" class="headerlink" title="摆花"></a>摆花</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p><p>试编程计算，一共有多少种不同的摆花方案。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。</p><p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h4><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h4><figure class="highlight"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs">2<br></code></pre></div></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>【数据范围】</p><p>对于 $20\%$ 数据，有 $0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le 8$。</p><p>对于 $50\%$ 数据，有 $0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le 20$。</p><p>对于 $100\%$ 数据，有 $0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le 100$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>刚开始我想的是让 $dp_{i,j,k}$ 表示为摆在第i个位置，摆的第j种花盆的第k个。但是好像细想有点反直觉，就是有点感觉有点不对。最后我想到，其实i可以省略，因为这个摆的花盆与j与k有关（因为题目说花盆有序），就是一个单调不下降子序列。</p><p>本来想是通过直接去掉i，但是细想这种又有点不对，最后求最后有多少种的时候又有不知道输出什么。</p><p>看了我之前的代码，我理解了，就是可以定义 $d<em>{i,j}$ 为在用到第 i 种花时，用了第 $j$ 盆花的方案数（**注意：这里$j$指的是全体的$j$盆，而不是$a</em>{i}$的第$j$盆**。</p><p>这样对于每个 $d<em>{i,j}$ 可以去更新后面的 $d</em>{i+1,j+k}$， k表示对于第 i 种花的约束。</p><p>那么动态转移方程为：</p><script type="math/tex; mode=display">d_{i+1,j+k} = d_{i+1,j+k} + d_{i,j} \qquad (k = 1,2,....a_i)</script><p>xxxxxxxxxx31 1#include<bits/stdc++.h>2​3using namespace std;4​5int T;6​7int main()8{9    int T;10    cin&gt;&gt;T;11    while(T—){12        int n,r;13        cin&gt;&gt;n&gt;&gt;r;14        int cnt1 = 0,ans = 0;15        for(int i=1;i&lt;=n;i++){16            int x;cin&gt;&gt;x;17            cnt1 += (x % 2);18            ans += (x/2)<em>2; 19            r -= (x/2);20        }21        22        if(r &gt;= cnt1)   ans += cnt1;23        else{24            int t = cnt1 - r;25            ans += (cnt1 - t</em>2);26        }27        28        cout&lt;&lt;ans&lt;&lt;endl;29    }30    return 0;31}cpp</p><p>以后遇到好题，都会加入补题计划（如果这次失败了，那也该和OI说再见了，一心一意的开始考研了）。</p>]]></content>
    
    
    <categories>
      
      <category>算法、 - 补题计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AVL树</title>
    <link href="/2024/10/05/AVL%E6%A0%91/"/>
    <url>/2024/10/05/AVL%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AVL 树是二叉搜索&amp;平衡树的一种，能够担任快速地插入，查找，等操作的数据结构。二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 $n$ 个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\log n)$，最坏为 $O(n)$。</p><h2 id="二叉搜索树的定义"><a href="#二叉搜索树的定义" class="headerlink" title="二叉搜索树的定义"></a>二叉搜索树的定义</h2><ul><li>空树为二叉搜索树</li><li>如果二叉搜索树的左子树不为空，那么它的左子树上所有点的附加权值均小于其根节点的值。</li><li>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</li><li>二叉搜索树的左右子树均为二叉搜索树。</li></ul><p>简单来说，就是一棵树满足全部左子树的值小于其根节点，全部右子树的值大于其根节点。</p><h2 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h2><p>与正常的树相同，有左右子节点。还有需要维护的总体大小，高度。全部用指针实现。在保存时只需保存根节点的指针就行。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTreeNote</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">int</span> key;<br>AVLTreeNote *Left;<br>AVLTreeNote *Right;<br><span class="hljs-keyword">int</span> height;<br><span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">int</span> count;<br><span class="hljs-built_in">AVLTreeNote</span>(<span class="hljs-keyword">int</span> value): <span class="hljs-built_in">key</span>(value), <span class="hljs-built_in">size</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">Left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">Right</span>(<span class="hljs-literal">nullptr</span>),<span class="hljs-built_in">height</span>(<span class="hljs-number">1</span>) &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>对于一个符合要求的二叉平衡树，它的中序遍历为非降的序列。那么可以利用这个性质来debug。(在小范围数据特别好用)，时间复杂度为 $O(n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 树的中序遍历，并且按顺序输出节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Traversal</span><span class="hljs-params">(AVLTreeNote* root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Left);<br>cout&lt;&lt;<span class="hljs-string">&quot;root-&gt;key: &quot;</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="hljs-string">&quot; height: &quot;</span>&lt;&lt;root-&gt;height&lt;&lt;<span class="hljs-string">&quot; size: &quot;</span>&lt;&lt;root-&gt;size&lt;&lt;<span class="hljs-string">&quot; count : &quot;</span>&lt;&lt;root-&gt;count&lt;&lt;<span class="hljs-string">&quot; Left(if have): &quot;</span>&lt;&lt;(root-&gt;Left ? root-&gt;Left-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;<span class="hljs-string">&quot; Right(if have): &quot;</span>&lt;&lt;(root-&gt;Right ? root-&gt;Right-&gt;key : <span class="hljs-number">-1</span>)&lt;&lt;endl;<br><span class="hljs-built_in">Traversal</span>(root-&gt;Right);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="寻找最大最小值"><a href="#寻找最大最小值" class="headerlink" title="寻找最大最小值"></a>寻找最大最小值</h3><p>一个二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右链的顶点。时间复杂度为 $O(h)$。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉平衡树</tag>
      
      <tag>AVL 树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序（Heapsort）</title>
    <link href="/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/"/>
    <url>/2024/09/04/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heapsort%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆排序（Heapsort）"><a href="#堆排序（Heapsort）" class="headerlink" title="堆排序（Heapsort）"></a>堆排序（Heapsort）</h1><p>堆排序指利用堆数据结构所设计的一种排序算法，</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>首先建立大顶堆，然后将堆顶的元素取出，作为最大值，与数组尾部的元素交换，并维持残余堆的性质；</p><p>之后将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持残余堆的性质；</p><p>以此类推，在第 $n-1$ 次操作后，整个数组就完成了排序。</p><ul><li>如何从一个无序序列建成一个堆？</li><li>如何将堆顶的元素取出之后，调整剩余元素成为一个新的堆？</li></ul><p>下面是具体步骤：</p><p>先解决第一个问题，首先现将数组从上至下转换成二叉树，对于一个节点 $i$，它的父节点为 $i/2$，左儿子为 $2 \times i$，右儿子为 $2 \times i + 1$。<br>现在是无序堆，我们要让这个无序堆变成最大堆（最小堆）。</p><p>从最后一个子堆开始，首先开始对比左右儿子，有的话取较大的子节点，再与父节点相比，如果比父节点大，那么就将儿子与父亲交换，这样一个子堆就变成了最大堆。</p><p>最后自顶向上去创建最大堆，直至最大堆完成。</p><p>将创建完成的最大堆的父节点给下放，放到最下面的一个节点，不动它了，之后对前面的继续变成最大堆，不断重复这些步骤。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先我们选一个数组 [100, 5, 3, 11, 33, 6, 8, 7]，按照数组顺序来构建一棵树。如下图</p><p><img src="https://s2.loli.net/2024/09/08/tTX1eJirlWSyq8L.png" alt="graph"></p><p>按照步骤，先看最后一个子堆，就是最下面的 11，发现 11 没有右儿子，有个左儿子 7，符合最大堆的性质，现在在看以 5 为父节点的堆，发现右儿子更大，再与父节点比较，发现儿子比父节点大，那么 5 和 33 交换，交换后子堆符合最大堆的性质。 </p><p><img src="https://s2.loli.net/2024/09/08/8HYlK2rPO7SD5VF.png" alt="graph_1"></p><p>再按照上面的规则将 3 的堆，变成最大堆，再将 100 为父节点的堆变成最大堆，最后成为下图：</p><p><img src="https://s2.loli.net/2024/09/08/ZXOEij3dUBwmLK1.png" alt="graph_2"></p><p>这样我们第一步就完成了，下面将整个最大堆的父节点 100 放到堆的末尾(实际上是100与7交换)，我们就不管它了。</p><p><img src="https://s2.loli.net/2024/09/08/li8VRZKedbEJzak.png" alt="graph_3"></p><p>然后继续开始最大堆调整，直至一轮结束，在 7 升至顶部之后，对顶部重新做最大堆调整，左孩子33代替7的位置。这里就不给图了。</p><p>最后不断建立最大堆，并且扩大有序区，最终全部有序，最终图如下图所示</p><p><img src="https://s2.loli.net/2024/09/10/23CHIv95YDNyGWV.png" alt="graph6.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x,<span class="hljs-keyword">int</span> *y)</span></span>&#123;       <span class="hljs-comment">// 交换代码</span><br><span class="hljs-keyword">int</span> tmp = *x;<br>*x = *y;<br>*y = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end)</span></span>&#123;            <span class="hljs-comment">// 对于 start到end的堆，从顶上开始往下去让整个堆符合最大堆的性质</span><br><span class="hljs-keyword">int</span> dad = start;<br><span class="hljs-keyword">int</span> son =  dad * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(son &lt;= end)&#123;      <span class="hljs-comment">// 如何儿子没有超过范围，也就是这个父节点有儿子的话</span><br><span class="hljs-keyword">if</span>(son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; a[son] &lt; a[son+<span class="hljs-number">1</span>])     <span class="hljs-comment">//两个儿子比较</span><br>son ++;<br><span class="hljs-keyword">if</span>(a[dad] &gt; a[son]) <span class="hljs-comment">// 儿子与父节点比较</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span>&#123;       <span class="hljs-comment">// 如果不符合最大堆的性质，则交换父节点与子节点</span><br>swap(&amp;a[dad],&amp;a[son]);<br>dad = son;<br>son = dad * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">()</span>     <span class="hljs-comment">// 真正的堆排序</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>max_heapify(i,n);       <span class="hljs-comment">// 第一次完整的堆排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;<span class="hljs-number">1</span>;i--)&#123;<br>swap(&amp;a[<span class="hljs-number">1</span>],&amp;a[i]);      <span class="hljs-comment">// 将父节点下放</span><br>max_heapify(<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);     <span class="hljs-comment">// 注意是 i-1</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>稳定匹配(stable Matching)问题</title>
    <link href="/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/"/>
    <url>/2024/08/28/%E7%A8%B3%E5%AE%9A%E5%8C%B9%E9%85%8D-stable-Matching/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在学 UCB CS70时，有一个note专门讲了这问题————稳定匹配问题，用了两天时间稍微理解了一些些。</p><h1 id="稳定匹配问题"><a href="#稳定匹配问题" class="headerlink" title="稳定匹配问题"></a>稳定匹配问题</h1><h2 id="提议与拒绝算法-The-Propose-and-Reject-Algorithm"><a href="#提议与拒绝算法-The-Propose-and-Reject-Algorithm" class="headerlink" title="提议与拒绝算法(The Propose-and-Reject Algorithm)"></a>提议与拒绝算法(The Propose-and-Reject Algorithm)</h2><p>Note 上就是这么命名的，也称盖尔-沙普利算法(Gale–Shapley algorithm)。</p><ol><li>每个职位（男士）向自己优先列表中尚未拒绝的最优先候选人提出邀请。</li><li>每位候选人（女士）收集所有在这一次收到的邀请，对于她最喜欢的邀请，他回应“可以”，对于其他排名的邀请，她直接拒绝这些提议。</li><li>每个被拒绝的职位将拒绝的候选人从其列表中划掉</li></ol><p>上述循环每天重复，直到没有邀请被拒绝。</p><h2 id="提议与拒绝算法的性质"><a href="#提议与拒绝算法的性质" class="headerlink" title="提议与拒绝算法的性质"></a>提议与拒绝算法的性质</h2><ul><li>这个算法总是会停止。</li></ul><p>证明：论证很简单：在算法未停止的每一天，至少有一个职位必须从其列表中删除一些候选人（否则算法的停止条件将会被触发）。由于每个列表有 $n$ 个元素，而总共有 $n$ 个列表，这意味着算法最多在 $n^2$ 次迭代（天）后终止。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>一个好的匹配应该具有什么性质？或许我们希望最大化首选的数量？或者，我们可以最小化最后选择的数量。或者理想情况下，我们可以最小化选择排名的总和，这可以被视为最大化平均幸福感。</p><p>在本讲中，我们将专注于一个更基本的标准，这个标准根植于自主性的理念，即<strong>稳定性</strong>。如果存在一个职位（男士）和一个候选人（女士），他们都希望与对方合作，而不是与他们当前的匹配对象合作，那么这个匹配就是<strong>不稳定的</strong>。我们将这样的配对称为<strong>不和谐对</strong>。因此，n 个职位与 n 个候选人的匹配是稳定的，如果它没有不和谐对。</p><p>在讨论如何找到一个稳定的匹配之前，让我们先问一个更基本的问题：<strong>稳定的匹配总是存在吗？</strong>答案显然是肯定的。对于任何不稳定的匹配，从上面的不稳定的定义来看，总可以找到一个其他的人，来拆散当前的匹配对象。</p><h3 id="分析稳定性"><a href="#分析稳定性" class="headerlink" title="分析稳定性"></a>分析稳定性</h3><ul><li><strong>引理1：</strong> 如果职位 $J$ 在第 $k$ 天向候选人 $C$ 提出提议，那么在随后的每一天 $C$ 都会收到一个她至少和 $J$ 一样喜欢的职位提议（即“在手中的”职位）。</li></ul><p>证明不证了，看了大概，只能看懂，开了一个坑，等后面这个课结束了在来填。</p><ul><li><p><strong>引理2：</strong> 提议与拒绝算法总是终止于一个匹配。</p></li><li><p><strong>定理1：</strong> 该算法生成的匹配总是稳定的。</p></li></ul><p>证明：这次我们从职位的角度来证明稳定性，我们直接证明在算法生成的匹配中，没有职位会涉及不和谐对。考虑最终匹配中的任何一对 $(J, C)$，假设 $J$ 更喜欢某个候选人 $C<em>{*}$ 而不是$C$。我们将论证 $C</em>{<em>}$ 更喜欢她的职位而不是 $J$，因此 $(J, C_</em>)$不能构成不和谐对。由于 $C<em>*$ 在 $J$ 的列表中比 $C$ 靠前，$J$ 必然在向C提出提议之前先向 $C</em><em>$ 提出了提议。因此，根据改善引理，$C_</em>$ 至少和 $J$ 一样喜欢她最终获得的职位，因此更喜欢她的职位而不是 $J$ 。因此，没有职位会涉及不和谐对，匹配是稳定的。</p><p>上面我们证明了这个算法总会存在稳定的匹配。但是在现实生活中不会仅仅追求这个，还要追求最好，那么最优性应运而生。</p><ul><li><strong>定义1 （职位的最佳候选人）</strong> 对于给定职位J，J的最佳候选人是所有稳定匹配中J可以配对的最高排名<em>候选人</em>（注意候选人是双方都看得上的）。</li><li><strong>定义4.3 （候选人的最佳职位）</strong> 对于给定候选人C，C的最佳职位是所有稳定匹配中C可以配对的最高排名的职位。</li></ul><p><strong>定理2：</strong> 提议与拒绝算法输出的匹配总是对于一方最优的。</p><p>假设不是对于一方最优的，我们先举个栗子，可能不是对雇主最优的。那么，在某一天(第 k 天)，J 被他的最佳候选人 C 拒绝，C 选择了 K 的位置，那么根据最佳候选人的定义，必然存在一个稳定匹配，其中 J 与 T 配对，那么这个稳定匹配为 ${\dotsc {J,T<br>},{C,K} \dotsc}$。</p><p>下面来证明(T,K) 是不和谐对。按照上面的逻辑，T更喜欢K而不是J。由于第 k 天是某个职位第一次被其最佳候选人拒绝的日子，在第k天之前，职位 T 没有被其最佳候选人拒绝过。由于 T 在第 k 天向 K 提出了提议，这表明 T 至少和它的最佳候选人一样喜欢C*，因此至少和它在稳定匹配T中的配对 K 一样喜欢 T。因此，(T,K)在匹配中形成了一个不和谐对，所以匹配中不是稳定的。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>就是很经典的题目，男士与女士结婚配对。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Stable_Marriage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 初始话女士与男士的对象</span><br><span class="hljs-built_in">memset</span>(man,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(man));<br><span class="hljs-built_in">memset</span>(woman,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(woman));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)rank[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 开始匹配</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!man[i])&#123;    <span class="hljs-comment">// 如果男士不是单身狗</span><br><span class="hljs-keyword">int</span> g = men[i][rank[i] ++];     <span class="hljs-comment">// 向没有被拒绝的女士发出邀请</span><br><span class="hljs-keyword">if</span>(!woman[g])&#123; <br>                    <span class="hljs-comment">// 如果女士也没有对象</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>                <span class="hljs-comment">// 如果有了，判断现在的男士提出的申请是否比原来的对象，如果好。就换一个</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sc_woman[g][i] &lt; sc_woman[g][woman[g]])&#123;<br>man[woman[g]] = <span class="hljs-number">0</span>;  <br>                    <span class="hljs-comment">// 把原来的甩了</span><br>woman[g] = i;man[i] = g;<br>&#125;<br>sign = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">// 如果所有的男士都有对象，那么这个匹配已经OK了</span><br><span class="hljs-keyword">if</span>(!sign)<span class="hljs-keyword">break</span>;<br>&#125;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,woman[man[i]],man[i]);<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Stable Matching</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UCB CS70: discrete Math and probability theory</title>
    <link href="/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/"/>
    <url>/2024/08/17/UCB-CS70-discrete-Math-and-probability-theory/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="集合的复习以及数学标记"><a href="#集合的复习以及数学标记" class="headerlink" title="集合的复习以及数学标记"></a>集合的复习以及数学标记</h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合可以包含任何东西，包括集合，任何元素。如过元素 $x$ 在集合 $A$ 中，那么记作 $x \in A$。如果 $y$ 不属于 $A$ 中，那么记作 $y \notin A$。</p><p>集合的基本属性：</p><ul><li>集合中不存在顺序</li><li>如果$A,B$两个集合相等，那么记作 $A = B$\</li></ul><h3 id="基数-Cardinality"><a href="#基数-Cardinality" class="headerlink" title="基数(Cardinality)"></a>基数(Cardinality)</h3><p>集合中的元素的个数，记作基数，比如 $A = {1,2,2,4}$，基数为 4，记作 $\mid A\mid=4$.</p><p>如果基数为0，那么被称为空集，记作 $\emptyset$。</p><h3 id="集合的基本运算"><a href="#集合的基本运算" class="headerlink" title="集合的基本运算"></a>集合的基本运算</h3><h4 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h4><p>设 $A,B$ 为两个集合，则由集合 $A$ 和集合 $B$ 中的所有元素汇集而成的集合称为集合 $A$ 和集合 $B$ 的 并。记作 $A \cup B$。即：</p><p>$A \cup B = {x \mid x\in A \vee x \in B}$</p><p>基本推理：</p><ul><li>$A \cup B = B \cup A$</li><li>$A \cup \emptyset = A$</li></ul><h4 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h4><p>设 $A,B$ 为两个集合，则由集合 $A$ 和集合 $B$ 中的公共元素汇集而成的集合称为集合 $A$ 和集合 $B$ 的 并。记作 $A \cap B$。即：</p><p>$A \cap B={x \mid x\in A \wedge x \in B}$</p><p>基本推论：</p><ul><li>$A \cap B = B \cap A$</li><li>$A \cap \emptyset = \emptyset$</li></ul><h4 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h4><p>设 $A,B$ 为两个集合，则由属于集合 $A$ 但不属于集合 $B$ 的所有元素汇集的集合称为集合 $A$ 与集合 $B$ 的差。记作 $A\backslash B$ 或 $A − B$。即：</p><p>$A\backslash B= {x \in A \mid x \notin B}$</p><p>基本推论：</p><ul><li>$A \backslash B = \emptyset$</li><li>$A \backslash \emptyset = A$</li><li>$\emptyset \backslash A = \emptyset$</li></ul><h3 id="基本集合标记"><a href="#基本集合标记" class="headerlink" title="基本集合标记"></a>基本集合标记</h3><ul><li>$\mathbb{N}$ 表示所有自然数的数集</li><li>$\mathbb{Z}$ 表示所有整数的数集</li><li>$\mathbb{Q}$ 表示所有有理数：${\frac{a}{b} \mid  a,b \in \mathbb{Z},b \neq 0}$</li><li>$\mathbb{R}$ 表示所有实数集</li><li>$\mathbb{C}$ 表示所有复数集</li></ul><h3 id="笛卡尔积（Cartesian-product）"><a href="#笛卡尔积（Cartesian-product）" class="headerlink" title="笛卡尔积（Cartesian product）"></a>笛卡尔积（Cartesian product）</h3><p>笛卡尔积，记作 $A \times B$，表示两个集合中的 元素的有序对，即：</p><p>$A \times B = {(a,b) \mid a \in A,b \in B}$</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>幂集，就是原集合中所有的子集（包括全集和空集）构成的集。</p><p>$S: {T | T \subseteq S}$</p><p>举个栗子，如果 $S = {1,2,3}$, $S$的幂集: $P(S) = {\emptyset,{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}$。</p><p>如果 $\mid S \mid = k$，那么 $\mid P(S) \mid = 2^k$。</p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><h3 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h3><p>能判断对错指代清楚的叫命题。例如：</p><ul><li>今天会下雨</li><li>根号三是无理数</li></ul><h3 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h3><ol><li>合取：记作 $q \land p$，只有两个都为真，结果才为真。</li><li>析取：记作 $q \lor p$，两个只要有一个真，结果就为真。</li><li>否定：记作 $\lnot p$，p 的否定，非 p。</li></ol><p>永真式：表示无论变量如何，永远为真的式子。例如：$P \lor \lnot Q$</p><p>矛盾式：表示无论变量如何，永远为假的式子。例如：$P \land \lnot Q$</p><div class="table-container"><table><thead><tr><th>$P$</th><th>$Q$</th><th>$P \land Q$</th><th>$P \lor Q$</th><th>$\lnot P$</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td></tr></tbody></table></div><ol><li><p>蕴含式：$P \implies Q$（P 蕴含 Q），若 $P$ 为真，则 $Q$ 为真。</p><ul><li>简单关系：$(P \implies Q) \equiv (\lnot P \lor Q)$。</li><li>如果 $P \implies Q$ 和 $Q \implies P$ 都为真，记作 $P \iff Q$，等价号。</li></ul></li></ol><p>已知 $P \implies Q$，我们可以定义：</p><ul><li>逆否命题为真：$\lnot Q \implies \lnot P$</li><li>逆命题：$Q \implies P$</li></ul><div class="table-container"><table><thead><tr><th>$P$</th><th>$Q$</th><th>$\lnot P$</th><th>$\lnot Q$</th><th>$P \implies Q$</th><th>$Q \implies P$</th><th>$\lnot Q \implies \lnot P$</th><th>$P \iff Q$</th></tr></thead><tbody><tr><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>F</td><td>T</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td></tr></tbody></table></div><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>全称量词：全称量词表示命题对所有元素都成立，通常用符号 $\forall$ 表示。</p><p>存在量词：存在量词表示命题对至少一个元素成立，通常用符号 $\exists$ 表示。</p><p>我们从高中用到大学，不再赘述了。</p><h3 id="处理否定的一些定律"><a href="#处理否定的一些定律" class="headerlink" title="处理否定的一些定律"></a>处理否定的一些定律</h3><h4 id="德摩根定律"><a href="#德摩根定律" class="headerlink" title="德摩根定律"></a>德摩根定律</h4><script type="math/tex; mode=display">\lnot (P \land Q) \equiv (\lnot P \lor \lnot Q)</script><script type="math/tex; mode=display">\lnot (P \lor Q) \equiv (\lnot P \land \lnot Q)</script><h4 id="有关量词的一些定律"><a href="#有关量词的一些定律" class="headerlink" title="有关量词的一些定律"></a>有关量词的一些定律</h4><p>$\lnot (\forall x P(x))\equiv \exists x \lnot P(x)$</p><p>$\lnot (\exists x P(x))\equiv \forall x \lnot P(x)$</p><p>下面还有更复杂一些的：</p><script type="math/tex; mode=display">\lnot (\forall x \exists y P(x,y)) \equiv \exists x \lnot(\exists y P(x,y)) \equiv \exists x \forall y \lnot P(x,y)</script>]]></content>
    
    
    <categories>
      
      <category>Discrete mathematics</category>
      
      <category>CS70</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Discrete mathematics</tag>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS50笔记（查漏补缺）</title>
    <link href="/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/"/>
    <url>/2024/07/17/CS50%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>准备一个暑假在跑外卖的时候干点有用的事，就从学习CS50开始吧，正好学点自己不知道到的知识。</p><p><strong>2024-07-17~2024-08-17</strong>  结束正好用时一个月，也终于结束了，因为不是零基础，所以有些课程跳了，有的太简单了，还是挺有感慨的，以前发现自己编程同龄人无敌，现在才发现任重道远，开学后要好好学学指针。</p><h2 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h2><p>还是基础功不太扎实，连这个都不知道。</p><p>归并排序基于分治思想将数组分段排序后合并，主要思想是将两个<strong>已经排好序</strong>的数合并在一起。</p><ol><li><p>注意：这个算法必须申请<strong>至少两倍空间</strong>，首先，设定两个指针，这两个指针在两个已经排好的数组的起始位置。</p></li><li><p>合并：从左向右，枚举两个数组<code>a[i]</code>和<code>b[i]</code>，找出最小的数放入新数组，直到有一个数组为空时，把另一个数组的剩下的元素放入新数组。</p></li><li><p>分治：如果数组长度为 1，该数组就是有序的，不用排序。如果数组长度大于 1，此时应将该数组分为两段，等分成左边和右边，检查有无序，无序重复此操作，左边有序后检查右边，两变边都有序了，合并（见2操作）。</p></li></ol><p>给一张动图吧，好理解一些，网上的：<img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt="sort"></p><h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C 标准库 "></a>C 标准库 <string.h></h2><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>int strcmp(const char *str1, const char *str2)</code></p><p>str1 ——— 要进行比较的第一个字符串</p><p>str2 ——— 要进行比较的第二个字符串 </p><p>返回值如下：</p><ul><li>如果返回值小于 0，则表示 str1 小于 str2。</li><li>如果返回值大于 0，则表示 str1 大于 str2。</li><li>如果返回值等于 0，则表示 str1 等于 str2。</li></ul><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p><code>char *strcpy(char *dest, const char *src)</code></p><p>dest — 指向用于存储复制内容的目标数组。\<br>src — 要复制的字符串。</p><h2 id="C-标准库-1"><a href="#C-标准库-1" class="headerlink" title="C 标准库 "></a>C 标准库 <stdlib.h></h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>C 库函数 <code>void *malloc(size_t size)</code> 分配所需的内存空间，并返回一个指向它的指针。</p><p><code>void *malloc(size_t size)</code></p><p>size — 内存块的大小，以字节为单位。</p><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>C 库函数 <code>void free(void *ptr)</code> 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。</p><p><code>void free(void *ptr)</code></p><p>ptr — 指针指向一个要释放内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果传递的参数是一个空指针，则不会执行任何动作。</p><p>C 标准库 <stdio.h></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h4><p>可以使用 fopen() 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><p><code>FILE *fopen( const char *filename, const char *mode );</code></p><p>filename ——- 字符串，用来命名文件。</p><p>mode ————- 访问模式，有下面几种格式：</p><div class="table-container"><table><thead><tr><th><strong>模式</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件。</td></tr><tr><td>w</td><td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td>a</td><td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件。</td></tr><tr><td>w+</td><td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td>a+</td><td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table></div><h4 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h4><p>为了关闭文件，请使用 fclose() 函数。函数的原型如下：</p><p><code>int fclose( FILE *fp );</code></p><p>如果成功关闭文件，fclose() 函数返回零，如果关闭文件时发生错误，函数返回 EOF。</p><h4 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h4><p>函数 fprintf() 函数根据指定的格式发送信息到由stream（流）指定的文件。因此 fprintf() 可以使得信息输出到指定的文件。</p><p><code>int fprintf( FILE *stream, const char *format, ... );</code></p><p>第一个参数是文件指针，第二个和后面都和printf() 一样的。将内容输出到字符串中。</p><h4 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h4><p>C 库函数 size_t fread(void <em>ptr, size_t size, size_t nmemb, FILE </em>stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。</p><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code></p><p>参数：</p><ul><li>ptr — 这是指向带有最小尺寸 size*nmemb 字节的内存块的指针。</li><li>size — 这是要读取的每个元素的大小，以字节为单位。</li><li>nmemb — 这是元素的个数，每个元素的大小为 size 字节。</li><li>stream — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></div></td></tr></table></figure><ul><li><p><strong>column1, column2, …</strong>：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</p></li><li><p><strong>table_name</strong>：要查询的表名称。</p></li><li><p>注意：在 <code>SELECT</code> 后在加 <code>DISTINCT</code> 可以去重</p></li></ul><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></div></td></tr></table></figure><p>WHERE 相当于 if ，<code>condition</code> 是条件。</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;<br></code></pre></div></td></tr></table></figure><ul><li><strong>column1, column2, …</strong>：要排序的字段名称，可以为多个字段。</li><li><strong>ASC</strong>：表示按升序排序。</li><li><strong>DESC</strong>：表示按降序排序。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CS50</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>SQL</tag>
      
      <tag>Python</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 学习（长期）</title>
    <link href="/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/"/>
    <url>/2024/05/02/git%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%95%BF%E6%9C%9F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最经换电脑了，电脑里的东西全得转移，真的麻烦，搞这个博客就花了好长时间来 git，借此机会想来学习一下 git 相关知识，慢慢学。</p><h2 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h2><ol><li><p>集中式版本控制系统：</p><p> 集中式的版本控制系统，所有的版本库是放在中央服务器中的，也就是说我们每一次的修改上传都是保存在中央服务器中的。中央服务器就是个大仓库，大家把产品都堆里面，每一次需要改进和完善的时候，需要去仓库里面把文件给提出来，然后再操作。</p><p> 但是有缺点，如果主服务器出现了问题，所有人就无法上传或下载，而且会有延迟，可能下载下来的版本不是最新的。</p></li><li><p>分布式版本控制系统：<br> 分布的含义不是说每台计算机上只留有版本库的一部分。恰恰相反，分布的含义是每台计算机上都还有一个完整的版本库。这个时候，你的修改仅仅需要提交给本地的版本库进行保存就可以了。</p><p> 而 Git 就是一个优秀分布式版本控制系统。</p></li></ol><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>一共有两种，第一种就是直接在自己本地电脑上新建一个，第二种就是从远程服务器克隆一个仓库。</p><p>方式一：<code>git init</code></p><p>方式二：<code>git clone</code></p><p>不管是哪样，都会在本地文件夹中生成一个 <code>.git</code> 目录，这个目录中存放着许多有关git信息的重要文件。</p><h2 id="Git-的工作区域和文件状态"><a href="#Git-的工作区域和文件状态" class="headerlink" title="Git 的工作区域和文件状态"></a>Git 的工作区域和文件状态</h2><p>本地的数据管理：</p><ol><li>工作区（Working Diretctory）.git 所在的目录，就是你在电脑里能看到的目录</li><li>暂存区（Staging Area/Index）.git/index，一般存放在 .git 目录下的 index 文件</li><li>本地仓库（Local Repository）.git/objects</li></ol><script type="math/tex; mode=display">工作区 \xrightarrow{\text{git\ add}}暂存区\xrightarrow{\text{git\ commit}} 本地仓库</script><p>文件也分几种状态：</p><ol><li><p>未追踪（Untrack）</p></li><li><p>未修改（Unmodified）</p></li><li><p>已修改（Modified）</p></li><li><p>已暂存（Staged）</p></li></ol><p><code>git add</code> 能直接将 Untrack 变成 Staged，<code>git rm</code> 将 Unmodified 变成 Untrack。</p><h2 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h2><p><code>git status</code> 查看仓库的状态</p><p><code>git add</code> 添加到暂存区：可以使用通配符，也可以用<code>.</code>代表当前文件夹</p><p><code>git commit</code> 提交：只提交暂存区中的内容，不会提交工作区中的内容</p><p><code>git log</code> 查看仓库提交历史记录；可以使用 <code>--oneline</code> 来查看简洁的提交记录</p><h2 id="git-reset-回退版本"><a href="#git-reset-回退版本" class="headerlink" title="git reset 回退版本"></a>git reset 回退版本</h2><p>有三种：</p><p><code>git reset --soft</code>：工作区保留，暂存区保留</p><p><code>git reset --hard</code>：工作区与暂存区都不保留</p><p><code>git reset --mixed</code>：工作区保留，暂存区不保留</p><h2 id="git-diff-查看差异"><a href="#git-diff-查看差异" class="headerlink" title="git diff 查看差异"></a>git diff 查看差异</h2><p><code>git diff</code> 比较工作区与暂存区的差异</p><p><code>git diff HEAD</code>  比较工作区与本地仓库之间的差异</p><p><code>git diff --cached/--staged</code> 比较暂存区与本地仓库之间的差异</p><p><code>git diff HEAD~&lt;number&gt; HEAD</code> 比较提交之间的差异</p><p><code>git diff &lt;branch_name&gt; &lt;bracnch_name&gt;</code> 比较分支之间的差异</p><h2 id="git-rm-删除文件"><a href="#git-rm-删除文件" class="headerlink" title="git rm 删除文件"></a>git rm 删除文件</h2><p><code>rm file;git add file</code> 先从工作区中删除文件，然后再暂存删除内容</p><p><code>git rm &lt;file&gt;</code> 把文件从工作区和暂存区中同时删除</p><p><code>git rm --cached &lt;file&gt;</code> 把文件从暂存区删除，但保留在当前工作区中</p><p><code>git rm -r *</code> 递归删除某个目录下的所有子目录和文件</p><p><strong>删除后不要忘记提交</strong></p><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h2><p>所有被忽略的文件都会被保存在一个 .gitignore 文件中。</p><p>.gitignore 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 .gitignore 中，你可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。你也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><p>.gitignore文件的匹配规则：</p><ul><li>空行或者以 <code>#</code>  开头的行会被Git忽略。一般空行用于可读性的分隔，<code>#</code> 一般用作注释</li><li>使用标准的Blob模式匹配，例如：<ul><li>星号 <code>*</code> 通配任意个字符</li><li>问号 <code>?</code> 匹配单个字符</li><li>中括号 <code>[]</code> 表示匹配列表中的单个字符，比如：<code>[abc]</code> 表示 <code>a/b/c</code></li></ul></li><li>两个星号 <code>**</code> 表示匹配任意的中间目录</li><li>中括号可以使用短中线连接，比如：<ul><li><code>[0-9]</code> 表示任意一位数字，<code>[a-z]</code> 表示任意一位小写字母</li></ul></li><li>感叹号 <code>!</code> 表示取反</li></ul><h2 id="SSH-配置和克隆仓库"><a href="#SSH-配置和克隆仓库" class="headerlink" title="SSH 配置和克隆仓库"></a>SSH 配置和克隆仓库</h2><p>…… 未完待续 </p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 学习 1</title>
    <link href="/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2022/08/08/Linux-%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux-文件权限学习"><a href="#Linux-文件权限学习" class="headerlink" title="Linux 文件权限学习"></a>Linux 文件权限学习</h1><h2 id="用户与用户组"><a href="#用户与用户组" class="headerlink" title="用户与用户组"></a>用户与用户组</h2><ol><li><p>文件拥有者(root)</p></li><li><p>一般用户组</p></li><li><p>其他人</p></li></ol><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>在终端输入 <code>ls -al</code> 后，就会出现一堆东西，其中在每一行的前面的是文件的权限，共有10个字符，</p><ul><li><p>第一个字符代表这个文件是目录、文件或链接文件。</p><ul><li><p><code>d</code> 则是目录</p></li><li><p><code>-</code> 则是文件</p></li><li><p><code>l</code> 则是链接文件</p></li></ul></li><li><p>接下来三个为一组，共三组；其中 <code>r</code> 表示可读，<code>w</code> 表示可写，<code>x</code> 表示可执行</p><ul><li><p>第一组 <strong>文件拥有者(root)</strong> 可具备的权限</p></li><li><p>第二组 <strong>一般用户</strong> 的权限</p></li><li><p>第三组 <strong>没有加入本用户组的其他账号</strong> 的权限</p></li></ul></li></ul><h2 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h2><ul><li><p><code>chgrp</code></p><ul><li><p>修改文件所属用户组</p></li><li><p>参数 <code>-R</code> ：进行递归修改</p></li><li><p>语法：<code>chgrp [-R][user] dir/file</code></p></li></ul></li><li><p><code>chown</code></p><ul><li><p>修改文件拥有者</p></li><li><p>语法：<code>chown [-R] [owner][:group] file</code></p></li></ul></li><li><p><code>chmod</code></p><ul><li><p>修改权限</p></li><li><p>数字类型修改权限：<code>r=4,w=2,x=1</code>，每种身份的的权限需要累加的，例如<code>owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=0+0+0=0</code>，所以权限数字是 770，</p></li><li><p>符号类型修改权限：身份 <code>u=user,g=group,o=others</code>，<code>+(加入),-(移除),=(设置)</code></p></li><li><p>语法：<code>chmod [-R] [xyz] file/dir</code> 或者 <code>chmod [ugo...][[+-=][rwxX]] file/dir</code></p></li></ul></li></ul><h2 id="目录与文件的权限意义"><a href="#目录与文件的权限意义" class="headerlink" title="目录与文件的权限意义"></a>目录与文件的权限意义</h2><h3 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h3><ul><li><p>r(read)：可读取此文件的实际内容</p></li><li><p>w(write)：可以编辑，修改此文件的内容</p></li><li><p>x(execute)：该文件具有被系统执行的权限</p></li></ul><p>注意，文件是否能被执行，与文件名后缀无关，与 x 权限有关，记得与 Windows 区分开</p><p>有 w 权限，但并不具备有删除文件本身的权限</p><h3 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h3><ul><li><p>r：具有读取目录结构的权限</p></li><li><p>w：改动该目录结构列表的权限</p></li><li><p>x：用户能否进入该目录成为工作目录（目前所在的目录）</p></li></ul><p>开放目录给任何人看时，应该至少给予 r 或 x 的权限。</p><p>先这样吧，有时间在来整理。</p>]]></content>
    
    
    <categories>
      
      <category>学习随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Python opencv 缩放图像</title>
    <link href="/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/04/29/%E4%BD%BF%E7%94%A8-Python-opencv-%E7%BC%A9%E6%94%BE%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>突发奇想来用 Python 来缩放图像，搜到可以用 opencv 来实现功能，就稍微了解一下，当然 opencv 的功能不只这些。</p><p><strong>注意</strong>：此处所有 <code>cv</code> 在实际写时改成 <code>cv2</code> 或者在导入库时加入一句 <code>import cv2 as cv</code></p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h3><p>可以用 <code>cv.imread()</code> 来读取图像，一共有两个参数，第一个提供图片所在目录，第二个是一个标志，表示读取的方式：</p><ul><li><p>cv.IMREAD_COLOR ：加载彩色图像，默认</p></li><li><p>cv.IMREAD_GRAYSCALE：以灰度模式加载图像</p></li><li><p>cv.IMREAD_UNCHANGED：加载图像</p></li></ul><p><strong>注意</strong>：即使图像路径错误，它也不会引发任何错误，但是 <code>print img</code> 会给出 <code>None</code></p><h3 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h3><p>使用函数 <code>cv.imshow()</code> 在窗口上显示图像，窗口自动适合图像尺寸。</p><p>第一个参数是字符串，表示窗口名，第二个参数是我们需要显示的图片的参数。</p><p>一般配合以下函数使用：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">cv.imshow(<span class="hljs-string">&#x27;img&#x27;</span>,img)<br>cv.waitKey(<span class="hljs-number">0</span>)<br>cv.destoryAllWindows()<br></code></pre></div></td></tr></table></figure><p><code>cv.waitKey()</code> 是一个控制键盘的函数。其参数是以毫秒为单位的时间。如果您在这段时间内按下任何键，程序将继续运行。如果 <code>0</code> 被传递，它将无限期地等待一次敲击键。</p><h3 id="写入图像"><a href="#写入图像" class="headerlink" title="写入图像"></a>写入图像</h3><p>使用 <code>cv.imwrite()</code> 保存图像，第一个参数是文件名，第二个参数是要保存的图像。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>使用函数 <code>cv.resize()</code>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">resize(src, dsize, dst=<span class="hljs-literal">None</span>, fx=<span class="hljs-literal">None</span>, fy=<span class="hljs-literal">None</span>, interpolation=<span class="hljs-literal">None</span>)<br></code></pre></div></td></tr></table></figure><p><code>scr</code>：是需要缩放的图片的对象</p><p><code>dsize</code>：目标图像大小。当 dsize 为 0 时，通过以下公式计算得出：</p><ul><li><code>disize = Size(round(fx*scr.cols) , round(fy*src.rows))</code></li></ul><p>所以 <code>disze</code> 与 <code>(fx , fy)</code> 不能同时为 0 </p><p><code>fx,fy</code> ：水平和垂直轴的比例因子。当它为零时，计算公式如下：<code>(double)dsize.width/src.cols</code> 和 <code>(double)dsize.width/src.cols</code></p><p><code>interpolation</code> ：插值方法，具体我也不太懂，最好使用 <code>cv.INTER_LINEAR</code> 参数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Distant-Skys</span><br><span class="hljs-comment"># To make a picture smaller or bigger.</span><br><br><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>image = cv.imread(<span class="hljs-string">&#x27;1.jpg&#x27;</span>)<br><br>res = cv.resize(image,<span class="hljs-literal">None</span>,fx=<span class="hljs-number">0.7</span>,fy=<span class="hljs-number">0.7</span>,interpolation=cv.INTER_CUBIC)<br><span class="hljs-comment"># if want to make picture bigger ,let ((fx and fy) &gt; 1).</span><br><br><span class="hljs-comment"># print the result picture.</span><br><span class="hljs-comment"># cv.imshow(&#x27;result image&#x27;,res)</span><br><span class="hljs-comment"># cv.waitKey(0)</span><br><span class="hljs-comment"># cv.destroyAllWindows()</span><br><br>cv.imwrite(<span class="hljs-string">&#x27;1_result.jpg&#x27;</span>,res)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC235E-MST+1题解</title>
    <link href="/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/01/29/ABC235E-MST-1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ABC235E-MST-1-题解"><a href="#ABC235E-MST-1-题解" class="headerlink" title="ABC235E MST+1 题解"></a>ABC235E MST+1 题解</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个图 $G$ 含有 $n$ 个顶点和 $m$ 条边，给出 $Q$ 次询问，询问所多输入的边加上原图 $G$ 的最小生成树是否是存在 $e_i$，存在输出 <code>Yes</code> 不存在输出 <code>No</code>。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们可以想到用最简单的方法，在每次询问时都做一次 Kruskal 算法，如果这个边被取到了，那么输出 <code>Yes</code>，反之亦然。时间复杂度为 $\mathcal{O}(Q \times n  \log n)$，太慢。</p><p>因为每个询问是相互独立的，而且询问的边 $e_i$ 对于 并查集 的不会产生影响，所以可以想到只用一次 Kruskal 算法，把所有的边都涵盖上。</p><p>在遍历时每条边的处理方法：</p><ul><li><p>如果是询问的 $e_i$ 的边</p><ul><li><p>如果 $e_i$ 的所连的两个顶点 $u,v$ 没有连通，则标记为 <code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是询问的 $e_i$ 的边</p><ul><li><p>如果 $e_i$ 的所连的两个顶点 $u,v$ 没有连通，则标记为 <code>Yes</code>。</p></li><li><p>如果连通，则标记为 <code>No</code>。</p></li></ul></li><li><p>如果是 $G$ 的边        </p><ul><li>将两个顶点在并查集内合并</li></ul></li></ul><p>时间复杂度 $\mathcal{O}((n+Q) \log (n + Q))$。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">200005</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><span class="hljs-keyword">int</span> u,v,w,Is,num;&#125;;<br><span class="hljs-keyword">int</span> fa[maxn];<br>Edge e[maxn*<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> ans[maxn];<br><span class="hljs-keyword">int</span> n,m,q;<br>vector&lt;Edge&gt; qe;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-keyword">const</span> Edge &amp;a,<span class="hljs-keyword">const</span> Edge &amp;b)&#123;<span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (a.u == b.u &amp;&amp; a.v == b.v &amp;&amp; a.w == b.w);&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">found</span>(fa[x]);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge x,Edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w &lt; y.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init_Onion</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)    fa[x] = x;<br>    <span class="hljs-built_in">memset</span>(ans,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans));<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>        e[i].Is = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[m+i].u,&amp;e[m+i].v,&amp;e[m+i].w);<br>        e[m+i].Is = <span class="hljs-number">1</span>;e[m+i].num = i;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+q+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-built_in">Init_Onion</span>();<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m+q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(e[i].Is == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(e[i].v) != <span class="hljs-built_in">found</span>(e[i].u))<br>                ans[e[i].num] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> u = e[i].u,v = e[i].v;<br>        <span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(u),t = <span class="hljs-built_in">found</span>(v);<br>        fa[t] = f;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)&#123;<br>        <span class="hljs-keyword">if</span>(ans[i] == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);#<span class="hljs-number">191B</span>1C<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Atcoder</tag>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ATCoder ABC 001</title>
    <link href="/2021/11/06/ATCoder-ABC-001/"/>
    <url>/2021/11/06/ATCoder-ABC-001/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ATCoder-ABC-001"><a href="#ATCoder-ABC-001" class="headerlink" title="ATCoder ABC 001"></a>ATCoder ABC 001</h1><p><a href="https://atcoder.jp/contests/abc001/tasks">题目链接</a></p><h2 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h2><p>太简单了，不放代码了。</p><h2 id="B-题"><a href="#B-题" class="headerlink" title="B 题"></a>B 题</h2><p>其实，就是模拟，只是需要注意边界问题，是一个左开右闭的区间。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> m;<br><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">0</span> &amp;&amp; m &lt;= <span class="hljs-number">5000</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">1000</span>)<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; (<span class="hljs-number">10</span> * m) / <span class="hljs-number">1000</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">5000</span> &amp;&amp; m &lt;= <span class="hljs-number">30000</span>)<br>        cout &lt;&lt; m / <span class="hljs-number">1000</span> + <span class="hljs-number">50</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m &gt; <span class="hljs-number">30000</span> &amp;&amp; m &lt;= <span class="hljs-number">70000</span>)<br>        cout &lt;&lt; (m / <span class="hljs-number">1000</span> - <span class="hljs-number">30</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">80</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-number">89</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="C-题"><a href="#C-题" class="headerlink" title="C 题"></a>C 题</h2><p>同样是模拟，只是 <code>else if</code>  的数量有点多，注意边界，同上。</p><p>这道题目需要求一个保留两位小数的浮点数，所以需要自己手写函数 <code>Around</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Around</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x,<span class="hljs-keyword">double</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">floor</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k)*x+<span class="hljs-number">0.5</span>) / <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,k);<br>    <span class="hljs-comment">// 保留两位小数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-keyword">int</span> cmp,meter;<span class="hljs-keyword">double</span> speed,sid;<br>    cin&gt;&gt;sid&gt;&gt;meter;<br>    speed = meter / <span class="hljs-number">60.0</span>;<br>    speed = <span class="hljs-built_in">Around</span>(speed,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">112.5</span> &amp;&amp; sid &lt;= <span class="hljs-number">337.5</span>)        s = <span class="hljs-string">&quot;NNE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">337.5</span> &amp;&amp; sid &lt; <span class="hljs-number">562.5</span>)    s = <span class="hljs-string">&quot;NE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">562.5</span> &amp;&amp; sid &lt; <span class="hljs-number">787.5</span>)    s = <span class="hljs-string">&quot;ENE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">787.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1012.5</span>)    s = <span class="hljs-string">&quot;E&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1012.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1237.5</span>)    s = <span class="hljs-string">&quot;ESE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1237.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1462.5</span>)    s = <span class="hljs-string">&quot;SE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1462.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1687.5</span>)    s = <span class="hljs-string">&quot;SSE&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1687.5</span> &amp;&amp; sid &lt; <span class="hljs-number">1912.5</span>)    s = <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">1912.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2137.5</span>)    s = <span class="hljs-string">&quot;SSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2137.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2362.5</span>)    s = <span class="hljs-string">&quot;SW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2362.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2587.5</span>)    s = <span class="hljs-string">&quot;WSW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2587.5</span> &amp;&amp; sid &lt; <span class="hljs-number">2812.5</span>)    s = <span class="hljs-string">&quot;W&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">2812.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3037.5</span>)    s = <span class="hljs-string">&quot;WNW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3037.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3262.5</span>)    s = <span class="hljs-string">&quot;NW&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sid &gt;= <span class="hljs-number">3262.5</span> &amp;&amp; sid &lt; <span class="hljs-number">3487.5</span>)    s = <span class="hljs-string">&quot;NNW&quot;</span>;<br>    <span class="hljs-keyword">else</span>    s = <span class="hljs-string">&quot;N&quot;</span>;<br><br>    <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">0.2</span>)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C 0\n&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">0.3</span> &amp;&amp; speed &lt;= <span class="hljs-number">1.5</span>)    cmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">1.6</span> &amp;&amp; speed &lt;= <span class="hljs-number">3.3</span>)    cmp = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">3.4</span> &amp;&amp; speed &lt;= <span class="hljs-number">5.4</span>)    cmp = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">5.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">7.9</span>)    cmp = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">8.0</span> &amp;&amp; speed &lt;= <span class="hljs-number">10.7</span>)    cmp = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">10.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">13.8</span>)    cmp = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">13.9</span> &amp;&amp; speed &lt;= <span class="hljs-number">17.1</span>)    cmp = <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">17.2</span> &amp;&amp; speed &lt;= <span class="hljs-number">20.7</span>)    cmp = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">20.8</span> &amp;&amp; speed &lt;= <span class="hljs-number">24.4</span>)    cmp = <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">24.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">28.4</span>)    cmp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(speed &gt;= <span class="hljs-number">28.5</span> &amp;&amp; speed &lt;= <span class="hljs-number">32.6</span>)    cmp = <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">else</span>    cmp = <span class="hljs-number">12</span>;<br><br><br>    cout&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cmp&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="D-题"><a href="#D-题" class="headerlink" title="D 题"></a>D 题</h2><p>比较简单的思维题。</p><p>输入时，注意时间为 5 分钟为增量舍入时间，观察题目发现时间总是从 $0000 \Rightarrow 9999$。所以可以想到开一个桶，第 $i$ 个桶表示第 $i$ 个时间是否有雨。最后重新遍历一次桶，记录下开始和结束的节点并输入。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">110000</span>;<br><span class="hljs-keyword">int</span> g[maxn];<br><span class="hljs-keyword">int</span> t;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=t;i++)&#123;<br>        <span class="hljs-keyword">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;x,&amp;y);<br>        x -= (x%<span class="hljs-number">5</span>);y += (<span class="hljs-number">5</span> - y%<span class="hljs-number">5</span>) % <span class="hljs-number">5</span>;<br>        <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(y%<span class="hljs-number">100</span>&gt;=<span class="hljs-number">60</span>)&#123;<br>            y+=<span class="hljs-number">100</span>;<br>            y-=<span class="hljs-number">60</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=x;j&lt;y;j++)    g[j] ++;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> on=<span class="hljs-number">0</span>,be=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">110000</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[i])&#123;<br>            <span class="hljs-keyword">if</span>(!on)be=i;<br>            on=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(on)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d-%04d\n&quot;</span>,be,i);<br>            on=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ATCoder</tag>
      
      <tag>简单题</tag>
      
      <tag>模拟</tag>
      
      <tag>思维题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2021/10/06/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><img src="https://z3.ax1x.com/2021/10/06/4x2h9K.png" alt="并查集"></p><p>并查集是一种树形的数据结构，可以很高效的解决一些问题。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>有三个操作：</p><ul><li>初始化</li><li>查找</li><li>合并</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始时，每个点都是自己的父亲。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> fa[maxn];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i ++)<br>    fa[i] = i;<br></code></pre></div></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><img src="https://z3.ax1x.com/2021/10/06/4xWYiq.png" alt=""></p><p>上图中，想要找 $5$ 的祖先，先通过 $2-5$ 这条边找到 $2$ ，通过同样的办法找到祖先 $1$，$1$ 没有祖先就得到答案了。<br>就像上面一样递归找到每个点的祖先，在返回答案。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == fa[x])<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>显而易见，就是将两个集合合并。</p><p><img src="https://z3.ax1x.com/2021/10/06/4zwqgA.png" alt="union"></p><p>挺简单的，就直接上代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(v);<br>    fa[u] = v;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>设操作次数为 $m$，平均时间复杂度为 $\mathcal{O}(m \log n)$，最坏时间复杂度为 $\mathcal{O}(mn)$。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在上面的操作中还是不够快，所以我们想办法优化。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>如果一个关系像一条链（如下图）一样，那么查找最下面的数的祖先的时间复杂度得退化到 $\mathcal{O}(n)$ 。</p><p><img src="https://z3.ax1x.com/2021/10/06/4z0LiF.png" alt="chain"></p><p>这样一层一层找太浪费时间，直接当祖先的儿子，问一次就可以出结果了。甚至祖先是谁都无所谓，只要这个人可以代表我们家族就能得到想要的效果。<strong>把在路径上的每个节点都直接连接到根上</strong>。</p><p><em>代码</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>查找都优化了，那合并总不能不优化吧。</p><p>我们思考一个问题：如果一个点与一个含有 $100$ 个点的集合合并，是一个点合并到 $100$ 个点的集合快？还是 $100$ 个点合并到一个点快？答案是显然的。<br>在题目中我们通常维护 点数 或 深度 来作为估价函数来合并</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br>    <span class="hljs-keyword">if</span>(u == v) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(sz[u] &gt; sz[v])<br>        <span class="hljs-built_in">swap</span>(u，v);<br>    fa[u] = v;<br>    sz[v] += sz[u];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="优化后的时间复杂度"><a href="#优化后的时间复杂度" class="headerlink" title="优化后的时间复杂度"></a>优化后的时间复杂度</h3><ul><li>只使用路径压缩的平均时间复杂度为 $\mathcal{O}(m \alpha(n))$，最坏时间复杂度为 $\mathcal{O}(m \log n)$</li><li>只使用启发式合并的平均时间复杂度为 $\mathcal{O}(m \log n)$，最坏时间复杂度为 $\mathcal{O}(m \log n)$。</li><li>路径压缩 + 启发式合并的平均时间复杂度为 $\mathcal{O}(m \alpha(n))$，最坏时间复杂度为 $\mathcal{O}(m \alpha(n))$。</li></ul><p>这里 $\alpha(n)$ 表示阿克曼函数的反函数增长很慢，可以认为是常数(<a href="https://oi-wiki.org/ds/dsu/#_7">具体在这</a>)。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><p>我们可以在并查集上维护一些东西，比如元素和，元素个数。</p><p>比如说<a href="https://www.luogu.com.cn/problem/UVA11987">Almost Union-Find</a>这道题。它就是在并查集上维护一个元素和与元素个数，唯一不同的是这道题要一个虚点并查集，防止在第二个操作中下面的元素一起移动。</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br> fa[i] = n+i;<br>        <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n+<span class="hljs-number">1</span>;i&lt;=n+n;i++)<br>fa[i] = i,sz[i] = <span class="hljs-number">1</span>,sum[i] = i-n;<br><br><span class="hljs-comment">// 第二个操作，仅仅将一个节点移动到另一个集合上。</span><br><br><span class="hljs-keyword">int</span> u = <span class="hljs-built_in">find</span>(x),v = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(u != v)&#123;<br>fa[x] = v;<br>sz[u] --;sz[v] ++;<br>sum[u] -= x;sum[v] += x;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵</title>
    <link href="/2021/09/18/%E7%9F%A9%E9%98%B5/"/>
    <url>/2021/09/18/%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。</p><p>就像下面一样：</p><script type="math/tex; mode=display">\begin{bmatrix}    1&2&3\\1&2&3\end{bmatrix}</script><p>特别的，主对角线上为 1，其余位置为 0 的叫做单位矩阵 $I$：</p><script type="math/tex; mode=display">\begin{bmatrix}    1&0&\cdots&0\\    \vdots&1&\ddots&0\\    0&0&\dots&1\\\end{bmatrix}</script><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><p>矩阵的加减法是逐个元素进行的。</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>矩阵相乘只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。</p><p>设 $P$ 为 $M \times N$ 的矩阵，$Q$ 是 $N \times Q$ 的矩阵，$C$ 矩阵为 $C = PQ$，则 $C$ 矩阵上 $i$ 行 $j$ 列的元素为。</p><script type="math/tex; mode=display">c_{i,j} = \sum\limits_{k=1}^{M}P_{i,k}Q_{k,j}</script><p>没有看懂，没事，有一种<del>比较简单</del>的方法。</p><p>设 $A$ 矩阵为:</p><script type="math/tex; mode=display">\begin{bmatrix}    a&b\\    c&d\\\end{bmatrix}</script><p>设 $B$ 矩阵为:</p><script type="math/tex; mode=display">\begin{bmatrix}    e\\f\end{bmatrix}</script><p>所以 $A$ 与 $B$ 的乘积是：</p><script type="math/tex; mode=display">e\begin{bmatrix}    a\\c\end{bmatrix} + f\begin{bmatrix}    b\\d\end{bmatrix}</script><p>注意，<strong>矩阵乘法满足结合律，不满足一般的交换律</strong>。</p><p>给出一个封装好的矩阵乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[N][N];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unit</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)   c[i][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mat</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat &amp;M)&#123;<br>mat ans;<br><span class="hljs-built_in">memset</span>(ans.c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ans.c);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>ans.c[i][j] += (c[i][k] * M.c[k][j]) % P,ans.c[i][j] %= P;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>如果算一个矩阵的 $A^k$，可以使用快速幂来加速到 $\mathcal{O}(n^3 \log k)$。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂</span><br><span class="hljs-function">mat <span class="hljs-title">qpow</span><span class="hljs-params">(mat x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    mat ans.<span class="hljs-built_in">unit</span>();<br>    <span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = ans * x;<br>        y = y / <span class="hljs-number">2</span>;<br>        x = x * x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="矩阵的应用"><a href="#矩阵的应用" class="headerlink" title="矩阵的应用"></a>矩阵的应用</h2><h3 id="快速求斐波拉契数列"><a href="#快速求斐波拉契数列" class="headerlink" title="快速求斐波拉契数列"></a>快速求斐波拉契数列</h3><p>斐波拉契数列形如：</p><script type="math/tex; mode=display">F_1 = F_2 = 1,F_i = F_{i-1} + F_{i-2}  (i  \geq 3)</script><p>当然可以使用递推的方法来求，时间复杂度 $\mathcal{O}(n)$ ，还挺快。<br>但是遇到<a href="https://www.luogu.com.cn/problem/P1962">这道题目</a>就不行了，$2^{63}$ 绝对会 TLE，所以可以用矩阵加速递推。</p><p>我们可以设 <script type="math/tex">f(n) = \begin{bmatrix}F_{n} & F_{n-1}\end{bmatrix}</script> ，我们希望可以从 $f(n-1)$ 推出它。</p><p>正好我们之前学了矩阵的乘法，所以我们可以尝试设一个矩阵 $\text{base}$ ，使得 $f(n) = \text{base} \times f(n-1)$，也就是：</p><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = \text{base} \times \begin{bmatrix}F_{i-1} & F_{i-2}\end{bmatrix}</script><p>因为前后都是 $1 \times 2$ 的矩阵，所以可以知道 $\text{base}$ 矩阵是 $2 \times 2$ 的矩阵。</p><p>所以 $\text{base} = \begin{bmatrix}<br>a &amp; b \<br>c &amp; d \<br>\end{bmatrix}$</p><p>xxxxxxxxxx17 1# Distant-Skys2# To make a picture smaller or bigger.3​4import cv2 as cv5import numpy as np6​7image = cv.imread(‘1.jpg’)8​9res = cv.resize(image,None,fx=0.7,fy=0.7,interpolation=cv.INTER_CUBIC)10# if want to make picture bigger ,let ((fx and fy) &gt; 1).11​12# print the result picture.13# cv.imshow(‘result image’,res)14# cv.waitKey(0)15# cv.destroyAllWindows()16​17cv.imwrite(‘1_result.jpg’,res)python</p><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = F_{i-1} \times \begin{bmatrix}a & b\end{bmatrix} + F_{i-2} \times \begin{bmatrix}c & d\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} F_i & F_{i-1}\end{bmatrix} = \begin{bmatrix}a F_{i-1} + c F_{i-2}  & b F_{i-1} + d F_{i-2}\end{bmatrix}</script><p>又因为 <script type="math/tex">F_i = F_{i-1} + F_{i-2}</script>，所以 <script type="math/tex">a = 1,c = 1,b = 1,d = 0</script>。</p><p>综上所述， <script type="math/tex">\text{base} = \begin{bmatrix} 1 & 1 \\1 & 0\end{bmatrix}</script>。</p><p>那么因为初始项为 $F_1,F_2$。所以 $F_n = \begin{bmatrix} F_1 &amp; F_2 \end{bmatrix} \times \text{base}^{n-2}$</p><p>好好品品。</p><p>$\text{base}^{n-2}$ 矩阵可以通过上面的快速幂来求，所以时间复杂度为 $\mathcal{O}(\log n)$。</p><p>这题核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mat</span>&#123;</span><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><span class="hljs-built_in">mat</span>() &#123;<span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(c));&#125;<br><span class="hljs-keyword">inline</span> mat <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> mat&amp; M)&#123;<br>mat res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=<span class="hljs-number">2</span>;k++)<br>res.c[i][j] = (res.c[i][j] + c[i][k]*M.c[k][j]) % mod;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br>&#125;;<br><br>mat base,ans;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>base.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = base.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = base.c[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = ans.c[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span></span>&#123;<br><span class="hljs-keyword">while</span>(y &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(y % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>ans = ans * base;<br>y = y / <span class="hljs-number">2</span>;<br>base = base * base;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>其实矩阵可以干事情的很多，就写这么多吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习线段树总结</title>
    <link href="/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/22/%E5%AD%A6%E4%B9%A0%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天在复习 qbxt 的知识，学到了线段树，就来总结一下。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p><img src="https://z3.ax1x.com/2021/08/17/f4sLWR.png" alt=""></p><p>上面这张图显然是线段树，线段树就是一个处理区间的一个数据结构，将整个线段划分成一个树的结构，将长度不是 1 的段划分成两个子区间来求解，通过合并两个区间的信息来求解，这也是一个高效的数据结构。</p><p>总体时间复杂度为 $O(\log n)$  </p><ul><li>适用范围：区间的最小值或最大值，区间的修改，区间求和</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>在所有操作开始之前，可以观察到一个根节点为 $p$ 的左儿子为 $p^2$ ，右儿子为  $p^2+1$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ls</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x&lt;&lt;<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 左儿子 left sons</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&lt;&lt;<span class="hljs-number">1</span>)+<span class="hljs-number">1</span>;&#125;   <span class="hljs-comment">// 右儿子 right sons</span><br></code></pre></div></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>我们可以想到像树上 DFS 一样，可以一直访问儿子节点，直到儿子节点长度为 1  ，我们可以通过数据上的值去更改子节点的值，再有子节点来合并（更新）父节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">// 建树 [l,r] 为当前的区间，p 为当前的节点编号</span><br>lazy[p] = <span class="hljs-number">1</span>;<span class="hljs-comment">// lazy_tag 后面会讲到</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果 长度为 1 </span><br>d[p] = a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 递归求解</span><br><span class="hljs-built_in">built</span>(l,mid,<span class="hljs-built_in">ls</span>(p));<span class="hljs-built_in">built</span>(mid+<span class="hljs-number">1</span>,r,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)] ;  <span class="hljs-comment">// 由儿子更新父亲，合并</span><br>    <span class="hljs-comment">// 如果是求最大值，改成 d[p] = max(d[ls(p)],d[rs(p)]);最小值同样 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>首先，我们可以想到还是像建树一样递归求解，如果这个区间在所要求的区间上了，直接返回，如果左儿子的子区间和原答案有交集，那么就递归到相应的节点上求解。那么思路就讲好了，代码怎么写呢？下面放上几张图就了解了</p><p>设所在区间为 $[l,r]$ , 查询区间为 $[s,t]$ 。</p><p><img src="https://z3.ax1x.com/2021/08/20/fj97CQ.jpg" alt="tree"></p><p>那么根据这张图可以很显然的推出所在区间在查询区间的判断方式：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(s &lt;= l &amp;&amp; r &lt;= t)<br></code></pre></div></td></tr></table></figure><p>设中间位置为 $mid = \dfrac{(l+r)}{2}$  。</p><p><img src="https://z3.ax1x.com/2021/08/20/fjiS1J.jpg" alt=""></p><p>可以很<del>简单</del>的看出，进入左儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &gt;= s)<br></code></pre></div></td></tr></table></figure><p>进入右儿子的条件是：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(mid &lt; t)<br></code></pre></div></td></tr></table></figure><p>综上，我们可以得出查询代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,t 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> d[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">pushdown</span>(p,l,r); <br>LL sum = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,t,<span class="hljs-built_in">ls</span>(p));    <span class="hljs-comment">// 如果是求最大值，就改成</span><br><span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同样</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>在讲区间修改之前，我先来讲一下最基础的单点修改。单点修改也是递归找需要更改的点，然后再返回合并父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> f,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 当前 p 节点的范围，f 是修改的点的编号， c 是修改的值</span><br><span class="hljs-keyword">if</span>(l == r)&#123;<span class="hljs-comment">// 如果递归到所达到的点了</span><br>d[p] = c;<br><span class="hljs-comment">// 如果是加上 c ，改成</span><br><span class="hljs-comment">// d[p] += c;</span><br>        <span class="hljs-comment">// 减去同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= f)<span class="hljs-comment">// 如果所要修改的点在左儿子上，进入左儿子</span><br><span class="hljs-built_in">update</span>(l,mid,f,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,f,c,<span class="hljs-built_in">rs</span>(p));<br>d[p] = d[<span class="hljs-built_in">ls</span>(p)] + d[<span class="hljs-built_in">rs</span>(p)];<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// d[p] = max(d[ls(p)] + d[rs(p)]);</span><br>    <span class="hljs-comment">// 最小值同理</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><ul><li><p>懒标记</p><p>简单来说，就是通过<strong>延迟</strong>对节点信息的更改，从而减少可能不必要的操作次数。每次执行修改时，我们通过打标记的方法表明该节点对应的区间在某一次操作中被更改，但不更新该节点的子节点的信息。实质性的修改则在下一次访问带有标记的节点时才进行。</p><div class="hljs code-wrapper"><pre><code>                                                                                                                                                                ----- OI-Wiki</code></pre></div></li></ul><p>这段话<del>深刻的阐释了</del>懒标记的作用，如果不用懒标记时间复杂度将会达到 $\mathcal{O}(n \log n)$ 有点慢，这样一来时间复杂度为 $\mathcal{O}(\log n)$ 的。</p><p>听我这样一讲有点蒙先来看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// [l,r] 为当前的, [s,t] 为询问的</span><br><span class="hljs-keyword">if</span>(l &gt;= s &amp;&amp; r &lt;= tt)&#123;<br>t[p] += (r-l+<span class="hljs-number">1</span>)*c;lazy[p] += c  <span class="hljs-comment">//懒标记;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p] &amp;&amp; l!=r)&#123; <span class="hljs-comment">// 懒标记的更新</span><br>t[<span class="hljs-built_in">ls</span>(p)] += (mid-l+<span class="hljs-number">1</span>)*lazy[p];t[<span class="hljs-built_in">rs</span>(p)] += (r-mid) * lazy[p];<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br><span class="hljs-built_in">update</span>(l,mid,s,tt,c,<span class="hljs-built_in">ls</span>(p));<br><span class="hljs-keyword">if</span>(tt &gt; mid)<br><span class="hljs-built_in">update</span>(mid+<span class="hljs-number">1</span>,r,s,tt,c,<span class="hljs-built_in">rs</span>(p));<br>t[p] = t[<span class="hljs-built_in">ls</span>(p)] + t[<span class="hljs-built_in">rs</span>(p)];<br>&#125;<br></code></pre></div></td></tr></table></figure><p>举个例子吧：</p><p><img src="https://z3.ax1x.com/2021/08/22/hpaTg0.png" alt="step1"></p><p>如果我想要更改 $[9,10]$ 的每个数加上 5，我们可以先直接在这个区间上改，并给它们打上标记。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpdV5d.png" alt="step2"></p><p>虽然，子节点没有更新值，但当我们要查询这两个子节点的信息时，我们会利用标记修改这两个子节点的信息，使查询的结果依旧准确。</p><p>现在，来查询一下 $[9,9]$ 的值，当递归到 $[9,10]$ 时，因为懒标记不为 0 ，所以将该区间的子区间更新并清零。</p><p><img src="https://z3.ax1x.com/2021/08/22/hpduxP.png" alt="step3"></p><p>当然为了编写的简单性，修改懒标记可以写一个单独的函数 <code>pushdown</code> 。</p><p>带乘法的查询也同理，只是新加一个乘法懒标记而已</p><h3 id="带懒标记的查询"><a href="#带懒标记的查询" class="headerlink" title="带懒标记的查询"></a>带懒标记的查询</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> tt,<span class="hljs-keyword">int</span> p)</span></span>&#123;<br><span class="hljs-comment">// l,r 为当前的, s,tt 为询问的</span><br><span class="hljs-keyword">if</span>(l&gt;=s &amp;&amp; r &lt;= tt)<br><span class="hljs-keyword">return</span> t[p];<br><span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(lazy[p])&#123;<br>t[<span class="hljs-built_in">ls</span>(p)] += lazy[p] * (mid-l+<span class="hljs-number">1</span>);t[<span class="hljs-built_in">rs</span>(p)] += lazy[p] * (r-mid);<br>lazy[<span class="hljs-built_in">ls</span>(p)] += lazy[p];lazy[<span class="hljs-built_in">rs</span>(p)] += lazy[p];<br>lazy[p] = <span class="hljs-number">0</span>;<br>&#125;<br>LL sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(mid &gt;= s)<br>sum += <span class="hljs-built_in">query</span>(l,mid,s,tt,<span class="hljs-built_in">ls</span>(p));<br>    <span class="hljs-comment">// 如果是求最大值，就改成</span><br>    <span class="hljs-comment">// sum = max(quert(l,mid,s,t,ls(p)),sum);     最小值同理</span><br><span class="hljs-keyword">if</span>(tt &gt; mid)<br>sum += <span class="hljs-built_in">query</span>(mid+<span class="hljs-number">1</span>,r,s,tt,<span class="hljs-built_in">rs</span>(p));<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>基本上有了这些操作就可以写以下几道题目：</p><ul><li><p>x 1// 初始化2​3for(int i=1;i&lt;=n;i++)4     fa[i] = n+i;5        6for(int i=n+1;i&lt;=n+n;i++)7    fa[i] = i,sz[i] = 1,sum[i] = i-n;8​9// 第二个操作，仅仅将一个节点移动到另一个集合上。10​11int u = find(x),v = find(y);12if(u != v){13    fa[x] = v;14    sz[u] —;sz[v] ++;15    sum[u] -= x;sum[v] += x;16}cpp</p><p>这道题是个纯模板题</p></li><li><p><a href="https://www.luogu.com.cn/problem/P3373">洛谷 P3373 【模板】线段树 2</a></p><p>这道题也差不多是个模板题，只是要注意：<strong>先乘后加</strong> 懒标记</p></li><li><p><a href="https://vjudge.net/problem/HDU-1166">HDU-1166 敌兵布阵</a></p><p>单点修改的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1754">HDU-1754 I Hate It</a></p><p>单点修改，查询最大值的模板</p></li><li><p><a href="https://vjudge.net/problem/HDU-1394">HDU-1394 Minimum Inversion Number</a> </p><p>线段树解决逆序对问题</p></li><li><p><a href="https://vjudge.net/problem/POJ-3468">POJ-3468 A Simple Problem with Integers</a></p><p>区间修改的模板题</p></li></ul><p>模板题/好题未完待续 $\dots \dots$ </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA1160题解</title>
    <link href="/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/"/>
    <url>/2021/08/22/UVA1160%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>并查集</li></ul><p>简单的查找（带路经压缩）:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>    <span class="hljs-comment">// fa[i] 为并查集的数组</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>查找（这里可以数据小完全不需要用启发式合并）：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br>    fa[f] = t;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>查阅资料可知，只用路径压缩，不用启发式合并的平均时间复杂度为 $\mathcal{O}(\alpha (n))$ ，最坏时间复杂度为 $\mathcal{O}(m \log n)$ 。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先可以将每个元素看成点，化合物看成边，因为如果有超过 3 个物品互相形成化合物就会爆炸，所以会爆炸的条件可以看成两个是在同一祖先（在同一集合）中，（如果这两个点有一个祖先的话，合并就会有 3 个物品在一起的）。</p><p>每一次都将不在一个集合中两个数合并。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">100010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x) == <span class="hljs-number">1</span>)&#123;    \\ 注意输入<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100010</span>;i++)fa[i] = i;<br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x != <span class="hljs-number">-1</span>)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">find</span>(x),t = <span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span>(f == t)ans ++;<br><span class="hljs-keyword">else</span><br>fa[f] = t;    <span class="hljs-comment">// 如果不会爆炸，就合并</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
      <tag>并查集</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python实现爬取UVA题库的PDF</title>
    <link href="/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/"/>
    <url>/2021/08/09/Python%E5%AE%9E%E7%8E%B0%E7%88%AC%E5%8F%96UVA%E9%A2%98%E5%BA%93%E7%9A%84PDF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我在一次看洛谷日报时了解到了有一个软件可以下载 UVA 的 PDF ， 我试了一下连接不上，可能是软件的作者太久没有更新了无法下载了，我便自己写了一个 Python ,可能有些不好的地方。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> urllib3<br><span class="hljs-keyword">import</span> time<br><br>url = <span class="hljs-string">&#x27;https://uva.onlinejudge.org/external/1/p&#x27;</span><br><br>urllib3.disable_warnings()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download</span>(<span class="hljs-params">name,url</span>):</span><br>    response = requests.get(url,verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 就是这个地方不能用异步，有没有大佬知道为什么</span><br>    <span class="hljs-built_in">print</span>(response)<br>    f = <span class="hljs-built_in">open</span>(name,<span class="hljs-string">&#x27;wb&#x27;</span>)<br>    f.write(response.content)<br>    f.close()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------------------&quot;</span>)<br>        i = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你所需要的 UVA 题号 ： &quot;</span>))<br>        time.sleep(<span class="hljs-number">3</span>)<br>        download(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>,url + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.pdf&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>注 ： 还会根据我的需要不定时更新</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UVA11426 GCD - Extreme (II)</title>
    <link href="/2021/07/28/UVA11426-GCD-Extreme-II/"/>
    <url>/2021/07/28/UVA11426-GCD-Extreme-II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="UVA11426-GCD-Extreme-II"><a href="#UVA11426-GCD-Extreme-II" class="headerlink" title="UVA11426 GCD - Extreme (II)"></a>UVA11426 GCD - Extreme (II)</h1><p>这几天我看了 LRJ 的书看到了这一题，就把这道题写了，正好这道题挺不错的。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://uva.onlinejudge.org/external/114/p11424.pdf">题目PDF</a></p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><ul><li>定义： $\varphi(n)$ 为小于等于 $n$ 与 $n$ 互质的数的个数</li></ul><p>它有一些有趣的性质：</p><ul><li>$\varphi(n)$  是积性函数 ： 如果有 $\gcd(i,j) = 1$ 那么就有 $\varphi(i \times j) = \varphi(i) \times \varphi(j)$</li></ul><h3 id="如何求欧拉函数："><a href="#如何求欧拉函数：" class="headerlink" title="如何求欧拉函数："></a>如何求欧拉函数：</h3><p>用一个类似于筛法求素数的方法，时间复杂度相似于埃氏筛法 $\mathcal{O}(n\log \log n)$</p><p><strong>模板代码</strong>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> phi[maxn];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">table</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i ++)<br>        phi[i] = <span class="hljs-number">0</span>;<br>    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;i ++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt;= n;j ++)&#123;<br>    <span class="hljs-keyword">if</span>(!phi[j])phi[j] = j;<br>    phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>    &#125;<br>   <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，我们能想到暴力，每一次将每一个的 $\gcd$ 求出 ，最差时间复杂度为 $\mathcal{O}(n^2\log n )$ ，太慢，在这个数据目前无能为力，所以想办法优化。</p><p>设 <script type="math/tex">\large f(n) = \sum\limits_{i=1}^{n-1}\gcd(i,n)</script> ，</p><p>所以答案为  <script type="math/tex">\large S(n) = \sum\limits_{i=1}^{n} f(i)</script>。</p><p><del>易证</del> ，$\gcd(i,n)$ 的值都是 n 的约数，我们好好看看这个柿子有什么优化的地方</p><p>设 $\dfrac{x}{i}$ ，所以 $\gcd(\dfrac{x}{i},\dfrac{n}{i}) = 1$</p><p>$\therefore$  $\dfrac{x}{i}$ 与 $\dfrac{n}{i}$ 互质</p><p>所以小于等于 $\dfrac{n}{i}$ 的互质的 $\dfrac{x}{i}$ 一共有 $\varphi(\dfrac{n}{i})$  个</p><p>又 $\because$   $\gcd(i,n)$  $\leqslant n$ </p><p>$\therefore $   $\large f(n) = \sum\limits_{i\subset A} i \times \varphi(\dfrac{n}{i})$  $( A = n$ 的约数 $)$ </p><p>上面的柿子就是我们所需要的，时间复杂度与求欧拉筛法同阶。</p><p>代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">4000000</span>;<br><br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> phi[maxn],s[maxn],f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">phi_c</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)phi[i] = <span class="hljs-number">0</span>;<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=maxn;i++)&#123;<br><span class="hljs-keyword">if</span>(!phi[i])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=maxn;j+=i)&#123;<br><span class="hljs-keyword">if</span>(!phi[j])<br>phi[j] = j;<br>phi[j] = phi[j] / i * (i<span class="hljs-number">-1</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">phi_c</span>();<br><span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(f));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i*<span class="hljs-number">2</span>;j&lt;=maxn;j+=i)<br>f[j] += i*phi[j/i];<br><br>s[<span class="hljs-number">2</span>] = f[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">3</span>;j&lt;=maxn;j++)<br>s[j] = s[j<span class="hljs-number">-1</span>] + f[j];<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,s[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
      <tag>UVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2021/07/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几天的竞赛期末考试中遇到了组合数的题目，就是 <a href="https://www.luogu.com.cn/problem/P2822">NOIP2016 组合数问题</a> 原题，正好现在数学学到了一点点排列组合，就来整理一下吧。</p><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>就是从 $n$ 个不同元素中，抽取 $m$ 个元素的方案数。</p><p>组合数公式为：</p><script type="math/tex; mode=display">\dbinom{n}{m}= \dfrac{n!}{m! \times (n-m)!}</script><p>通过杨辉三角可得到递推公式：</p><p>$\dbinom{i}{j} = \dbinom{i-1}{j-1} + \dbinom{i-1}{j}$ </p><p>还有一个递推公式（可证明）：</p><script type="math/tex; mode=display">\dbinom{i}{j} = \dfrac{n-k+1}{k} \times \dbinom{i}{j-1}</script><p>但是这个可能会乘法溢出</p><details>    <summary>证明</summary>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k} = \dfrac{n!}{k!(n-k)!} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1}{k\cdot(k-1)\dots\cdot1\cdot(n-k)\cdot(n-k-1)\dots\cdot1}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\dbinom{n}{k-1} \cdot \dfrac{n-k+1}{k} = \dfrac{n\cdot(n-1)\cdot(n-2)\dots\cdot1\cdot(n - k + 1)}{k\cdot(k-1)\dots\cdot1\cdot(n-k+1)\cdot(n-k-1)\dots\cdot1}" />    <br><br>       <img src="http://latex.codecogs.com/gif.latex? = \dbinom{n}{k}" />    <br><br>    <img src="http://latex.codecogs.com/gif.latex?\therefore" />证明完毕</details><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><ul><li><p>暴力</p><p>暴力，暴力，暴力！</p></li><li><p>预处理</p><p>用第一个递推公式先递推出来所有的数，然后对于每一次查询进行判断是否 % k == 0，时间复杂度为 $\mathcal{O}(q+tn^2)$，还是有点慢</p></li><li><p>预处理优化</p><p>我们可以想到每一判断都 % k 有点慢所以可以在预处理时 % k，判断是否等于 0 ，开过 $O2$ 95 pts，还需要优化。</p></li><li><p>前缀和+预处理</p><p>我们可以二维前缀和等于 0 的个数，然后每一次查询即可，时间复杂度变成了 $\mathcal{O}(q+t)$ ,可以过了。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p = <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">int</span> c[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">2010</span>][<span class="hljs-number">2010</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> n,m,k,t;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">complet</span><span class="hljs-params">()</span></span>&#123;<br>c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">2000</span>;i++)&#123;<br>c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>c[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>c[i][j] = (c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + c[i<span class="hljs-number">-1</span>][j]) % k;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] + f[i][j<span class="hljs-number">-1</span>] - f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];\\ 前缀和<br>        <span class="hljs-keyword">if</span>(c[i][j] == <span class="hljs-number">0</span>)f[i][j] ++;<br>        &#125;<br>        f[i][i+<span class="hljs-number">1</span>] = f[i][i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>cin&gt;&gt;t&gt;&gt;k;<br><span class="hljs-built_in">complet</span>();<br><span class="hljs-keyword">while</span>(t--)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">if</span>(m &gt; n)<br>m = n;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n][m]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>组合数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA问题</title>
    <link href="/2021/06/23/LCA%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/23/LCA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p>LCA 的问题是很经典的，我这一次就来讲解一下 LCA 的求法，就先从一道模板题入手吧</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a></p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个正整数 $N,M,S$ 分别表示树的结点个数、询问的个数和树根结点的序号。</p><p>接下来 $N-1$ 行每行包含两个正整数 $x, y$ 表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。</p><p>接下来 $M$ 行每行包含两个正整数 $a, b$ 表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。</p><h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h3><p>对于 $30\%$ 的数据，$N\leq 10，N \leq 10$。</p><p>对于 $70\%$ 的数据，$N\leq 10000，N \leq 10000$。</p><p>对于 $100\%$ 的数据，$N\leq 500000 ， N \leq 500000$</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="LCA-的一些性质"><a href="#LCA-的一些性质" class="headerlink" title="LCA 的一些性质"></a>LCA 的一些性质</h3><ul><li>两点的距离 ： $ d(u,v) = h(u) + h(v) + h(\operatorname{LCA}(u,v) )$  ，$h$ 代表某一点的深度</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li></ul><h3 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h3><p>首先，我们想到最暴力的方法，先把整个树 DFS 一下，顺便将每个点的深度记录下来，将要查找的两个点中每次找深度最大的点，然后向上跳一格，最后两个点一定会相遇，相遇的点就一定是他们的 LCA 。</p><p>下面是 DFS 的代码</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span>&#123;     <span class="hljs-comment">// fa 为父亲节点，u 为当前节点， dep 为节点深度</span><br>    f[u] = fa;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 因为是 DFS ，每个节点是从它的父亲来的，父亲与儿子的深度相差 1 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i;i = nex[i])&#123;        <span class="hljs-comment">// 链式前向星</span><br>        <span class="hljs-keyword">int</span> v = to[i]; <br>        <span class="hljs-keyword">if</span>(v != fa)<br>            <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后是 LCA 的核心代码 ：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(x != y)&#123;<br>        <span class="hljs-keyword">if</span>(dep[x] &gt;= dep[y])    x = f[x];<br>        <span class="hljs-keyword">else</span> y = f[y];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br></code></pre></div></td></tr></table></figure><p>很简单，就不详细讲了， 预处理时间复杂度是 $\mathcal{O}(n)$ ， 单次查询时间复杂度为 $\Theta(n \log n)$ （随机树上) ，时间有点慢，遇到大数据就不行了，我们需要优化 </p><h3 id="倍增-LCA"><a href="#倍增-LCA" class="headerlink" title="倍增 LCA"></a>倍增 LCA</h3><p>这里先来了解一下<strong>倍增</strong>（<a href="https://blog.csdn.net/jarjingx/article/details/8180560">更容易理解</a>），顾名思义，一倍一倍的增加，就比如一步一步跳 7 格，但是我们可以先跳 $2^2= 4$ 次，再跳 $2$ 次，最后跳 $1$ 次，原本需要跳 7 次，通过倍增只需要跳 3 次。</p><p>这里可以倍增首先基于一个推论 ：</p><ul><li><p>任意整数可以表示成若干个 2 的次幂项的和</p><p>$eg. 7 = 2^2 + 2^1 + 2^0$</p><p>$10 = 2^3 + 2^1$</p></li></ul><p>下面来讲一下倍增 LCA :</p><p>显然可以将一步一步跳变成倍增，在 DFS 时可以通过 $2^i = 2^{i-1}+2^{i-1}$ 预处理 $fa_i$ 的位置。</p><p>在查询时可以从小到大倍增（$2^0,2^1,2^2\dots$）来将 $u,v$ 跳到同一深度，在同时    跳的时候从大到小倍增（$2^i,2^{i-1}\dots 2^1,2^0$），如果两个父亲不一样，就跳，那么最后的 LCA 是 $fa_0$ </p><p>倍增 LCA 预处理时间复杂度为 $\mathcal{O}(n \log n)$ ，单次查询时间为 $\mathcal{O}(\log n)$ 。</p><p>这个时间复杂度大部分题目都是可以接受的。</p><p>代码： </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;<br>    dep[u] = dep[v] + <span class="hljs-number">1</span>;<br>    fa[u][<span class="hljs-number">0</span>] = v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)<br>        fa[u][i] = fa[fa[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;G[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(G[u][i] == v)    <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(G[u][i],u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[x] &gt; dep[y])        <span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">int</span> tmp = dep[y] - dep[x];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;tmp;i++,tmp &gt;&gt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">1</span>)<br>            y = fa[y][i];<br>    <span class="hljs-keyword">if</span>(x == y)    <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span> &amp;&amp; x != y;i--)<br>        <span class="hljs-keyword">if</span>(fa[x][i] != fa[y][i])&#123;x = fa[x][i];y = fa[y][i];&#125;<br>    <span class="hljs-keyword">return</span> fa[x][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF1A Theatre Square</title>
    <link href="/2021/05/16/CF1A-Theatre-Square/"/>
    <url>/2021/05/16/CF1A-Theatre-Square/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用 $a \times a$ 的石板覆盖 $n \times m$ 的长方形广场，允许石板覆盖的区域超出广场，不允许打破石板，石板的两侧应平行于广场两侧，要求覆盖完广场所需的石板数量最少是多少。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入有三个数字 $n,m,a$ ($1≤n,m,a≤10^9$)</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，我们看到是广场是长方形的，而石板是正方形的，<del>很容易就想到</del>可能会出现一中特殊情况：（广场的面积不足以铺一个石板），还会想到将长和宽一起除以石板边长，就是这个边所可以容纳多少个石板边长，最后再将所得的个数相乘，就是我们的答案了。<br><img src="https://z3.ax1x.com/2021/05/16/gcWxnP.png" alt="gcWxnP.png"></p><p>$AC$ 代码：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,a;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;a;<br>cout&lt;&lt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(<span class="hljs-built_in">ceil</span>(n/(<span class="hljs-keyword">double</span>)a)*<span class="hljs-built_in">ceil</span>(m/(<span class="hljs-keyword">double</span>)a))&lt;&lt;endl;<span class="hljs-comment">//注意一定要long long 不然就会强制转换为科学计数法</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></div></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简单题</tag>
      
      <tag>CodeForces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3383 【模板】线性筛素数</title>
    <link href="/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/04/07/P3383-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://www.luogu.com.cn/problem/P3383">P3383 【模板】线性筛素数</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，给定一个范围$n$，有$q$个询问，每次输出第$k$小的素数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。</p><p>接下来$q$行每行一个正整数$k$，表示查询第$k$小的素数。  </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出$q$行，每行一个正整数表示答案。</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $100\%$ 的数据，$n = 10^8,1≤q≤10^6$，保证查询的素数不大于$n$。</p><h1 id="知识-题解"><a href="#知识-题解" class="headerlink" title="知识/题解"></a>知识/题解</h1><p>这题是一道筛法模版题，第一个先想到的应该是暴力枚举，但是暴力枚举时间复杂度显然太高，然后经过一番搜寻，找到了埃式筛。</p><h3 id="埃式筛"><a href="#埃式筛" class="headerlink" title="埃式筛"></a>埃式筛</h3><p>这个筛法的时间复杂度为$O(n\log\log n)$,算的上是比较优秀了。</p><blockquote><p>如果$x$是合数，那么$x$的倍数也一定是合数。  </p></blockquote><p>这个规则很容易就知道了是对的，是吧，这样我们要求100以内的数就只需将1到10以内的倍数枚举并标记，没有标记的数就是质数，这个筛法就是这个思想。<br>埃式筛的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) is_prime[i] = <span class="hljs-number">1</span>;<br>  is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>      prime[p++] = i;  <span class="hljs-comment">// prime[p]是i,后置自增运算代表当前素数数量</span><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)<br>          <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span><br>          <span class="hljs-comment">// 的倍数开始，提高了运行速度</span><br>          is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><p>但是这个还是有点慢，这个数据可能会过不了，所以我们又找到了另一个更快的算法：欧拉筛（线性筛）。</p><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记，所以线性筛就是来解决这个事情的。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; MAXN; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>      prime[cnt++] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * i * prime[j] &gt;= MAXN) <span class="hljs-keyword">break</span>;<br>      vis[i * prime[j]] = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 换言之，i 之前被 pri[j] 筛过了</span><br>        <span class="hljs-comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是</span><br>        <span class="hljs-comment">// pri[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break</span><br>        <span class="hljs-comment">// 掉就好了</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="本题AC代码"><a href="#本题AC代码" class="headerlink" title="本题AC代码"></a>本题AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">bool</span> visited[<span class="hljs-number">100000010</span>];<br><span class="hljs-keyword">int</span> prime[<span class="hljs-number">6000010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shai</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!visited[i])prime[cnt++] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br><span class="hljs-keyword">if</span>(i * prime[j] &gt; n)<br><span class="hljs-keyword">break</span>;<br>visited[i * prime[j]] = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m,x;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">shai</span>(n);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,prime[x<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>筛法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1029 [NOIP2001 普及组] 最大公约数和最小公倍数</title>
    <link href="/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    <url>/2021/04/02/P1029-NOIP2001-%E6%99%AE%E5%8F%8A%E7%BB%84-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个正整数$x_0, y_0$，求出满足下列条件的$P, Q$的个数:  </p><ol><li>$P,Q$ 是正整数。</li><li>要求 $P, Q$ 以 $x_0$为最大公约数，以$y_0$为最小公倍数。</li></ol><p>试求：满足条件的所有可能的$P, Q$的个数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行两个正整数$x_0, y_0$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个数，表示求出满足条件的$P, Q$个数。    </p><h1 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h1><p>这一题是关于最大公约数（gcd）和最小公倍数（lcm）的，首先要算最大公约数，最好的算法是<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352">欧几里得算法</a>（辗转相除法）然而本人是个蒟蒻，所以还是要来证明一下的：</p><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>设 $a=bk+c$ 则有 $c= a\bmod b$ ,设有一个数 $d \mid a~,d \mid b$（这个符号表示前者是后者的因数，能整除）,<br>则存在 $c=a-bk$ ， $\dfrac{c}{d} = \dfrac{a-b}{d}k$。<br>显而易见，$\dfrac{c}{d}$ 为整数，所以对于 $a$ 与 $b$ 的最大公约数为 $a\bmod b$ 的最大公约数（因为c为$c= a\bmod b$），<br>所以 $ \gcd(a,b) = \gcd(a,a\bmod b)$ ,而这，就是欧几里得算法的核心内容。(终于结束了)下面给出欧几里得算法的代码：    </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><br><br>下面我们来讲最小公倍数的算法，最小公倍数可以通过最大公约数来求.</p><h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><p>首先我们介绍这样一个定理——算术基本定理： </p><blockquote><p>每一个正整数都可以表示成若干整数的乘积，这种分解方式在忽略排列次序的条件下是唯一的。</p></blockquote><p>这个有一个通式 $\large x=p_1^{k_1}p_2^{k_2}p_3^{k_3}\dots b p_s^{k_s}$  </p><p>设  <script type="math/tex">\large a=p_1^{k_{a_1}}p_2^{k_{a_2}}p_3^{k_{a_3}} \dots p_s^{k_{a_s}} ,\large b=p_1^{k_{b_1}}p_2^{k_{b_2}}p_3^{k_{b_3}}\dotsb p_s^{k_{b_s}}</script>    </p><p> 可以得到，最大公约数为：  </p><script type="math/tex; mode=display">\large p_1^{\min(k_{a_1},k_{b_1})}p_2^{\min(k_{a_2},k_{b_2})}\dotsb p_s^{\min(k_{a_s},k_{b_s})}</script><p>最小公倍数为：  </p><script type="math/tex; mode=display">\large p_1^{\max(k_{a_1},k_{b_1})}p_2^{\max(k_{a_2},k_{b_2})}\dotsb p_s^{\max(k_{a_s},k_{b_s})}</script><p>将以上两个式子相乘，可以得到:</p><blockquote><p>$ \large \gcd(a,b)\times \operatorname{lcm}(a,b)=a\times b$ </p></blockquote><p>将上面的式子进行移项，就终于得到了这个重要的计算方法（呼，累死我了）： </p><blockquote><p>$\large \operatorname{lcm}(a,b) = a\times b \div \gcd(a,b)$</p></blockquote><h2 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h2><p>那么，这道题基本的知识都讲完了，总结一下思路：<br>首先我们可以枚举$P$，那么$Q$可通过已经给的最小公倍数和最大公约数来求，然后再算出本身这两个数的最小公倍数和最大公约数，判断它们是否相等。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">LL <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123; <span class="hljs-comment">//最大公约数的算法</span><br><span class="hljs-keyword">return</span>  b==<span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>LL n,m,ans = <span class="hljs-number">0</span>;<br>cin&gt;&gt;n&gt;&gt;m;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(m*n);i++)&#123;  <span class="hljs-comment">//枚举到sqrt个即可</span><br><span class="hljs-keyword">if</span>(n==m)&#123;<br>ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">int</span> j = m*n/i;  <br>LL x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>LL cnt = <span class="hljs-built_in">gcd</span>(i,j);<br><span class="hljs-keyword">if</span>(cnt == n &amp;&amp; i*j/cnt == m)   <span class="hljs-comment">//i*j/cnt 是算最大公约数的算法</span><br>ans += <span class="hljs-number">2</span>;<br>&#125;<br><br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCM</tag>
      
      <tag>GCD</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树(模板)</title>
    <link href="/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/02/20/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这是个模板题<br><strong>链接</strong>:<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 $ N,M $ ，表示该图共有 $ N $ 个结点和 $ M $ 条无向边。<br>接下来 $ M $ 行每行包含三个整数 $ X_i,Y_i,Z_i $ ,示有一条长度为 $ Z_i $ 的无向边连接结点 $ X_i,Y_i $。 </p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。</p><h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>对于 20% 的数据，$ N≤5，M≤20 $ 。</p><p>对于 40% 的数据，$ N≤50，M≤2500 $ 。</p><p>对于 70% 的数据，$ N≤500，M≤10 $ 。</p><p>对于 100\%100% 的数据：$ 50001≤N≤5000， 1≤M≤2×10^5 $ 。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>Kruskal 算法的主要思路：</p><ol><li>先以边的权值来给边排序，从小到大  </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8YcQ.png" alt="dis0"></p><ol><li>然后开始由小到大遍历边，也就是一步一步的点的扩展       </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8J1g.png" alt="dis1"></p><ol><li>然后判断这个点的是否在已拓展的点内，如果不在就将答案加上它的边权，并且加入并查集  </li></ol><p><img src="https://z3.ax1x.com/2021/09/08/hb8G9S.png" alt="dis2"></p><p><img src="https://z3.ax1x.com/2021/09/08/hb81tf.png" alt="dis3"></p><p><img src="https://z3.ax1x.com/2021/09/08/hb83h8.png" alt="dis4"></p><p><strong>注意一下，这个是用邻接表edge写的（u，v为边的两个点，为边权），没有用领接矩阵</strong></p><p>基本上这个模板就这样了，代码如下：</p><p>​    </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span> <br><span class="hljs-keyword">int</span> u,v,w;    <span class="hljs-comment">//定义一个边的结构体，u、v为边的两个定点，w为边的边权</span><br>&#125;;<br><br><br><br>edge e[<span class="hljs-number">200005</span>];<br><span class="hljs-keyword">int</span> father[<span class="hljs-number">5005</span>];      <span class="hljs-comment">//并查集</span><br><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> edge&amp; a,<span class="hljs-keyword">const</span> edge&amp; b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w &lt; b.w;        <span class="hljs-comment">//sort（）的判断，以边权的由大到小的顺序来排序 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">found</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;          <span class="hljs-comment">//并查集的寻找父亲</span><br><span class="hljs-keyword">return</span> father[x] == x ? x : father[x] = <span class="hljs-built_in">found</span>(father[x]);        <span class="hljs-comment">//压行，并且压缩路径，这样可以将之后的查找时间变为常数级</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n,m;<br><br>cin&gt;&gt;n&gt;&gt;m;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>&#125;<br><br><span class="hljs-built_in">sort</span>(e,e+m,cmp);    <span class="hljs-comment">//kruskal 算法的重要部分：按照边权的大小来排序</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)father[j] = j;  <span class="hljs-comment">//初始化，每一个点都是一个自己的父亲</span><br><br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(k == n - <span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">int</span> v = e[j].v,u = e[j].u;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">found</span>(v) != <span class="hljs-built_in">found</span>(u))        <span class="hljs-comment">//如果没有这个边所在的点没有加入，就执行下面</span><br>&#123;<br>k++;   <span class="hljs-comment">//注意一点：这一句话一定要在这里写，我已经掉过坑里了</span><br>ans += e[j].w;    <span class="hljs-comment">//加入答案：最小生成树的总长</span><br><br><span class="hljs-keyword">int</span> f = <span class="hljs-built_in">found</span>(v),t = <span class="hljs-built_in">found</span>(u);<br>father[t] = f;          <span class="hljs-comment">//使这个的边的这个点加入路径</span><br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(father[i] == i)<br>                cnt++;<br><br><br><span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;orz&quot;</span>&lt;&lt;endl;        <span class="hljs-comment">//如果有边不联通，就输出“orz”</span><br><span class="hljs-built_in">getchar</span>();<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kruskal</tag>
      
      <tag>最小生成树</tag>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过河卒</title>
    <link href="/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/"/>
    <url>/2021/02/18/%E8%BF%87%E6%B2%B3%E5%8D%92/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="过河卒"><a href="#过河卒" class="headerlink" title="过河卒"></a>过河卒</h1><p><strong>本题链接</strong>：<a href="https://www.luogu.com.cn/problem/P1002">p1002 过河卒</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $ A $ 点有一个过河卒，需要走到目标$ B $点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $ C $ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$ A $ 点 $ (0,0) $ 、$ B $ 点 $ (n,m) $ ，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从 $ A $ 点能够到达 $ B $ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。  </p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $ B $ 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p>对于100%的数据, $ 1≤n,m≤20 $ ，$ 0≤ $ 马的坐标 $ ≤20 $。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><p>我看到这题时，我就想到用递推来做这题</p><h4 id="1-根据题意并根据样例，第一步可以写出下列-（简单的）-表格："><a href="#1-根据题意并根据样例，第一步可以写出下列-（简单的）-表格：" class="headerlink" title="1. 根据题意并根据样例，第一步可以写出下列 （简单的） 表格："></a>1. 根据题意并根据样例，第一步可以写出下列 <del>（简单的）</del> 表格：</h4><div class="table-container"><table><thead><tr><th style="text-align:right"></th><th style="text-align:right">[0]</th><th style="text-align:right">[1]</th><th style="text-align:right">[2]</th><th style="text-align:right">[3]</th><th style="text-align:right">[4]</th><th style="text-align:right">[5]</th><th style="text-align:right">[6]</th></tr></thead><tbody><tr><td style="text-align:right">[0]</td><td style="text-align:right">0</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td><td style="text-align:right">1</td></tr><tr><td style="text-align:right">[1]</td><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">5</td><td style="text-align:right">6</td><td style="text-align:right">7</td></tr><tr><td style="text-align:right">[2]</td><td style="text-align:right">1</td><td style="text-align:right">3</td><td style="text-align:right">6</td><td style="text-align:right">10</td><td style="text-align:right">15</td><td style="text-align:right">21</td><td style="text-align:right">28</td></tr><tr><td style="text-align:right">[3]</td><td style="text-align:right">1</td><td style="text-align:right">4</td><td style="text-align:right">10</td><td style="text-align:right">20</td><td style="text-align:right">35</td><td style="text-align:right">56</td><td style="text-align:right">84</td></tr><tr><td style="text-align:right">[4]</td><td style="text-align:right">1</td><td style="text-align:right">5</td><td style="text-align:right">15</td><td style="text-align:right">35</td><td style="text-align:right">70</td><td style="text-align:right">135</td><td style="text-align:right">219</td></tr><tr><td style="text-align:right">[5]</td><td style="text-align:right">1</td><td style="text-align:right">6</td><td style="text-align:right">21</td><td style="text-align:right">56</td><td style="text-align:right">126</td><td style="text-align:right">261</td><td style="text-align:right">370</td></tr><tr><td style="text-align:right">[6]</td><td style="text-align:right">1</td><td style="text-align:right">7</td><td style="text-align:right">28</td><td style="text-align:right">84</td><td style="text-align:right">210</td><td style="text-align:right">471</td><td style="text-align:right">841</td></tr></tbody></table></div><p><del>（显而易见）</del>，这里可以利用<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86/7538330?fr=aladdin">加法原理</a>，写出<strong>递推式</strong>：</p><script type="math/tex; mode=display">f[i][j]=f[i-1][j]+f[i][j-1];(start:f[0][0]=1)</script><h4 id="2-第二步再加上马的影响"><a href="#2-第二步再加上马的影响" class="headerlink" title="2. 第二步再加上马的影响"></a>2. 第二步再加上马的影响</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">[0]</th><th style="text-align:center">[1]</th><th style="text-align:center">[2]</th><th style="text-align:center">[3]</th><th style="text-align:center">[4]</th><th style="text-align:center">[5]</th><th style="text-align:center">[6]</th></tr></thead><tbody><tr><td style="text-align:center">[0]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">[1]</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">[2]</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">[3]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[4]</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[5]</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">[6]</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">6</td></tr></tbody></table></div><p>根据这个表格，我们可以想到先把马的控制点，也就是马能到达的地方（包括他本身的这个点，做一个预处理，之后递推的时候，如果到达马的控制点，直接跳过，继续下一个点。</p><p>基本思路就是这样，但是在测评中发现了第三个点：只有long long类型才能AC。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>   </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,x,y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> map[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>]=&#123;&#123;<span class="hljs-number">1</span>&#125;&#125;;  \\递推开始式为f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">bool</span> horse[<span class="hljs-number">42</span>][<span class="hljs-number">42</span>];<br><span class="hljs-keyword">int</span> hx[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>&#125;,  \\马的位移<br>hy[<span class="hljs-number">9</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">8</span>;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx=x+hx[i],yy=y+hy[i];<br><span class="hljs-keyword">if</span> (xx&gt;n||xx&lt;<span class="hljs-number">0</span>||yy&gt;m||yy&lt;<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>horse[xx][yy]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!horse[<span class="hljs-number">0</span>][++k]&amp;&amp;k&lt;=m)<br>map[<span class="hljs-number">0</span>][k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!horse[++l][<span class="hljs-number">0</span>]&amp;&amp;l&lt;=n)<br>map[l][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-keyword">if</span> (!horse[i][j])<br>map[i][j]=map[i<span class="hljs-number">-1</span>][j]+map[i][j<span class="hljs-number">-1</span>];   \\递推式<br>cout&lt;&lt;map[n][m]&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递推</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
